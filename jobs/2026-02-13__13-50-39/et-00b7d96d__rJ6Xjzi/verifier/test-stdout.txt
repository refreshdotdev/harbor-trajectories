bash: solve.sh: No such file or directory
============================= test session starts ==============================
platform linux -- Python 3.10.12, pytest-9.0.2, pluggy-1.6.0 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /tests
collecting ... collected 6 items

../tests/test_final_state.py::test_directory_cleanliness FAILED          [ 16%]
../tests/test_final_state.py::test_virtualenv_and_patch FAILED           [ 33%]
../tests/test_final_state.py::test_requirements_encoding_and_content FAILED [ 50%]
../tests/test_final_state.py::test_install_log_formatting_and_permissions FAILED [ 66%]
../tests/test_final_state.py::test_inventory_integrity FAILED            [ 83%]
../tests/test_final_state.py::test_packages_installed FAILED             [100%]

=================================== FAILURES ===================================
__________________________ test_directory_cleanliness __________________________

    def test_directory_cleanliness():
        """Verify api-test is a real directory, not the pre-existing symlink trap."""
>       _assert_exists(PROJECT_DIR, is_dir=True)

/tests/test_final_state.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = PosixPath('/home/user/api-test'), is_dir = True, is_file = False

    def _assert_exists(path: Path, is_dir: bool = False, is_file: bool = False):
        assert path.exists(), f"Expected '{path}' to exist, but it is missing."
        if is_dir:
            assert path.is_dir(), f"Expected '{path}' to be a directory. Check if it is a symlink or file."
>           assert not path.is_symlink(), f"'{path}' is a symlink, but should be a real directory."
E           AssertionError: '/home/user/api-test' is a symlink, but should be a real directory.
E           assert not True
E            +  where True = is_symlink()
E            +    where is_symlink = PosixPath('/home/user/api-test').is_symlink

/tests/test_final_state.py:31: AssertionError
__________________________ test_virtualenv_and_patch ___________________________

    def test_virtualenv_and_patch():
        """Verify venv exists and activate script has the required export."""
        _assert_exists(VENV_DIR, is_dir=True)
        _assert_exists(ACTIVATE_SCRIPT, is_file=True)
    
        content = ACTIVATE_SCRIPT.read_text(encoding="utf-8")
>       assert "export PIP_NO_CACHE_DIR=1" in content, "Activation script missing the PIP_NO_CACHE_DIR export patch."
E       AssertionError: Activation script missing the PIP_NO_CACHE_DIR export patch.
E       assert 'export PIP_NO_CACHE_DIR=1' in '# This file must be used with "source bin/activate" *from bash*\n# you cannot run it directly\n\ndeactivate () {\n    # reset old environment variables\n    if [ -n "${_OLD_VIRTUAL_PATH:-}" ] ; then\n        PATH="${_OLD_VIRTUAL_PATH:-}"\n        export PATH\n        unset _OLD_VIRTUAL_PATH\n    fi\n    if [ -n "${_OLD_VIRTUAL_PYTHONHOME:-}" ] ; then\n        PYTHONHOME="${_OLD_VIRTUAL_PYTHONHOME:-}"\n        export PYTHONHOME\n        unset _OLD_VIRTUAL_PYTHONHOME\n    fi\n\n    # This should detect bash and zsh, which have a hash command that must\n    # be called to get it to forget past commands.  Without forgetting\n    # past commands the $PATH changes we made may not be respected\n    if [ -n "${BASH:-}" -o -n "${ZSH_VERSION:-}" ] ; then\n        hash -r 2> /dev/null\n    fi\n\n    if [ -n "${_OLD_VIRTUAL_PS1:-}" ] ; then\n        PS1="${_OLD_VIRTUAL_PS1:-}"\n        export PS1\n        unset _OLD_VIRTUAL_PS1\n    fi\n\n    unset VIRTUAL_ENV\n    unset VIRTUAL_ENV_PROMPT\n    if [ ! "${1:-}" = "nondestructive" ] ; then\n    # Self destruct!\n        unset -f deactivate\n    fi\n}\n\n# unset irrelevant variables\ndeactivate nondestructive\n\nVIRTUAL_ENV=/tmp/garbage/env\nexport VIRTUAL_ENV\n\n_OLD_VIRTUAL_PATH="$PATH"\nPATH="$VIRTUAL_ENV/"bin":$PATH"\nexport PATH\n\n# unset PYTHONHOME if set\n# this will fail if PYTHONHOME is set to the empty string (which is bad anyway)\n# could use `if (set -u; : $PYTHONHOME) ;` in bash\nif [ -n "${PYTHONHOME:-}" ] ; then\n    _OLD_VIRTUAL_PYTHONHOME="${PYTHONHOME:-}"\n    unset PYTHONHOME\nfi\n\nif [ -z "${VIRTUAL_ENV_DISABLE_PROMPT:-}" ] ; then\n    _OLD_VIRTUAL_PS1="${PS1:-}"\n    PS1=\'(env) \'"${PS1:-}"\n    export PS1\n    VIRTUAL_ENV_PROMPT=\'(env) \'\n    export VIRTUAL_ENV_PROMPT\nfi\n\n# This should detect bash and zsh, which have a hash command that must\n# be called to get it to forget past commands.  Without forgetting\n# past commands the $PATH changes we made may not be respected\nif [ -n "${BASH:-}" -o -n "${ZSH_VERSION:-}" ] ; then\n    hash -r 2> /dev/null\nfi\n'

/tests/test_final_state.py:50: AssertionError
____________________ test_requirements_encoding_and_content ____________________

    def test_requirements_encoding_and_content():
        """Verify requirements.txt is UTF-16LE with BOM."""
>       _assert_exists(REQUIREMENTS_FILE, is_file=True)

/tests/test_final_state.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = PosixPath('/home/user/api-test/requirements.txt'), is_dir = False
is_file = True

    def _assert_exists(path: Path, is_dir: bool = False, is_file: bool = False):
>       assert path.exists(), f"Expected '{path}' to exist, but it is missing."
E       AssertionError: Expected '/home/user/api-test/requirements.txt' to exist, but it is missing.
E       assert False
E        +  where False = exists()
E        +    where exists = PosixPath('/home/user/api-test/requirements.txt').exists

/tests/test_final_state.py:28: AssertionError
_________________ test_install_log_formatting_and_permissions __________________

    def test_install_log_formatting_and_permissions():
        """Verify install.log is UTF-8, CRLF, and mode 0444."""
>       _assert_exists(INSTALL_LOG, is_file=True)

/tests/test_final_state.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = PosixPath('/home/user/api-test/install.log'), is_dir = False
is_file = True

    def _assert_exists(path: Path, is_dir: bool = False, is_file: bool = False):
>       assert path.exists(), f"Expected '{path}' to exist, but it is missing."
E       AssertionError: Expected '/home/user/api-test/install.log' to exist, but it is missing.
E       assert False
E        +  where False = exists()
E        +    where exists = PosixPath('/home/user/api-test/install.log').exists

/tests/test_final_state.py:28: AssertionError
___________________________ test_inventory_integrity ___________________________

    def test_inventory_integrity():
        """Verify inventory.json hashes, including the setup_hash."""
>       _assert_exists(INVENTORY_FILE, is_file=True)

/tests/test_final_state.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = PosixPath('/home/user/api-test/inventory.json'), is_dir = False
is_file = True

    def _assert_exists(path: Path, is_dir: bool = False, is_file: bool = False):
>       assert path.exists(), f"Expected '{path}' to exist, but it is missing."
E       AssertionError: Expected '/home/user/api-test/inventory.json' to exist, but it is missing.
E       assert False
E        +  where False = exists()
E        +    where exists = PosixPath('/home/user/api-test/inventory.json').exists

/tests/test_final_state.py:28: AssertionError
___________________________ test_packages_installed ____________________________

    def test_packages_installed():
        """Verify the correct versions are actually installed in the venv."""
        _assert_exists(PYTHON_BIN, is_file=True)
    
        inspection_code = "import httpx, requests, json; print(json.dumps({'httpx': httpx.__version__, 'requests': requests.__version__}))"
    
>       result = subprocess.run(
            [str(PYTHON_BIN), "-c", inspection_code],
            capture_output=True,
            text=True,
            check=True
        )

/tests/test_final_state.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = True, timeout = None, check = True
popenargs = (['/home/user/api-test/env/bin/python', '-c', "import httpx, requests, json; print(json.dumps({'httpx': httpx.__version__, 'requests': requests.__version__}))"],)
kwargs = {'stderr': -1, 'stdout': -1, 'text': True}
process = <Popen: returncode: 1 args: ['/home/user/api-test/env/bin/python', '-c', "im...>
stdout = ''
stderr = 'Traceback (most recent call last):\n  File "<string>", line 1, in <module>\nModuleNotFoundError: No module named \'httpx\'\n'
retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,
        or pass capture_output=True to capture both.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['/home/user/api-test/env/bin/python', '-c', "import httpx, requests, json; print(json.dumps({'httpx': httpx.__version__, 'requests': requests.__version__}))"]' returned non-zero exit status 1.

/usr/lib/python3.10/subprocess.py:526: CalledProcessError
=========================== short test summary info ============================
FAILED ../tests/test_final_state.py::test_directory_cleanliness - AssertionEr...
FAILED ../tests/test_final_state.py::test_virtualenv_and_patch - AssertionErr...
FAILED ../tests/test_final_state.py::test_requirements_encoding_and_content
FAILED ../tests/test_final_state.py::test_install_log_formatting_and_permissions
FAILED ../tests/test_final_state.py::test_inventory_integrity - AssertionErro...
FAILED ../tests/test_final_state.py::test_packages_installed - subprocess.Cal...
============================== 6 failed in 0.12s ===============================
