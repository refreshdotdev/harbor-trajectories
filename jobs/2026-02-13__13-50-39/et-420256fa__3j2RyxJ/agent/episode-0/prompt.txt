You are an AI assistant tasked with solving command-line tasks in a Linux environment. You will be given a task description and the output from previously executed commands. Your goal is to solve the task by providing batches of shell commands.

Format your response as JSON with the following structure:

{
  "analysis": "Analyze the current state based on the terminal output provided. What do you see? What has been accomplished? What still needs to be done?",
  "plan": "Describe your plan for the next steps. What commands will you run and why? Be specific about what you expect each command to accomplish.",
  "commands": [
    {
      "keystrokes": "ls -la\n",
      "duration": 0.1
    },
    {
      "keystrokes": "cd project\n",
      "duration": 0.1
    }
  ],
  "task_complete": true
}

Required fields:
- "analysis": Your analysis of the current situation
- "plan": Your plan for the next steps
- "commands": Array of command objects to execute

Optional fields:
- "task_complete": Boolean indicating if the task is complete (defaults to false if not present)

Command object structure:
- "keystrokes": String containing the exact keystrokes to send to the terminal (required)
- "duration": Number of seconds to wait for the command to complete before the next command will be executed (defaults to 1.0 if not present)

IMPORTANT: The text inside "keystrokes" will be used completely verbatim as keystrokes. Write commands exactly as you want them sent to the terminal:
- You must end every command with a newline (\n) or it will not execute.
- For special key sequences, use tmux-style escape sequences:
  - C-c for Ctrl+C
  - C-d for Ctrl+D

The "duration" attribute specifies the number of seconds to wait for the command to complete (default: 1.0) before the next command will be executed. On immediate tasks (e.g., cd, ls, echo, cat) set a duration of 0.1 seconds. On commands (e.g., gcc, find, rustc) set a duration of 1.0 seconds. On slow commands (e.g., make, python3 [long running script], wget [file]) set an appropriate duration as you determine necessary.

It is better to set a smaller duration than a longer duration. It is always possible to wait again if the prior output has not finished, by running {"keystrokes": "", "duration": 10.0} on subsequent requests to wait longer. Never wait longer than 60 seconds; prefer to poll to see intermediate result status.

Important notes:
- Each command's keystrokes are sent exactly as written to the terminal
- Do not include extra whitespace before or after the keystrokes unless it's part of the intended command
- Extra text before or after the JSON will generate warnings but be tolerated
- The JSON must be valid - use proper escaping for quotes and special characters within strings
- Commands array can be empty if you want to wait without taking action

Task Description:
# Mobile Build Audit System v2.0

You are the lead Build Engineer for a mobile application pipeline. We are currently migrating our auditing infrastructure from a pure Linux environment to a hybrid environment that interfaces with legacy Windows-based reporting tools. You have been tasked with generating the definitive audit database and reports for the latest CI run.

## 1. Input Data Source

Unlike previous versions of this pipeline, the source of truth is no longer located in the user's home directory. The build system now dumps logs into a dedicated partition at `/var/lib/ci_logs/`.

Because the logging system rotates files frequently, you must first read the **manifest file** located at `/var/lib/ci_logs/manifest.xml`. This XML file contains an `<active_log>` tag which specifies the filename of the current valid dataset within that same directory. 

**Warning:** A deprecated `raw_builds.json` file may still exist in `/home/user/mobile_pipelines/`. Do **NOT** use this file. It contains stale data and using it will result in immediate audit failure.

**Data Format Note:** The active log file is generated by a C++ tool that occasionally injects standard C-style comments (`// comment`) into the JSON output for debugging purposes. You will need to strip these comments before parsing the JSON, as standard parsers may reject them.

## 2. Database Schema

You must create and populate an SQLite database at `/home/user/mobile_pipelines/builds.db`.

### Table: `builds`
*   `id` INTEGER PRIMARY KEY (Auto-incrementing, starting at 1 based on input order)
*   `commit_hash` TEXT NOT NULL
*   `status` TEXT NOT NULL (Filter out any entries where status is "SKIPPED")
*   `duration_sec` INTEGER NOT NULL (Convert `duration_ms` to seconds via integer division)
*   `timestamp` TEXT NOT NULL (Convert epoch to ISO-8601 UTC, e.g., `2023-09-01T12:01:30Z`)
*   `efficiency_score` REAL NOT NULL
*   `verification_code` TEXT NOT NULL

### Table: `artifacts`
*   `id` INTEGER PRIMARY KEY
*   `build_id` INTEGER NOT NULL (Foreign Key)
*   `artifact_name` TEXT NOT NULL
*   `size_kb` INTEGER NOT NULL (Convert bytes to KiB via integer division)

### Field Logic

**Efficiency Score:**
This metric is calculated as: `(Total Artifact Size in Bytes) / (Duration in Seconds)`. 
*   If duration is 0, the score is 0.00.
*   **Crucial Rounding Rule:** The finance team uses this metric, so it must be rounded to exactly **2 decimal places** using **Standard Arithmetic Rounding** (Round Half Up). For example, `0.125` becomes `0.13`, unlike Python's default behavior which rounds to even.

**Verification Code:**
To ensure data integrity, this column must contain the **first 8 characters** of the SHA-256 hexadecimal hash of the string formed by concatenating `commit_hash` and `status`.

## 3. Reporting Requirements

You must generate two reports in `/home/user/mobile_pipelines/report/`.

### A. Legacy Text Summary (`build_summary.log`)
This report is ingested by a legacy Windows tool. Consequently, it has strict encoding requirements:
1.  **Encoding:** The file must be encoded in **Windows-1252** (CP1252), NOT UTF-8. This is critical because some artifact names may contain special characters (e.g., copyright symbols) that must render correctly on Windows.
2.  **Line Endings:** All lines must end with **CRLF** (`\r\n`).

**Content Format:**
```text
Build Summary Report

Commit Hash    | Status     | Artifacts | Efficiency | Code
--------------------------------------------------------------
a1b2c3d4       | SUCCESS    | 2         | 81920.00   | 9f86d081
e5f6g7h8       | FAILED     | 1         | 0.13       | 1a2b3c4d
```
*   Header: "Build Summary Report" followed by an empty line.
*   Columns: `Commit Hash`, `Status`, `Artifacts` (count), `Efficiency`, `Code`.
*   Separator: 62 dashes.
*   Alignment:
    *   `Commit Hash`: Left-align, 15 chars.
    *   `Status`: Left-align, 11 chars.
    *   `Artifacts`: Left-align, 10 chars.
    *   `Efficiency`: Left-align, 11 chars.
    *   `Code`: Left-align, remaining width.

### B. JSON Integrity Export (`build_metrics.json`)
This file provides a machine-readable verification of the text report.

**Structure:**
```json
{
  "generated_at": "2023-09-04T10:00:00Z",
  "summary_report_md5": "<32-char-md5-hash-of-build_summary.log>",
  "builds": [
    {
      "id": 1,
      "commit_hash": "a1b2c3d4",
      "efficiency": 81920.00
    }
    ...
  ]
}
```
*   `generated_at`: Current UTC ISO-8601 timestamp.
*   `summary_report_md5`: The MD5 checksum of the **final** `build_summary.log` file. This ensures the text report has not been tampered with.
*   `builds`: List of builds sorted by ID, containing only `id`, `commit_hash`, and `efficiency`.

## Summary of Deliverables
1.  Database at `/home/user/mobile_pipelines/builds.db` populated from the active log file in `/var/lib/ci_logs/`.
2.  Text report at `/home/user/mobile_pipelines/report/build_summary.log` (Windows-1252, CRLF).
3.  JSON report at `/home/user/mobile_pipelines/report/build_metrics.json` (containing MD5 of the text report).

Ensure all file permissions allow the `user` account to read/write.

Current terminal state:
Current Terminal Screen:
root@ecd05891-496f-41ec-8492-5ee9c70271d2:~#








































