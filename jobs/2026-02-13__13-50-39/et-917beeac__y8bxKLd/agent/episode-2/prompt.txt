New Terminal Output:

root@6fc9b5d9-ea74-43ac-8d2d-c85d12cffe93:~# cat > solve.sh << 'EOF'
> #!/bin/bash
 original CSV to raw backup
        mv "${csv_file}" "${RAW_BACKUP_DIR}/"

        # Keep track of total records
        total_records=$((total_records + row_count))

        echo "  Processed successfully (${row_count} records)"
    done

    echo "Total valid records processed: ${total_records}"

    # Create manifest file
    create_manifest "${manifest_files[@]}" "${manifest_hashes[@]}" "${manifest_row_counts[@]}" "${total_records}"

    # Create archive
    create_archive "${total_records}"

    # Extract to staging
    extract_to_staging

    # Sort orders file
    sort_orders_file
}

# Create manifest file
create_manifest() {
    local -n files=$1
    local -n hashes=$2
    local -n row_counts=$3
    local total_records=$4

    echo "Creating manifest file: ${MANIFEST_FILE}"

    # Create ISO-8859-1 encoded manifest file
    # Use iconv to convert to Latin-1 encoding
    {
        echo "Legacy ETL Manifest © 2023"

        # Combine arrays into lines
        for i in "${!files[@]}"; >
> # Legacy Data Ingestion Script
> # Author: Hermes AI
> # Date: $(date +'%Y-%m-%d')
>
> set -euo pipefail
>
> # --- Configuration ---
> CONFIG_FILE="/etc/legacy_etl/settings.conf"
> INCOMING_DIR="/home/user/incoming"
> QUARANTINE_DIR="/home/user/etl/quarantine"
> ARCHIVE_DIR="/home/user/etl/archive"
> RAW_BACKUP_DIR="/home/user/etl/raw_backup"
> STAGING_DIR="/home/user/etl/staging"
> LOG_DIR="/home/user/etl/logs"
> MANIFEST_FILE="${LOG_DIR}/process_manifest.txt"
>
+> echo "Starting Legacy ETL Process at $(date)"
>
> # --- Helper Functions ---
>
> # Read configuration file
> load_config() {
>     if [[ ! -f "${CONFIG_FILE}" ]]; then
>         echo "ERROR: Configuration file ${CONFIG_FILE} not found!"
>         exit 1
>     fi
>
>     # Source the configuration file
>     source "${CONFIG_FILE}"
>
>     echo "Loaded configuration:"
>     echo "  REGION_CODE: ${REGION_CODE}"
>     echo "  RETENTION_POLICY: ${RETENTION_POLICY}"
> }
>
> # Check if file has UTF-8 BOM
> has_bom() {
>     local file="$1"
>     # Check first 3 bytes for UTF-8 BOM (EF BB BF)
>     if [[ -f "$file" ]]; then
>         local bom_bytes=$(od -An -tx1 -j0 -N3 "$file" | tr -d ' ')
>         if [[ "$bom_bytes" == "efbbbf" ]]; then
>             return 0  # Has BOM
>         fi
>     fi
>     return 1  # No BOM
> }
>
> # Convert CSV to TSV
> convert_csv_to_tsv() {
>     local csv_file="$1"
>     local tsv_file="$2"
>
>     # Use awk to replace commas with tabs, handling quoted fields
>     awk -F, '{
>         # Remove surrounding quotes from each field
>         for(i=1; i<=NF; i++) {
>             gsub(/^"|"$/, "", $i);
>         }
>         # Print fields separated by tabs
>         print $0
>     }' "${csv_file}" > "${tsv_file}"
> }
>
> # --- Main Processing Functions ---
>
> # Process incoming files
> process_incoming_files() {
>     echo "Processing files in ${INCOMING_DIR}..."
>
>     local total_records=0
>
>     # Temporary arrays to store file information for manifest
>     declare -a manifest_files
>     declare -a manifest_hashes
>     declare -a manifest_row_counts
>
>     # Process each CSV file in incoming directory
>     for csv_file in "${INCOMING_DIR}"/*.csv; do
>         [[ -f "${csv_file}" ]] || continue  # Skip if no files found
>
>         echo "Processing file: $(basename "${csv_file}")"
>
>         # Check for BOM
>         if has_bom "${csv_file}"; then
>             echo "  ERROR: File has UTF-8 BOM - moving to quarantine"
>             mv "${csv_file}" "${QUARANTINE_DIR}/"
>             continue
>         fi
>
>         # Calculate row count (excluding header)
>         local row_count=$(grep -cv '^$' "${csv_file}" | awk 'END{print $1-1}')
>
>         # Generate MD5 hash
>         local file_hash=$(md5sum "${csv_file}" | awk '{print $1}')
>
>         # Store information for manifest
>         manifest_files+=("$(basename "${csv_file}" | sed 's/\.csv$//')")
>         manifest_hashes+=("${file_hash}")
>         manifest_row_counts+=("${row_count}")
>
>         # Convert to TSV
>         local tsv_file="${csv_file%.csv}.tsv"
>         convert_csv_to_tsv "${csv_file}" "${tsv_file}"
>
>         # Move original CSV to raw backup
>         mv "${csv_file}" "${RAW_BACKUP_DIR}/"
>
>         # Keep track of total records
>         total_records=$((total_records + row_count))
>
>         echo "  Processed successfully (${row_count} records)"
>     done
>
>     echo "Total valid records processed: ${total_records}"
>
>     # Create manifest file
>     create_manifest "${manifest_files[@]}" "${manifest_hashes[@]}" "${manifest_row_counts[@]}" "${total_records}"
>
>     # Create archive
>     create_archive "${total_records}"
>
>     # Extract to staging
>     extract_to_staging
>
>     # Sort orders file
>     sort_orders_file
> }
>
> # Create manifest file
> create_manifest() {
>     local -n files=$1
>     local -n hashes=$2
>     local -n row_counts=$3
>     local total_records=$4
>
>     echo "Creating manifest file: ${MANIFEST_FILE}"
>
>     # Create ISO-8859-1 encoded manifest file
>     # Use iconv to convert to Latin-1 encoding
>     {
>         echo "Legacy ETL Manifest © 2023"
>
>         # Combine arrays into lines
>         for i in "${!files[@]}"; do
>             # Skip if any element is missing
>             if [[ -n "${files[i]}" && -n "${hashes[i]}" && -n "${row_counts[i]}" ]]; then
>                 echo "${files[i]}.csv|${hashes[i]}|${row_counts[i]}"
>             fi
>         done
>     } | iconv -t ISO-8859-1 > "${MANIFEST_FILE}"
>
>     echo "Manifest created with ${#files[@]} entries"
> }
>
> # Create archive file
> create_archive() {
>     local total_records=$1
>     local timestamp=$(date +'%Y%m%d')
>     local archive_name="data_${REGION_CODE}_${timestamp}_${total_records}.tar.gz"
>     local archive_path="${ARCHIVE_DIR}/${archive_name}"
>
>     echo "Creating archive: ${archive_path}"
>
>     # Create temporary directory for archive contents
>     local temp_dir="$(mktemp -d)"
>
>     # Copy TSV files to temporary directory
>     for csv_file in "${RAW_BACKUP_DIR}"/*.csv; do
>         local tsv_file="${csv_file%.csv}.tsv"
>         if [[ -f "${tsv_file}" ]]; then
>             cp "${tsv_file}" "${temp_dir}/"
>         fi
>     done
>
>     # Create tarball
>     tar -czf "${archive_path}" -C "${temp_dir}" .
>
>     # Clean up temporary directory
>     rm -rf "${temp_dir}"
>
>     echo "Archive created: ${archive_name} (${total_records} total records)"
> }
>
> # Extract files to staging directory
> extract_to_staging() {
>     echo "Extracting files to staging directory: ${STAGING_DIR}"
>
>     # Find the latest archive file
>     local archive_file=$(ls -t "${ARCHIVE_DIR}"/*.tar.gz | head -1)
>
>     if [[ -z "${archive_file}" ]]; then
>         echo "ERROR: No archive files found!"
>         return 1
>     fi
>
>     # Extract archive to staging directory
>     tar -xzf "${archive_file}" -C "${STAGING_DIR}"
>
>     echo "Extracted $(ls -1 "${STAGING_DIR}" | wc -l) files to staging"
> }
>
> # Sort orders file by total_amount (3rd column) descending
> sort_orders_file() {
>     local orders_file="${STAGING_DIR}/orders.tsv"
>
>     if [[ -f "${orders_file}" ]]; then
>         echo "Sorting orders file by total_amount..."
>
>         # Sort numerically by 3rd column in descending order
>         sort -t$'\t' -k3,3nr "${orders_file}" -o "${orders_file}"
>
>         echo "orders.tsv sorted successfully"
>     else
>         echo "WARNING: orders.tsv not found in staging directory"
>     fi
> }
>
> # --- Main Execution ---
>
> load_config
>
> # Clear previous staging files
> rm -f "${STAGING_DIR}"/*.tsv
>
> # Process the incoming files
> process_incoming_files
>
> echo "Legacy ETL Process Completed at $(date)"
> EOF
root@6fc9b5d9-ea74-43ac-8d2d-c85d12cffe93:~# chmod +x solve.sh
root@6fc9b5d9-ea74-43ac-8d2d-c85d12cffe93:~# ls -la solve.sh
-rwxr-xr-x 1 root root 6546 Feb 13 19:12 solve.sh
root@6fc9b5d9-ea74-43ac-8d2d-c85d12cffe93:~#
