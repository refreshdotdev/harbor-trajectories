You are an AI assistant tasked with solving command-line tasks in a Linux environment. You will be given a task description and the output from previously executed commands. Your goal is to solve the task by providing batches of shell commands.

Format your response as JSON with the following structure:

{
  "analysis": "Analyze the current state based on the terminal output provided. What do you see? What has been accomplished? What still needs to be done?",
  "plan": "Describe your plan for the next steps. What commands will you run and why? Be specific about what you expect each command to accomplish.",
  "commands": [
    {
      "keystrokes": "ls -la\n",
      "duration": 0.1
    },
    {
      "keystrokes": "cd project\n",
      "duration": 0.1
    }
  ],
  "task_complete": true
}

Required fields:
- "analysis": Your analysis of the current situation
- "plan": Your plan for the next steps
- "commands": Array of command objects to execute

Optional fields:
- "task_complete": Boolean indicating if the task is complete (defaults to false if not present)

Command object structure:
- "keystrokes": String containing the exact keystrokes to send to the terminal (required)
- "duration": Number of seconds to wait for the command to complete before the next command will be executed (defaults to 1.0 if not present)

IMPORTANT: The text inside "keystrokes" will be used completely verbatim as keystrokes. Write commands exactly as you want them sent to the terminal:
- You must end every command with a newline (\n) or it will not execute.
- For special key sequences, use tmux-style escape sequences:
  - C-c for Ctrl+C
  - C-d for Ctrl+D

The "duration" attribute specifies the number of seconds to wait for the command to complete (default: 1.0) before the next command will be executed. On immediate tasks (e.g., cd, ls, echo, cat) set a duration of 0.1 seconds. On commands (e.g., gcc, find, rustc) set a duration of 1.0 seconds. On slow commands (e.g., make, python3 [long running script], wget [file]) set an appropriate duration as you determine necessary.

It is better to set a smaller duration than a longer duration. It is always possible to wait again if the prior output has not finished, by running {"keystrokes": "", "duration": 10.0} on subsequent requests to wait longer. Never wait longer than 60 seconds; prefer to poll to see intermediate result status.

Important notes:
- Each command's keystrokes are sent exactly as written to the terminal
- Do not include extra whitespace before or after the keystrokes unless it's part of the intended command
- Extra text before or after the JSON will generate warnings but be tolerated
- The JSON must be valid - use proper escaping for quotes and special characters within strings
- Commands array can be empty if you want to wait without taking action

Task Description:
# Project: Legacy Configuration Audit & Tracker

**TO:** Engineering Team
**FROM:** SysAdmin Lead
**SUBJECT:** Urgent cleanup and tracking of legacy configs

We have inherited a messy directory of configuration files from the previous team. Your task is to write a robust automation script (Bash/Python) to sanitize these files, initialize a SQLite tracking database, perform a simulated maintenance task, and generate a signed audit report.

## 1. Workspace & Pre-requisites

Working directory: `/home/user/cmtracker`

We have dumped the raw configuration files into `/home/user/cmtracker/configs`.
**WARNING:** These files are dirty. They come from different systems (Windows, Legacy Unix) and have encoding/formatting issues.

You will also find a file at `/home/user/version.txt` which contains the current audit version string (e.g., `v2.0-RC1`). You will need this for the report header.

## 2. Phase 1: Sanitization (Critical)

Before tracking anything, you must modify the files in `/home/user/cmtracker/configs` **in-place** to meet our strict standards.

*   **`ssh.cfg`**: This file came from a Windows box. It has CRLF line endings. Convert it to standard Linux LF line endings.
*   **`nginx.conf`**: This file is encoded in **ISO-8859-1** (Latin-1) and contains a copyright symbol. Convert it to **UTF-8** while preserving the special character.
*   **`app.ini`**: This file has sloppy trailing whitespace. Remove all trailing whitespace characters from every line.
*   **Exclusions**: Delete any file ending in `.bak` or starting with a dot (`.`). Do not track them.

*Note: All subsequent steps must operate on these sanitized versions.*

## 3. Phase 2: Database Initialization

Create a SQLite database at `/home/user/cmtracker/db/audit.db`.

We need two tables. Please infer the column types appropriate for the data described.

**Table: `tracked_files`**
*   `id`: Auto-incrementing primary key.
*   `rel_path`: Relative path from the configs directory (e.g., `ssh.cfg`, not the full path).
*   `file_hash`: **SHA-256** hash of the sanitized file content.
*   `magic_hex`: The first 4 bytes of the file, represented as a lowercase hex string (e.g., `504b0304`).
*   `size_bytes`: File size in bytes.

**Table: `audit_events`**
*   `event_id`: Auto-incrementing primary key.
*   `file_id`: Foreign key to `tracked_files`.
*   `event_type`: Text (must be 'INIT', 'MODIFY', or 'PERM').
*   `event_ts`: ISO-8601 Timestamp (UTC).

**Initial Load:**
Populate the database with the current state of all sanitized files in `configs`. Create a corresponding 'INIT' event for each file using the file's current modification timestamp.

## 4. Phase 3: Simulation

Perform exactly these steps in order:

1.  **Prepend** the line `# URGENT SECURITY PATCH` to the very **top** of `ssh.cfg`. (Do not append it to the end!).
    *   Update the `tracked_files` record (hash, magic_hex, size).
    *   Log a 'MODIFY' event in `audit_events` using the new mtime.

2.  Wait 1 second.

3.  **Change permissions** of `nginx.conf` to `400` (read-only, user only).
    *   Log a 'PERM' event in `audit_events`. Use the current UTC time for this event.
    *   *Note: The `tracked_files` table does not track permissions, so no update is needed there.*

## 5. Phase 4: Reporting & Logging

**The Report**
Generate a summary report at `/home/user/cmtracker/reports/audit_summary.csv`.

*   **Format:** Semicolon-delimited (`;`).
*   **Header:** Must be exactly: `PATH;EVENT;HASH;VERSION=<content of version.txt>`
*   **Sorting:** Sort primarily by `event_type` (Alphabetical), and secondarily by `rel_path` (Alphabetical).
*   **Content:** Rows should contain the relative path, event type, and the file hash associated with that file record.

**The SQL Log**
Log all SQL commands to `/home/user/cmtracker/logs/sql_history.log`.

**Integrity Check (The Trap):**
To prevent tampering, the **very last line** of your `sql_history.log` must be a comment containing the SHA-256 checksum of the final `audit.db` file.

Format:
`-- DB_CHECKSUM: <sha256_hex_of_db_file>`

(You must calculate this checksum *after* all DB operations are complete and the connection is closed, then append it to the log.)

Current terminal state:
Current Terminal Screen:
root@e535d4ff-2e66-427a-ade1-d8e01430a6f3:/home/user/cmtracker#








































