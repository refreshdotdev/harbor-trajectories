Current terminal state:
New Terminal Output:

root@a6c8e3be-6726-4ee5-9f78-2c5dba1b4482:/home/user# mkdir -p /home/user/scripts
root@a6c8e3be-6726-4ee5-9f78-2c5dba1b4482:/home/user# cd /home/user/scripts
root@a6c8e3be-6726-4ee5-9f78-2c5dba1b4482:/home/user/scripts# cat > filter_errors.sh << 'EOF'
> #!/bin/bash
>
> # Validate arguments
> if [ "$#" -ne 2 ]; then
>     echo "Usage: $0 <input_log> <output_dir>" >&2
>     exit 1
> fi
>
> input_log="$1"
> output_dir="$2"
>
> # Create output directory
> mkdir -p "$output_dir"
>
> # Get absolute paths
> target_log=$(realpath "$input_log")
> target_dir=$(realpath "$output_dir")
>
> # Initialize variables
> categories=()
> entries=()
>
> # Process log file
> awk -v target_log="$target_log" -v output_dir="$output_dir" '
> BEGIN {
>     in_entry=0
>     current_entry=""
>     current_category=""
>     category_found=0
>     email_regex="[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"
> }
> /^[0-9]{4}-[0-9]{2}-[0-9]{2}/ {
>     if (in_entry == 1) {
>         if (category_found == 1) {
>             entries[length(entries)+1] = current_entry
>             categories[length(categories)+1] = current_category
>         }
>         current_entry = $0
>         in_entry = 1
>         category_found = 0
>         current_category = ""
>     } else {
>         current_entry = $0
>         in_entry = 1
>         category_found = 0
>         current_category = ""
>     }
>
>     # Check for matching patterns
>     if ($0 ~ /^ERROR/) {
>         current_category = "FATAL"
>         category_found = 1
>     }
>     if ($0 ~ /Payment failed/ && current_category == "") {
>         current_category = "PAYMENT_FAILURE"
>         category_found = 1
>     }
>     if ($0 ~ /^HTTP\/1\.1 5[0-9]{2}/ && current_category == "") {
>         current_category = "HTTP_5XX"
>         category_found = 1
>     }
>     if ($0 ~ /^FATAL/ && current_category == "") {
>         current_category = "FATAL"
>         category_found = 1
>     }
> }
> !/^([0-9]{4}-[0-9]{2}-[0-9]{2})/ && in_entry == 1 {
>     current_entry = current_entry "\n" $0
> }
> END {
>     if (in_entry == 1 && category_found == 1) {
>         entries[length(entries)+1] = current_entry
>         categories[length(categories)+1] = current_category
>     }
>
>     # Write redacted content to file
>     printf "# Source: %s\n", target_log > "output_dir/critical_errors.log"
>     for (i=1; i<=length(entries); i++) {
>         # Redact emails
>         gsub(email_regex, "<REDACTED>", entries[i])
>         print entries[i] >> "output_dir/critical_errors.log"
>     }
>
>     # Count categories
>     counts["PAYMENT_FAILURE"] = 0
>     counts["HTTP_5XX"] = 0
>     counts["FATAL"] = 0
>     for (i=1; i<=length(categories); i++) {
>         counts[categories[i]]++
>     }
>
>     # Write CSV
>     printf "error_category,count\n" > "output_dir/error_summary.csv"
>     for (cat in counts) {
>         if (counts[cat] > 0) {
>             print cat "," counts[cat] >> "output_dir/error_summary.csv"
>         }
>     }
>
>     # Sort CSV
>     system("sort -t, -k2,2nr -k1,1 output_dir/error_summary.csv -o output_dir/error_summary.csv")
> }' "${target_log}"
>
> # Log execution
> date +"%Y-%m-%d|%H:%M:%S" | awk -v input="${target_log}" -v output="${target_dir}" '{print $0 "|input=" input "|output_dir=" output "|status=OK"}' >> /home/us
er/filter_run.log
> EOFchmod +x filter_errors.sh
> ls -la filter_errors.sh
>


Are you sure you want to mark the task as complete? This will trigger your solution to be graded and you won't be able to make any further corrections. If so, include "task_complete": true in your JSON response again.