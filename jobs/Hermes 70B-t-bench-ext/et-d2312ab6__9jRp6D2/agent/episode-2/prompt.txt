New Terminal Output:

root@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# python3 -c "
   version_utf8 = root_utf8.find('version').text
        print(f'Version extracted (UTF-8): {version_utf8}')
        if version_utf8 and version_utf8.startswith('v'):
            print(f'Clean version (UTF-8): {version_utf8}')
        else:
            print('Version did not start with v, or was not found with UTF-8.')
    except Exception as e_utf8:
        print(f'Error with UTF-8 decoding or XML parsing: {e_utf8}')
        print('Final fallback: attempting to read as raw bytes and find version string.')
        with open('incoming/build_meta.xml', 'rb') as f:
            content_bytes = f.read()
        print('Raw bytes (first 80 bytes):', content_bytes[:80])
        print('Attempting to find version tag in raw bytes...')
        if b'<version>' in content_bytes and b'</version>' in content_bytes:
            # A simple extraction assuming <version>VALUE</version>
            start_idx = content_bytes.find(b'<version>') + 10
            end_idx = content_bytes.find(b'</version>', start_idx)
            if > import xml.etree.ElementTree as ET
> import codecs
> try:
>     with open('incoming/build_meta.xml', 'rb') as f:
>         content = f.read()
>     # Try UTF-16LE decoding
>     decoded_content = content.decode('utf-16-le').strip()
>     print('Decoded content (UTF-16LE):')
>     print(decoded_content)
>     root = ET.fromstring(decoded_content)
>     version = root.find('version').text
>     print(f'Version extracted: {version}')
>     if version and version.startswith('v'):
>         print(f'Clean version: {version}')
>     else:
>         print('Version did not start with v, or was not found.')
> except Exception as e:
>     print(f'Error with UTF-16LE decoding or XML parsing: {e}')
>
>     # Fallback attempt: Try UTF-8
>     try:
>         with open('incoming/build_meta.xml', 'rb') as f:
>             content_utf8 = f.read()
>         decoded_content_utf8 = content_utf8.decode('utf-8').strip()
>         print('Attempting UTF-8 decoding:')
>         print(decoded_content_utf8)
>         root_utf8 = ET.fromstring(decoded_content_utf8)
>         version_utf8 = root_utf8.find('version').text
>         print(f'Version extracted (UTF-8): {version_utf8}')
>         if version_utf8 and version_utf8.startswith('v'):
>             print(f'Clean version (UTF-8): {version_utf8}')
>         else:
>             print('Version did not start with v, or was not found with UTF-8.')
>     except Exception as e_utf8:
>         print(f'Error with UTF-8 decoding or XML parsing: {e_utf8}')
>         print('Final fallback: attempting to read as raw bytes and find version string.')
>         with open('incoming/build_meta.xml', 'rb') as f:
>             content_bytes = f.read()
>         print('Raw bytes (first 80 bytes):', content_bytes[:80])
>         print('Attempting to find version tag in raw bytes...')
>         if b'<version>' in content_bytes and b'</version>' in content_bytes:
>             # A simple extraction assuming <version>VALUE</version>
>             start_idx = content_bytes.find(b'<version>') + 10
>             end_idx = content_bytes.find(b'</version>', start_idx)
>             if start_idx < end_idx:
>                 potential_version_bytes = content_bytes[start_idx:end_idx]
>                 # Try to decode potential_version_bytes as utf-16le or utf-8
>                 try:
>                     potential_version_str = potential_version_bytes.decode('utf-16-le').strip()
>                     if potential_version_str.startswith('v'):
>                         print(f'Potential version from raw bytes (UTF-16LE): {potential_version_str}')
>                     else:
>                         print(f'Potential version from raw bytes (UTF-16LE, no leading v): {potential_version_str}')
>                 except UnicodeDecodeError:
>                     try:
>                         potential_version_str = potential_version_bytes.decode('utf-8').strip()
>                         if potential_version_str.startswith('v'):
>                             print(f'Potential version from raw bytes (UTF-8): {potential_version_str}')
>                         else:
>                             print(f'Potential version from raw bytes (UTF-8, no leading v): {potential_version_str}')
>                     except UnicodeDecodeError:
>                         print(f'Potential version from raw bytes could not be decoded: {potential_version_bytes}')
>             else:
>                 print('Could not isolate version content from raw bytes.')
>         else:
>             print('<version> tag not found in raw bytes.')
>
> print('Python XML parsing script finished.')
> "
Decoded content (UTF-16LE):
<Build><Meta><Version>v2.4.1-beta</Version></Meta></Build>
Error with UTF-16LE decoding or XML parsing: 'NoneType' object has no attribute 'text'
Error with UTF-8 decoding or XML parsing: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
Final fallback: attempting to read as raw bytes and find version string.
Raw bytes (first 80 bytes): b'\xff\xfe<\x00B\x00u\x00i\x00l\x00d\x00>\x00<\x00M\x00e\x00t\x00a\x00>\x00<\x00V\x00e\x00r\x00s\x00i\x00o\x00n\x00>\x00v\x002\x00.\
x004\x00.\x001\x00-\x00b\x00e\x00t\x00a\x00<\x00/\x00V\x00e\x00r\x00s\x00'
Attempting to find version tag in raw bytes...
<version> tag not found in raw bytes.
Python XML parsing script finished.
root@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace#
