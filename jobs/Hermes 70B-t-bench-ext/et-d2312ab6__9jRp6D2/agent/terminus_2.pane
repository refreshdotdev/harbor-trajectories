[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# asciinema rec --stdin /logs/agent/recording.cast
[?2004l[0;32masciinema: recording asciicast to /logs/agent/recording.cast[0m
[0;32masciinema: press <ctrl-d> or type "exit" when you're done[0m
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# clear
[?2004l[H[J[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# ls -la
[?2004ltotal 0
drwxrwxrwx 1 root root 50 Feb 13 18:50 [0m[34;42m.[0m
drwxr-xr-x 1 root root 31 Feb 13 18:50 [01;34m..[0m
drwxrwxrwx 1 root root 36 Feb 13 18:50 [34;42mincoming[0m
drwxrwxrwx 1 root root 10 Feb 13 18:50 [34;42moutgoing[0m
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# ls -la incoming/
[?2004ltotal 4
drwxrwxrwx 1 root root  36 Feb 13 18:50 [0m[34;42m.[0m
drwxrwxrwx 1 root root  50 Feb 13 18:50 [34;42m..[0m
-rwxrwxrwx 1 root root 118 Oct 27  2023 [01;32mbuild_meta.xml[0m
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# file incoming/build_meta.xml
[?2004lbash: file: command not found
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# stat --format '%Y' incoming/build_meta.xml
[?2004l1698400800
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# python3 -c "
[?2004l   version_utf8 = root_utf8.find('version').text
        print(f'Version extracted (UTF-8): {version_utf8}')
        if version_utf8 and version_utf8.startswith('v'):
            print(f'Clean version (UTF-8): {version_utf8}')
        else:
            print('Version did not start with v, or was not found with UTF-8.')
    except Exception as e_utf8:
        print(f'Error with UTF-8 decoding or XML parsing: {e_utf8}')
        print('Final fallback: attempting to read as raw bytes and find version string.')
        with open('incoming/build_meta.xml', 'rb') as f:
            content_bytes = f.read()
        print('Raw bytes (first 80 bytes):', content_bytes[:80])
        print('Attempting to find version tag in raw bytes...')
        if b'<version>' in content_bytes and b'</version>' in content_bytes:
            # A simple extraction assuming <version>VALUE</version>
            start_idx = content_bytes.find(b'<version>') + 10
            end_idx = content_bytes.find(b'</version>', start_idx)
            if [?2004h> import xml.etree.ElementTree as ET
[?2004l[?2004h> import codecs
[?2004l[?2004h> try:
[?2004l[?2004h>     with open('incoming/build_meta.xml', 'rb') as f:
[?2004l[?2004h>         content = f.read()
[?2004l[?2004h>     # Try UTF-16LE decoding
[?2004l[?2004h>     decoded_content = content.decode('utf-16-le').strip()
[?2004l[?2004h>     print('Decoded content (UTF-16LE):')
[?2004l[?2004h>     print(decoded_content)
[?2004l[?2004h>     root = ET.fromstring(decoded_content)
[?2004l[?2004h>     version = root.find('version').text
[?2004l[?2004h>     print(f'Version extracted: {version}')
[?2004l[?2004h>     if version and version.startswith('v'):
[?2004l[?2004h>         print(f'Clean version: {version}')
[?2004l[?2004h>     else:
[?2004l[?2004h>         print('Version did not start with v, or was not found.')
[?2004l[?2004h> except Exception as e:
[?2004l[?2004h>     print(f'Error with UTF-16LE decoding or XML parsing: {e}')
[?2004l[?2004h>     
[?2004l[?2004h>     # Fallback attempt: Try UTF-8
[?2004l[?2004h>     try:
[?2004l[?2004h>         with open('incoming/build_meta.xml', 'rb') as f:
[?2004l[?2004h>             content_utf8 = f.read()
[?2004l[?2004h>         decoded_content_utf8 = content_utf8.decode('utf-8').strip()
[?2004l[?2004h>         print('Attempting UTF-8 decoding:')
[?2004l[?2004h>         print(decoded_content_utf8)
[?2004l[?2004h>         root_utf8 = ET.fromstring(decoded_content_utf8)
[?2004l[?2004h>         version_utf8 = root_utf8.find('version').text
[?2004l[?2004h>         print(f'Version extracted (UTF-8): {version_utf8}')
[?2004l[?2004h>         if version_utf8 and version_utf8.startswith('v'):
[?2004l[?2004h>             print(f'Clean version (UTF-8): {version_utf8}')
[?2004l[?2004h>         else:
[?2004l[?2004h>             print('Version did not start with v, or was not found with UTF-8.')
[?2004l[?2004h>     except Exception as e_utf8:
[?2004l[?2004h>         print(f'Error with UTF-8 decoding or XML parsing: {e_utf8}')
[?2004l[?2004h>         print('Final fallback: attempting to read as raw bytes and find version string.')
[?2004l[?2004h>         with open('incoming/build_meta.xml', 'rb') as f:
[?2004l[?2004h>             content_bytes = f.read()
[?2004l[?2004h>         print('Raw bytes (first 80 bytes):', content_bytes[:80])
[?2004l[?2004h>         print('Attempting to find version tag in raw bytes...')
[?2004l[?2004h>         if b'<version>' in content_bytes and b'</version>' in content_bytes:
[?2004l[?2004h>             # A simple extraction assuming <version>VALUE</version>
[?2004l[?2004h>             start_idx = content_bytes.find(b'<version>') + 10
[?2004l[?2004h>             end_idx = content_bytes.find(b'</version>', start_idx)
[?2004l[?2004h>             if start_idx < end_idx:
[?2004l[?2004h>                 potential_version_bytes = content_bytes[start_idx:end_idx]
[?2004l[?2004h>                 # Try to decode potential_version_bytes as utf-16le or utf-8
[?2004l[?2004h>                 try:
[?2004l[?2004h>                     potential_version_str = potential_version_bytes.decode('utf-16-le').strip()
[?2004l[?2004h>                     if potential_version_str.startswith('v'):
[?2004l[?2004h>                         print(f'Potential version from raw bytes (UTF-16LE): {potential_version_str}')
[?2004l[?2004h>                     else:
[?2004l[?2004h>                         print(f'Potential version from raw bytes (UTF-16LE, no leading v): {potential_version_str}')
[?2004l[?2004h>                 except UnicodeDecodeError:
[?2004l[?2004h>                     try:
[?2004l[?2004h>                         potential_version_str = potential_version_bytes.decode('utf-8').strip()
[?2004l[?2004h>                         if potential_version_str.startswith('v'):
[?2004l[?2004h>                             print(f'Potential version from raw bytes (UTF-8): {potential_version_str}')
[?2004l[?2004h>                         else:
[?2004l[?2004h>                             print(f'Potential version from raw bytes (UTF-8, no leading v): {potential_version_str}')
[?2004l[?2004h>                     except UnicodeDecodeError:
[?2004l[?2004h>                         print(f'Potential version from raw bytes could not be decoded: {potential_version_bytes}')
[?2004l[?2004h>             else:
[?2004l[?2004h>                 print('Could not isolate version content from raw bytes.')
[?2004l[?2004h>         else:
[?2004l[?2004h>             print('<version> tag not found in raw bytes.')
[?2004l[?2004h>     
[?2004l[?2004h> print('Python XML parsing script finished.')
[?2004l[?2004h> "
[?2004lDecoded content (UTF-16LE):
ï»¿<Build><Meta><Version>v2.4.1-beta</Version></Meta></Build>
Error with UTF-16LE decoding or XML parsing: 'NoneType' object has no attribute 'text'
Error with UTF-8 decoding or XML parsing: 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
Final fallback: attempting to read as raw bytes and find version string.
Raw bytes (first 80 bytes): b'\xff\xfe<\x00B\x00u\x00i\x00l\x00d\x00>\x00<\x00M\x00e\x00t\x00a\x00>\x00<\x00V\x00e\x00r\x00s\x00i\x00o\x00n\x00>\x00v\x002\x00.\x004\x00.\x001\x00-\x00b\x00e\x00t\x00a\x00<\x00/\x00V\x00e\x00r\x00s\x00'
Attempting to find version tag in raw bytes...
<version> tag not found in raw bytes.
Python XML parsing script finished.
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# python3 -c "
[?2004l[?2004h> import xml.etree.ElementTree as ET
[?2004l[?2004h> import codecs
[?2004l[?2004h> 
[?2004l[?2004h> try:
[?2004l[?2004h>     with open('incoming/build_meta.xml', 'rb') as f:
[?2004l[?2004h>         content_bytes = f.read()
[?2004l[?2004h>     
[?2004l[?2004h>     # Decode using UTF-16LE as identified
[?2004l[?2004h>     decoded_content = content_bytes.decode('utf-16-le').strip()
[?2004l[?2004h>     print('Decoded content:')
[?2004l[?2004h>     print(decoded_content)
[?2004l[?2004h>     
[?2004l[?2004h>     # Parse with ElementTree
[?2004l[?2004h>     root = ET.fromstring(decoded_content)
[?2004l[?2004h>     
[?2004l[?2004h>     # Find the Version tag (case-sensitive based on observed structure)
[?2004l[?2004h>     version_element = root.find('.//Version') # Searches recursively for Version tag
[?2004l[?2004h>     if version_element is not None and version_element.text:
[?2004l[?2004h>         version = version_element.text.strip()
[?2004l[?2004h>         print(f'Extracted version: {version}')
[?2004l[?2004h>         if version.startswith('v'):
[?2004l[?2004h>             print(f'Clean version: {version}')
[?2004l[?2004h>             exit_code = 0
[?2004l[?2004h>         else:
[?2004l[?2004h>             print(f'Warning: Version does not start with v: {version}')
[?2004l[?2004h>             exit_code = 1
[?2004l[?2004h>     else:
[?2004l[?2004h>         print('Error: Version element not found or has no text.')
[?2004l[?2004h>         exit_code = 1
[?2004l[?2004h>         version = '' # Default if not found
[?2004l[?2004h> 
[?2004l[?2004h> except Exception as e:
[?2004l[?2004h>     print(f'Error: {e}')
[?2004l[?2004h>     exit_code = 2
[?2004l[?2004h>     version = ''
[?2004l[?2004h> 
[?2004l[?2004h> # For debugging, print the extracted version to stdout
[?2004l[?2004h> print(f'FINAL_VERSION_EXTRACTED:{version}')
[?2004l[?2004h> " 2>&1
[?2004lDecoded content:
ï»¿<Build><Meta><Version>v2.4.1-beta</Version></Meta></Build>
Extracted version: v2.4.1-beta
Clean version: v2.4.1-beta
FINAL_VERSION_EXTRACTED:v2.4.1-beta
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# ls -la /etc/opt/keys/
[?2004ltotal 12
drw-r--r-- 1 root root 103 Feb 13 18:51 [0m[01;34m.[0m
drwxr-xr-x 1 root root  26 Feb 13 18:50 [01;34m..[0m
-rw-r--r-- 1 root root  21 Feb 13 18:51 old_key.bak
-rw-r--r-- 1 root root  27 Feb 13 18:51 release_signing.key
-rw-r--r-- 1 root root  24 Feb 13 18:51 release_signing.key.example
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# cd /etc/opt/keys
[?2004l[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/etc/opt/keys# pwd
[?2004l/etc/opt/keys
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/etc/opt/keys# cat release_signing.key
[?2004l  super-secret-key-value  
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/etc/opt/keys# cd /home/user/workspace
[?2004l[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# pwd
[?2004l/home/user/workspace
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# python3 -c "
[?2004l it directly.
# For this exercise, let's assume the key is 'MySecureKeyForRelease' (this is a placeholder as actual key is unknown)
# Let's make a more generic assumption: the key is some string.
# We MUST get the actual key. The previous command output was truncated.
# I will re-run the cat command.
# For now, I'll proceed with a placeholder key for the logic demonstration.
# This is a critical point - the key is essential.
# Let's assume the key is 'MySecureKeyForRelease' for demonstration.
key = 'MySecureKeyForRelease' # This should be read from the file

# Clean the key (remove surrounding whitespace)
cleaned_key = key.strip()
print(f'Using signing key: {cleaned_key}')

# Compute HMAC-SHA256
digest = hmac.new(cleaned_key.encode('utf-8'), payload.encode('utf-8'), hashlib.sha256)
signature_hex = digest.hexdigest().lower()
print(f'Computed HMAC-SHA256 signature (hex, lowercase): {signature_hex}')
" 2>&1
[?2004h> import hmac
[?2004l[?2004h> import hashlib
[?2004l[?2004h> import os
[?2004l[?2004h> 
[?2004l[?2004h> # Extracted values
[?2004l[?2004h> version = 'v2.4.1-beta'
[?2004l[?2004h> build_timestamp = '1698400800'
[?2004l[?2004h> 
[?2004l[?2004h> # Construct signature payload
[?2004l[?2004h> payload = version + build_timestamp
[?2004l[?2004h> print(f'Payload for signature: {payload}')
[?2004l[?2004h> 
[?2004l[?2004h> # Get signing key
[?2004l[?2004h> # In a real script, this would be: with open('/etc/opt/keys/release_signing.key', 'r') as f: key_content = f.read().strip()
[?2004l[?2004h> # For this interactive session, we'll simulate reading the key 'MySecureKeyForRelease\n' (example from cat output)
[?2004l[?2004h> # Let's assume the key content is 'MySecureKeyForRelease' after stripping.
[?2004l[?2004h> # The actual key content from 'cat release_signing.key' was not shown in the output, so I need to get it.
[?2004l[?2004h> # Let's re-run the cat command in this context to ensure we have the key.
[?2004l[?2004h> # Actually, the previous 'cat release_signing.key' output is missing. Let's execute it again.
[?2004l[?2004h> # This is a flaw in the current state, I need the key.
[?2004l[?2004h> # I'll assume for now the key is 'MySecureKeyForRelease' as an example, but this is a placeholder.
[?2004l[?2004h> # A robust script would read it directly.
[?2004l[?2004h> # For this exercise, let's assume the key is 'MySecureKeyForRelease' (this is a placeholder as actual key is unknown)
[?2004l[?2004h> # Let's make a more generic assumption: the key is some string.
[?2004l[?2004h> # We MUST get the actual key. The previous command output was truncated.
[?2004l[?2004h> # I will re-run the cat command.
[?2004l[?2004h> # For now, I'll proceed with a placeholder key for the logic demonstration.
[?2004l[?2004h> # This is a critical point - the key is essential.
[?2004l[?2004h> # Let's assume the key is 'MySecureKeyForRelease' for demonstration.
[?2004l[?2004h> key = 'MySecureKeyForRelease' # This should be read from the file
[?2004l[?2004h> 
[?2004l[?2004h> # Clean the key (remove surrounding whitespace)
[?2004l[?2004h> cleaned_key = key.strip()
[?2004l[?2004h> print(f'Using signing key: {cleaned_key}')
[?2004l[?2004h> 
[?2004l[?2004h> # Compute HMAC-SHA256
[?2004l[?2004h> digest = hmac.new(cleaned_key.encode('utf-8'), payload.encode('utf-8'), hashlib.sha256)
[?2004l[?2004h> signature_hex = digest.hexdigest().lower()
[?2004l[?2004h> print(f'Computed HMAC-SHA256 signature (hex, lowercase): {signature_hex}')
[?2004l[?2004h> " 2>&1
[?2004lPayload for signature: v2.4.1-beta1698400800
Using signing key: MySecureKeyForRelease
Computed HMAC-SHA256 signature (hex, lowercase): dad0962b0a38812479b87fcd5060ad253097c3307f80465ace927f8cd5ec6009
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# python3 -c "
[?2004l[?2004h> import hmac
[?2004l[?2004h> import hashlib
[?2004l[?2004h> 
[?2004l[?2004h> # Extracted values
[?2004l[?2004h> version = 'v2.4.1-beta'
[?2004l[?2004h> build_timestamp = '1698400800'
[?2004l[?2004h> 
[?2004l[?2004h> # Construct signature payload
[?2004l[?2004h> payload = version + build_timestamp
[?2004l[?2004h> print(f'Payload for signature: {payload}')
[?2004l[?2004h> 
[?2004l[?2004h> # Read signing key
[?2004l[?2004h> with open('/etc/opt/keys/release_signing.key', 'r') as f:
[?2004l[?2004h>     key_content = f.read()
[?2004l[?2004h> 
[?2004l[?2004h> cleaned_key = key_content.strip()
[?2004l[?2004h> print(f'Cleaned signing key (first 10 chars): {cleaned_key[:10]}...') # Avoid printing full key if it's sensitive
[?2004l[?2004h> print(f'Cleaned signing key length: {len(cleaned_key)}')
[?2004l[?2004h> 
[?2004l[?2004h> # Compute HMAC-SHA256
[?2004l[?2004h> digest = hmac.new(cleaned_key.encode('utf-8'), payload.encode('utf-8'), hashlib.sha256)
[?2004l[?2004h> signature_hex = digest.hexdigest().lower()
[?2004l[?2004h> print(f'Computed HMAC-SHA256 signature (hex, lowercase): {signature_hex}')
[?2004l[?2004h> "
[?2004lPayload for signature: v2.4.1-beta1698400800
Cleaned signing key (first 10 chars): super-secr...
Cleaned signing key length: 22
Computed HMAC-SHA256 signature (hex, lowercase): 50d318f35909f2d02a7941a4be4a5be8dd266e0b3e62247e520e3b4152078cd7
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# sqlite3 /var/lib/db/production.db "
[?2004l[?2004h> INSERT INTO deployment_log (iso_version, deploy_time, integrity_hash, status)
[?2004l[?2004h> VALUES ('v2.4.1-beta', 1698400800, '50d318f35909f2d02a7941a4be4a5be8dd266e0b3e62247e520e3b4152078cd7', 'pending_audit');
[?2004l[?2004h> "
[?2004l[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# sqlite3 /var/lib/db/production.db "SELECT * FROM deployment_log WHERE iso_version = 'v2.4.1-beta';"
[?2004l2|v2.4.1-beta|1698400800|50d318f35909f2d02a7941a4be4a5be8dd266e0b3e62247e520e3b4152078cd7|pending_audit
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# mkdir -p outgoing
[?2004l[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# python3 -c "
[?2004l[?2004h> import sys
[?2004l[?2004h> 
[?2004l[?2004h> # Data
[?2004l[?2004h> version = 'v2.4.1-beta'
[?2004l[?2004h> timestamp = '1698400800'
[?2004l[?2004h> signature = '50d318f35909f2d02a7941a4be4a5be8dd266e0b3e62247e520e3b4152078cd7'
[?2004l[?2004h> 
[?2004l[?2004h> # File path
[?2004l[?2004h> output_file = 'outgoing/legacy_sync.dat'
[?2004l[?2004h> 
[?2004l[?2004h> # Content
[?2004l[?2004h> content = f'{version}|{timestamp}|{signature}'
[?2004l[?2004h> 
[?2004l[?2004h> # Write to file with ISO-8859-1 encoding and CRLF line endings
[?2004l[?2004h> # For a single line, we can add '\r\n' at the end if it's not implicit for last line by some tools.
[?2004l[?2004h> # Python's newline='' in open means all '\n' are written as is. For CRLF, we have to specify newline='
[?2004l[?2004h> \n' or add it manually.
[?2004l[?2004h> # The simplest way is to write the string and then add a CRLF if it's not already there, or ensure the mode handles it.
[?2004l[?2004h> # For a single line file, we can just write the content string and then a separate CRLF.
[?2004l[?2004h> # Or, open with newline='' and write content + '\r\n'
[?2004l[?2004h> 
[?2004l[?2004h> with open(output_file, 'w', encoding='iso-8859-1', newline='') as f:
[?2004l[?2004h>     f.write(content + '\r\n') # Ensure CRLF line ending
[?2004l[?2004h> 
[?2004l[?2004h> print(f'Created {output_file}')
[?2004l[?2004h> print(f'Content: {content}')
[?2004l[?2004h> print(f'File encoding should be ISO-8859-1 with CRLF line endings.')
[?2004l[?2004h> " 2>&1
[?2004l  File "<string>", line 18
    \n' or add it manually.
     ^
SyntaxError: unexpected character after line continuation character
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# file outgoing/legacy_sync.dat
[?2004lbash: file: command not found
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# cat outgoing/legacy_sync.dat
[?2004lcat: outgoing/legacy_sync.dat: No such file or directory
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# hexdump -C outgoing/legacy_sync.dat
[?2004lbash: hexdump: command not found
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# python3 -c "
[?2004l[?2004h> version = 'v2.4.1-beta'
[?2004l[?2004h> timestamp = '1698400800'
[?2004l[?2004h> signature = '50d318f35909f2d02a7941a4be4a5be8dd266e0b3e62247e520e3b4152078cd7'
[?2004l[?2004h> output_file = 'outgoing/legacy_sync.dat'
[?2004l[?2004h> content = f'{version}|{timestamp}|{signature}'
[?2004l[?2004h> 
[?2004l[?2004h> with open(output_file, 'w', encoding='iso-8859-1', newline='') as f:
[?2004l[?2004h>     f.write(content + '\r\n')
[?2004l[?2004h> 
[?2004l[?2004h> print('legacy_sync.dat created with content:', content)
[?2004l[?2004h> " 2>&1
[?2004llegacy_sync.dat created with content: v2.4.1-beta|1698400800|50d318f35909f2d02a7941a4be4a5be8dd266e0b3e62247e520e3b4152078cd7
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# ls -la outgoing/legacy_sync.dat
[?2004l-rw-r--r-- 1 root root 89 Feb 13 19:02 outgoing/legacy_sync.dat
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# cat outgoing/legacy_sync.dat
[?2004lv2.4.1-beta|1698400800|50d318f35909f2d02a7941a4be4a5be8dd266e0b3e62247e520e3b4152078cd7
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# od -c outgoing/legacy_sync.dat
[?2004l0000000   v   2   .   4   .   1   -   b   e   t   a   |   1   6   9   8
0000020   4   0   0   8   0   0   |   5   0   d   3   1   8   f   3   5
0000040   9   0   9   f   2   d   0   2   a   7   9   4   1   a   4   b
0000060   e   4   a   5   b   e   8   d   d   2   6   6   e   0   b   3
0000100   e   6   2   2   4   7   e   5   2   0   e   3   b   4   1   5
0000120   2   0   7   8   c   d   7  \r  \n
0000131
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# python3 -c "
[?2004l[?2004h> import hashlib
[?2004l[?2004h> import json
[?2004l[?2004h> 
[?2004l[?2004h> version = 'v2.4.1-beta'
[?2004l[?2004h> signature = '50d318f35909f2d02a7941a4be4a5be8dd266e0b3e62247e520e3b4152078cd7'
[?2004l[?2004h> legacy_file_path = 'outgoing/legacy_sync.dat'
[?2004l[?2004h> output_manifest_path = 'outgoing/manifest.json'
[?2004l[?2004h> 
[?2004l[?2004h> # Calculate SHA-256 hash of the legacy_sync.dat file's binary content
[?2004l[?2004h> with open(legacy_file_path, 'rb') as f:
[?2004l[?2004h>     legacy_file_content_bytes = f.read()
[?2004l[?2004h>     sha256_hash = hashlib.sha256(legacy_file_content_bytes).hexdigest()
[?2004l[?2004h> 
[?2004l[?2004h> print(f'SHA-256 hash of {legacy_file_path}: {sha256_hash}')
[?2004l[?2004h> 
[?2004l[?2004h> # Create manifest data
[?2004l[?2004h> data = {
[?2004l[?2004h>     'version': version,
[?2004l[?2004h>     'legacy_file_sha256': sha256_hash,
[?2004l[?2004h>     'signature': signature
[?2004l[?2004h> }
[?2004l[?2004h> 
[?2004l[?2004h> # Write manifest to file
[?2004l[?2004h> with open(output_manifest_path, 'w', encoding='utf-8') as f:
[?2004l[?2004h>     json.dump(data, f, indent=2)
[?2004l[?2004h> 
[?2004l[?2004h> print(f'Manifest {output_manifest_path} created.')
[?2004l[?2004h> print(f'Manifest content:\n', json.dumps(data, indent=2))
[?2004l[?2004h> "
[?2004lSHA-256 hash of outgoing/legacy_sync.dat: 40f4695f705ff1fb714b49bd64fcb9c86ba6c61b315f74aebeab845bc448cc27
Manifest outgoing/manifest.json created.
Manifest content:
 {
  "version": "v2.4.1-beta",
  "legacy_file_sha256": "40f4695f705ff1fb714b49bd64fcb9c86ba6c61b315f74aebeab845bc448cc27",
  "signature": "50d318f35909f2d02a7941a4be4a5be8dd266e0b3e62247e520e3b4152078cd7"
}
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# cat outgoing/manifest.json
[?2004l{
  "version": "v2.4.1-beta",
  "legacy_file_sha256": "40f4695f705ff1fb714b49bd64fcb9c86ba6c61b315f74aebeab845bc448cc27",
  "signature": "50d318f35909f2d02a7941a4be4a5be8dd266e0b3e62247e520e3b4152078cd7"
}[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# chmod 0444 outgoing/manifest.json
[?2004l[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# ls -la outgoing/manifest.json
[?2004l-r--r--r-- 1 root root 205 Feb 13 19:02 outgoing/manifest.json
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# ls -la outgoing/
[?2004ltotal 8
drwxrwxrwx 1 root root  62 Feb 13 19:02 [0m[34;42m.[0m
drwxrwxrwx 1 root root  30 Feb 13 18:50 [34;42m..[0m
-rw-r--r-- 1 root root  89 Feb 13 19:02 legacy_sync.dat
-r--r--r-- 1 root root 205 Feb 13 19:02 manifest.json
[?2004hroot@deffe039-a7f3-4eed-8987-0dc55da36361:/home/user/workspace# 