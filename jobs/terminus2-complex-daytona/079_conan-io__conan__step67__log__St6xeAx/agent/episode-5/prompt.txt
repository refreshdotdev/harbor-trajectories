Previous response had warnings:
WARNINGS: - Extra text detected before JSON object
- Extra text detected after JSON object

New Terminal Output:

root@39bdc262-3610-44de-afa5-532e6c1977b7:/workspace/repo# cat conan/api/output.py
import fnmatch
import os
import sys
import time
from threading import Lock
import colorama
from colorama import Fore, Style
from conan.errors import ConanException
LEVEL_QUIET = 80
LEVEL_ERROR = 70
LEVEL_WARNING = 60
LEVEL_NOTICE = 50
LEVEL_STATUS = 40
LEVEL_VERBOSE = 30
LEVEL_DEBUG = 20
LEVEL_TRACE = 10

class Color:
    """ Wrapper around colorama colors that are undefined in importing
    """
    RED = Fore.RED
    WHITE = Fore.WHITE
    CYAN = Fore.CYAN
    GREEN = Fore.GREEN
    MAGENTA = Fore.MAGENTA
    BLUE = Fore.BLUE
    YELLOW = Fore.YELLOW
    BLACK = Fore.BLACK
    BRIGHT_RED = Style.BRIGHT + Fore.RED
    BRIGHT_BLUE = Style.BRIGHT + Fore.BLUE
    BRIGHT_YELLOW = Style.BRIGHT + Fore.YELLOW
    BRIGHT_GREEN = Style.BRIGHT + Fore.GREEN
    BRIGHT_CYAN = Style.BRIGHT + Fore.CYAN
    BRIGHT_WHITE = Style.BRIGHT + Fore.WHITE
    BRIGHT_MAGENTA = Style.BRIGHT + Fore.MAGENTA
if os.environ.get('CONAN_COLOR_DARK'):
    Color.WHITE = Fore.BLACK
    Color.CYAN = Fore.BLUE
    Color.YELLOW = Fore.MAGENTA
    Color.BRIGHT_WHITE = Fore.BLACK
    Color.BRIGHT_CYAN = Fore.BLUE
    Color.BRIGHT_YELLOW = Fore.MAGENTA
    Color.BRIGHT_GREEN = Fore.GREEN

def init_colorama(stream):
    import colorama
    if _color_enabled(stream):
        if os.getenv('CLICOLOR_FORCE', '0') != '0':
            colorama.init(strip=False, convert=False)
        else:
            colorama.init()

def _color_enabled(stream):
    """
    NO_COLOR: No colors

    https://no-color.org/

    Command-line software which adds ANSI color to its output by default should check for the
    presence of a NO_COLOR environment variable that, when present (**regardless of its value**),
    prevents the addition of ANSI color.

    CLICOLOR_FORCE: Force color

    https://bixense.com/clicolors/
    """
    if os.getenv('CLICOLOR_FORCE', '0') != '0':
        return True
    if os.getenv('NO_COLOR') is not None:
        return False
    return hasattr(stream, 'isatty') and stream.isatty()

class ConanOutput:
    """ A singleton class to handle output messages in Conan.

    Recipes should only access this class through the ``self.output`` attribute of the recipe,
    but custom commands or tools can instantiate it directly, where doing so for each message is
    a valid practice.

    It provides methods to write messages at different levels of verbosity, such as debug, info,
    warning, and error. The output level can be controlled by the user through command-line options
    or environment variables.

    The output methods return the instance itself, so different methods can be chained together.
    """
    _conan_output_level = LEVEL_STATUS
    _silent_warn_tags = []
    _warnings_as_errors = []
    lock = Lock()

    def __init__(self, scope: str=''):
        """ Initialize the ConanOutput instance.

        :parameter scope: A string that represents the scope of the output. This is usually the
            reference of the recipe being executed, like ``pkg/1.0@user/channel`` and is prefixed
            to the output messages. If not provided, it defaults to an empty string.
        """
        self.stream = sys.stderr
        self._scope = scope
        self._color = _color_enabled(self.stream)

    @classmethod
    def define_silence_warnings(cls, warnings):
        cls._silent_warn_tags = warnings

    @classmethod
    def set_warnings_as_errors(cls, value):
        cls._warnings_as_errors = value

    @classmethod
    def get_output_level(cls):
        return cls._conan_output_level

    @classmethod
    def set_output_level(cls, level):
        cls._conan_output_level = level

    @classmethod
    def valid_log_levels(cls):
        return {'quiet': LEVEL_QUIET, 'error': LEVEL_ERROR, 'warning': LEVEL_WARNING, 'notice': LEVEL_NOTICE, 'status': LEVEL_STATUS, None: LEVEL_VERBOSE, 'verb
ose': LEVEL_VERBOSE, 'debug': LEVEL_DEBUG, 'v': LEVEL_DEBUG, 'trace': LEVEL_TRACE, 'vv': LEVEL_TRACE}

    @classmethod
    def define_log_level(cls, v):
        env_level = os.getenv('CONAN_LOG_LEVEL')
        v = env_level or v
        levels = cls.valid_log_levels()
        try:
            level = levels[v]
        except KeyError:
            msg = ' defined in CONAN_LOG_LEVEL environment variable' if env_level else ''
            vals = 'quiet, error, warning, notice, status, verbose, debug(v), trace(vv)'
            raise ConanException(f"Invalid argument '-v{v}'{msg}.\nAllowed values: {vals}")
        else:
            cls.set_output_level(level)

    @classmethod
    def level_allowed(cls, level):
        return cls._conan_output_level <= level

    @property
    def color(self):
        return self._color

    @property
    def scope(self):
        return self._scope

    @scope.setter
    def scope(self, out_scope):
        self._scope = out_scope

    @property
    def is_terminal(self):
        return hasattr(self.stream, 'isatty') and self.stream
[... output limited to 10000 bytes; 70 interior bytes omitted ...]
ents,
        like the start or completion of processes, without implying specific problems or achievements."""
        if self._conan_output_level <= LEVEL_STATUS:
            self._write_message(msg, fg=fg, bg=bg, newline=newline)
        return self
    info = status

    def title(self, msg: str):
        """ Draws a title around the message, useful for important messages"""
        if self._conan_output_level <= LEVEL_NOTICE:
            self._write_message('\n======== {} ========'.format(msg), fg=Color.BRIGHT_MAGENTA)
        return self

    def subtitle(self, msg: str):
        """ Draws a subtitle around the message, useful for important messages"""
        if self._conan_output_level <= LEVEL_NOTICE:
            self._write_message('\n-------- {} --------'.format(msg), fg=Color.BRIGHT_MAGENTA)
        return self

    def highlight(self, msg: str):
        """ Marks or emphasizes important events or processes that need to stand out but don’t necessarily
        indicate success or error.

        These messages draw attention to key points that may be relevant for the user or administrator."""
        if self._conan_output_level <= LEVEL_NOTICE:
            self._write_message(msg, fg=Color.BRIGHT_MAGENTA)
        return self

    def success(self, msg: str):
        """ Shows that an operation has been completed successfully.

        This type of message is useful to confirm that key processes or tasks have finished correctly,
        which is essential for good application monitoring."""
        if self._conan_output_level <= LEVEL_NOTICE:
            self._write_message(msg, fg=Color.BRIGHT_GREEN)
        return self

    @staticmethod
    def _warn_tag_matches(warn_tag, patterns):
        lookup_tag = warn_tag or 'unknown'
        return any((fnmatch.fnmatch(lookup_tag, pattern) for pattern in patterns))

    def warning(self, msg: str, warn_tag: str=None):
        """ Highlights a potential issue that, while not stopping the system,
        could cause problems in the future or under certain conditions.

        Warnings signal abnormal situations that should be
        reviewed but don’t necessarily cause an immediate halt in operations.
        Notice that if the tag matches the pattern in the ``core:warnings_as_errors`` configuration,
        and is not skipped, this will be upgraded to an error, and raise an exception
        when the output is printed, so that the error does not pass unnoticed."""
        _treat_as_error = self._warn_tag_matches(warn_tag, self._warnings_as_errors)
        if self._conan_output_level <= LEVEL_WARNING or (_treat_as_error and self._conan_output_level <= LEVEL_ERROR):
            if self._warn_tag_matches(warn_tag, self._silent_warn_tags):
                return self
            warn_tag_msg = '' if warn_tag is None else f'{warn_tag}: '
            output = f'{warn_tag_msg}{msg}'
            if _treat_as_error:
                self.error(output)
            else:
                self._write_message(f'WARN: {output}', Color.YELLOW)
        return self

    def error(self, msg: str, error_type: str=None):
        """ Indicates that a serious issue has occurred that prevents the system
        or application from continuing to function correctly.

        Typically, this represents a failure in the normal flow of execution,
        such as a service crash or a critical exception.
        Notice that if the user has set the ``core:warnings_as_errors`` configuration,
        this will raise an exception when the output is printed,
        so that the error does not pass unnoticed."""
        if self._warnings_as_errors and error_type != 'exception':
            raise ConanException(msg)
        if self._conan_output_level <= LEVEL_ERROR:
            self._write_message('ERROR: {}'.format(msg), Color.RED)
        return self

    def flush(self):
        self.stream.flush()

def cli_out_write(data, fg=None, bg=None, endline='\n', indentation=0):
    """
    Output to be used by formatters to dump information to stdout
    """
    if (fg or bg) and _color_enabled(sys.stdout):
        data = f"{' ' * indentation}{fg or ''}{bg or ''}{data}{Style.RESET_ALL}{endline}"
        sys.stdout.write(data)
    else:
        data = f"{' ' * indentation}{data}{endline}"
        if sys.stdout.isatty():
            colorama.deinit()
            sys.stdout.write(data)
            colorama.reinit()
        else:
            sys.stdout.write(data)

class TimedOutput:

    def __init__(self, interval, out=None, msg_format=None):
        self._interval = interval
        self._msg_format = msg_format
        self._t = time.time()
        self._out = out or ConanOutput()

    def info(self, msg, *args, **kwargs):
        t = time.time()
        if t - self._t > self._interval:
            self._t = t
            if self._msg_format:
                msg = self._msg_format(msg, *args, **kwargs)
            self._out.info(msg)root@39bdc262-3610-44de-afa5-532e6c1977b7:/workspace/repo#
