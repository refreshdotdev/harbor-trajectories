{"version": 2, "width": 160, "height": 40, "timestamp": 1770669311, "env": {"SHELL": "/bin/bash", "TERM": "tmux-256color"}}
[0.005991, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo# "]
[0.778186, "i", "clear\r"]
[0.778372, "o", "clear\r\n\u001b[?2004l\r"]
[0.780212, "o", "\u001b[H\u001b[J\u001b[3J"]
[0.780432, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo# "]
[6.707279, "i", "ls -la\n"]
[6.707459, "o", "ls -la\r\n\u001b[?2004l\r"]
[6.710186, "o", "total 184\r\n"]
[6.710259, "o", "drwxr-xr-x 1 root root    55 Feb  9 20:23 .\r\ndrwxr-xr-x 1 root root    26 Feb  9 20:23 ..\r\n-rw-rw-r-- 1 root root   446 Jan 21 16:29 .clang-format\r\n-rw-rw-r-- 1 root root   484 Jan 21 16:29 .coveragerc\r\n"]
[6.71033, "o", "-rw-rw-r-- 1 root root   222 Jan 21 16:29 .gitattributes\r\ndrwxr-xr-x 3 root root    93 Feb  9 20:23 .github\r\n-rw-rw-r-- 1 root root   227 Jan 21 16:29 .gitignore\r\ndrwxr-xr-x 3 root root    72 Feb  9 20:23 .mypy_cache\r\n-rw-rw-r-- 1 root root   231 Jan 21 16:29 .readthedocs.yaml\r\n-rw-rw-r-- 1 root root 81978 Jan 21 16:29 CHANGES.rst\r\n-rw-rw-r-- 1 root root 19467 Jan 21 16:29 LICENSE-CC-BY-3.0.txt\r\n-rw-rw-r-- 1 root root  1632 Jan 21 16:29 LICENSE.txt\r\n"]
[6.710367, "o", "-rw-rw-r-- 1 root root   364 Jan 21 16:29 MANIFEST.in\r\n-rw-rw-r-- 1 root root  2545 Jan 21 16:29 README.rst\r\ndrwxr-xr-x 3 root root    68 Feb  9 20:23 docs\r\n-rw-rw-r-- 1 root root   163 Jan 21 16:29 edm.yaml\r\n-rw-rw-r-- 1 root root 17475 Jan 21 16:29 etstool.py\r\ndrwxr-xr-x 3 root root    53 Feb  9 20:23 examples\r\n-rw-rw-r-- 1 root root   961 Jan 21 16:29 image_LICENSE.txt\r\n-rw-rw-r-- 1 root root   254 Jan 21 16:29 pyproject.toml\r\n-rw-rw-r-- 1 root root   238 Jan 21 16:29 setup.cfg\r\n-rw-rw-r-- 1 root root 10510 Jan 21 16:29 setup.py\r\ndrwxr-xr-x 1 root root    61 Feb  9 20:23 traits\r\ndrwxr-xr-x 1 root root   162 Feb  9 20:23 traits.egg-info\r\n"]
[6.710767, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo# "]
[10.099552, "i", "cd traits\n"]
[10.099808, "o", "cd traits\r\n\u001b[?2004l\r"]
[10.099974, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[10.474892, "i", "ls -la\n"]
[10.475109, "o", "ls -la\r\n\u001b[?2004l\r"]
[10.476908, "o", "total 1108\r\ndrwxr-xr-x 1 root root     61 Feb  9 20:23 .\r\ndrwxr-xr-x 1 root root     55 Feb  9 20:23 ..\r\n-rw-rw-r-- 1 root root    815 Jan 21 16:29 __init__.py\r\n-rw-rw-r-- 1 root root      0 Jan 21 16:29 __init__.pyi\r\n"]
[10.477047, "o", "drwxr-xr-x 3 root root    185 Feb  9 20:23 adaptation\r\n-rw-rw-r-- 1 root root   3673 Jan 21 16:29 api.py\r\n-rw-rw-r-- 1 root root   4597 Jan 21 16:29 api.pyi\r\n-rw-rw-r-- 1 root root   6365 Jan 21 16:29 base_trait_handler.py\r\n-rw-rw-r-- 1 root root    440 Jan 21 16:29 base_trait_handler.pyi\r\n-rw-rw-r-- 1 root root   6610 Jan 21 16:29 constants.py\r\n-rw-rw-r-- 1 root root   1508 Jan 21 16:29 constants.pyi\r\n-rw-rw-r-- 1 root root   8422 Jan 21 16:29 ctrait.py\r\n-rw-rw-r-- 1 root root   1613 Jan 21 16:29 ctrait.pyi\r\n-rw-rw-r-- 1 root root 186979 Jan 21 16:29 ctraits.c\r\n-rwxr-xr-x 1 root root 269272 Feb  9 20:23 ctraits.cpython-310-x86_64-linux-gnu.so\r\n-rw-rw-r-- 1 root root   1049 Jan 21 16:29 ctraits.pyi\r\n-rw-rw-r-- 1 root root   5808 Jan 21 16:29 editor_factories.py\r\n-rw-rw-r-- 1 root root   1052 Jan 21 16:29 editor_factories.pyi\r\ndrwxr-xr-x 3 root root     92 Feb  9 20:23 etsconfig\r\ndrwxr-xr-x 4 root root    102 Feb  9 20:23 examples\r\n-rw-rw-r-- 1 root root 109698 Jan 21 16:29 has_traits.py\r\n-rw-rw-r-- 1 root root   7285 Jan 21 16:29 has_traits.pyi\r\n-rw-rw-r-- 1 root root   5881 Jan 21 16:29 interface_checker.py\r\ndrwxr-xr-x 3 root root   4096 Feb  9 20:23 observation\r\n-rw-rw-r-- 1 root root      0 Jan 21 16:29 py.typed\r\ndrwxr-xr-x 4 root root    121 Feb  9 20:23 stubs_tests\r\ndrwxr-xr-x 3 root root    161 Feb  9 20:23 testing\r\ndrwxr-xr-x 3 root root   4096 Feb  9 20:23 tests\r\n-rw-rw-r-- 1 root root  10269 Jan 21 16:29 trait_base.py\r\n-rw-rw-r-- 1 root root   4365 Jan 21 16:29 trait_converters.py\r\n-rw-rw-r-- 1 root root  17835 Jan 21 16:29 trait_dict_object.py\r\n-rw-rw-r-- 1 root root   3198 Jan 21 16:29 trait_errors.py\r\n-rw-rw-r-- 1 root root   2211 Jan 21 16:29 trait_factory.py\r\n"]
[10.477105, "o", "-rw-rw-r-- 1 root root   2987 Jan 21 16:29 trait_handler.py\r\n-rw-rw-r-- 1 root root    505 Jan 21 16:29 trait_handler.pyi\r\n-rw-rw-r-- 1 root root  25687 Jan 21 16:29 trait_handlers.py\r\n-rw-rw-r-- 1 root root   1480 Jan 21 16:29 trait_handlers.pyi\r\n-rw-rw-r-- 1 root root  27588 Jan 21 16:29 trait_list_object.py\r\n-rw-rw-r-- 1 root root  24960 Jan 21 16:29 trait_notifiers.py\r\n-rw-rw-r-- 1 root root  14260 Jan 21 16:29 trait_numeric.py\r\n-rw-rw-r-- 1 root root   2099 Jan 21 16:29 trait_numeric.pyi\r\n-rw-rw-r-- 1 root root  16770 Jan 21 16:29 trait_set_object.py\r\n-rw-rw-r-- 1 root root  19113 Jan 21 16:29 trait_type.py\r\n-rw-rw-r-- 1 root root   1845 Jan 21 16:29 trait_type.pyi\r\n-rw-rw-r-- 1 root root 148950 Jan 21 16:29 trait_types.py\r\n-rw-rw-r-- 1 root root  11982 Jan 21 16:29 trait_types.pyi\r\n-rw-rw-r-- 1 root root  24535 Jan 21 16:29 traits.py\r\n-rw-rw-r-- 1 root root   1579 Jan 21 16:29 traits.pyi\r\n-rw-rw-r-- 1 root root  43250 Jan 21 16:29 traits_listener.py\r\n-rw-rw-r-- 1 root root    168 Jan 21 16:29 traits_notifiers.pyi\r\ndrwxr-xr-x 3 root root   4096 Feb  9 20:23 util\r\n-rw-rw-r-- 1 root root    772 Jan 21 16:29 version.py\r\n"]
[10.477335, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[14.841143, "i", "nano has_traits.py\n"]
[14.841293, "o", "nano has_traits.py\r\n\u001b[?2004l\r"]
[14.84175, "o", "bash: nano: command not found\r\n"]
[14.842064, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[17.527369, "i", "vi has_traits.py\n"]
[17.527525, "o", "vi has_traits.py\r\n\u001b[?2004l\r"]
[17.527926, "o", "bash: vi: command not found\r\n"]
[17.52814, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[21.283068, "i", "cat has_traits.py\n"]
[21.28323, "o", "cat has_traits.py\r\n\u001b[?2004l\r"]
[21.284625, "o", "\"\"\" Defines the HasTraits class, along with several useful subclasses and\r\n    associated metaclasses.\r\n\"\"\"\r\nimport abc\r\nimport copy as copy_module\r\nimport inspect\r\nimport os\r\nimport pickle\r\nimport re\r\nimport types\r\nimport warnings\r\nimport weakref\r\nfrom types import FunctionType\r\nfrom . import __version__ as TraitsVersion\r\nfrom .constants import DefaultValue, TraitKind\r\nfrom .ctrait import CTrait, __newobj__\r\nfrom .ctraits import CHasTraits\r\nfrom .observation import api as observe_api\r\nfrom .traits import ForwardProperty, Property, Trait, generic_trait\r\nfrom .trait_types import Any, Bool, Disallow, Event, Python, Str\r\nfrom .trait_notifiers import ExtendedTraitChangeNotifyWrapper, FastUITraitChangeNotifyWrapper, NewTraitChangeNotifyWrapper, StaticAnytraitChangeNotifyWrapper, StaticTraitChangeNotifyWrapper, TraitChangeNotifyWrapper, ui_dispatch\r\nfrom .trait_base import SequenceTypes, TraitsCache, Undefined, is_none, not_event, not_false\r\nfrom .trait_errors import TraitError\r\nfrom .trait_converters import check_trait, mapped_trait_for, trait_for\r\nCHECK_INTERFACES = 0\r\n\r\nclass AbstractViewElement(abc.ABC):\r\n    pass\r\nWrapperTypes = (StaticAnytraitChangeNotifyWrapper, StaticTraitChangeNotifyWrapper)\r\nBaseTraits = '__base_traits__'\r\nClassTraits = '__class_traits__'\r\nPrefixTraits = '__prefix_traits__'\r\nListenerTraits = '__listener_traits__'\r\nObserverTraits = '__observer_traits__'\r\nViewTraits = '__view_traits__'\r\nInstanceTraits = '__instance_traits__'\r\nDefaultTraitsView = 'traits_view'\r\nCantHaveDefaultValue = ('event', 'delegate', 'constant')\r\nDeferredCopy = ('delegate', 'property')\r\nextended_trait_pat = re.compile('.*[ :\\\\+\\\\-,\\\\.\\\\*\\\\?\\\\[\\\\]]')\r\nany_trait = Any().as_ctrait()\r\n_ObserverDispatchers = {'same': observe_api.dispatch_same, 'ui': ui_dispatch}\r\n\r\ndef _clone_trait(clone, metadata=None):\r\n    \"\"\" Creates a clone of a specified trait.\r\n    \"\"\"\r\n    trait = CTrait(TraitKind.trait)\r\n    trait.clone(clone)\r\n    if clone.__dict__ is not None:\r\n        trait.__dict__ = clone.__dict__.copy()\r\n    if metadata is not None:\r\n        trait.__dict__.update(metadata)\r\n    return trait\r\n\r\ndef _get_method(cls, method):\r\n    \"\"\" Get the definition of a specified method (if any). \"\"\"\r\n    result = getattr(cls, method, None)\r\n    if result is not None and is_unbound_method_type(result):\r\n        return result\r\n    return None\r\n\r\ndef _get_def(class_name, class_dict, bases, method):\r\n    \"\"\" Gets the definition of a specified method (if any).\r\n    \"\"\"\r\n    if method[0:2] == '__':\r\n        method = '_%s%s' % (class_name.lstrip('_'), method)\r\n    result = class_dict.get(method)\r\n    if result is not None and is_unbound_method_type(result) and (getattr(result, 'on_trait_change', None) is None) and (getattr(result, '_observe_inputs', None) is None):\r\n        return result\r\n    for base in bases:\r\n        result = getattr(base, method, None)\r\n        if result is not None and is_unbound_method_type(result) and (getattr(result, 'on_trait_change', None) is None) and (getattr(result, '_observe_inputs', None) is None):\r\n            return result\r\n    return None\r\n\r\ndef is_unbound_method_type(method):\r\n    \"\"\" Check for something that looks like an unbound class method.\r\n\r\n    This is used in practice to identify magic-named _name_changed\r\n    and _name_fired methods.\r\n\r\n    \"\"\"\r\n    return inspect.isfunction(method) or inspect.ismethoddescriptor(method)\r\n\r\ndef _is_serializable(value):\r\n    \"\"\" Returns whether or not a specified value is serializable.\r\n    \"\"\"\r\n    if isinstance(value, (list, tuple)):\r\n        for item in value:\r\n            if not _is_serializable(item):\r\n                return False\r\n        return True\r\n    if isinstance(value, dict):\r\n        for (name, item) in value.items():\r\n            if not _is_serializable(name) or not _is_serializable(item):\r\n                return False\r\n        return True\r\n    return not isinstance(value, HasTraits) or value.has_traits_interface(ISerializable)\r\n\r\ndef _get_instance_handlers(class_dict, bases):\r\n    \"\"\" Returns a dictionary of potential 'Instance' or 'List(Instance)'\r\n        handlers.\r\n    \"\"\"\r\n    instance_traits = {}\r\n    for base in bases:\r\n        for (name, base_arg_lists) in base.__dict__.get(InstanceTraits).items():\r\n            arg_lists = instance_traits.get(name)\r\n            if arg_lists is None:\r\n                instance_traits[name] = base_arg_lists[:]\r\n            else:\r\n                for arg_list in base_arg_lists:\r\n                    if arg_list not in arg_lists:\r\n                        arg_lists.append(arg_list)\r\n    for (name, value) in class_dict.items():\r\n        if name[:1] == '_' and is_unbound_method_type(value):\r\n            n = 13\r\n            col = name.find('_changed_for_')\r\n            if col < 2:\r\n                n = 11\r\n                col = name.find('_fired_for_')\r\n            if col >= 2:\r\n                key = name[col + n:]\r\n                if key != '':\r\n                    arg_list = (name, name[1:col])\r\n                    arg_lists = instance_traits.setdefault(key, [])\r\n                    if arg_list not in arg_lists:\r\n                        arg_lists.append(arg_list)\r\n    return instance_traits\r\n\r\ndef get_delegate_pattern(name, trait):\r\n    \"\"\" Returns the correct 'delegate' listener pattern for a specified name\r\n    and delegate trait.\r\n    \"\"\"\r\n    prefix = trait._prefix\r\n    if prefix == '':\r\n        prefix = name\r\n    elif len(prefix) > 1 and prefix[-1] == '*':\r\n        prefix = prefix[:-1] + name\r\n    return ' %s:%s' % (trait._delegate, prefix)\r\n\r\nclass _SimpleTest:\r\n\r\n    def __init__(self, value):\r\n        self.value = value\r\n\r\n    def __call__(self, test):\r\n        return test == self.value\r\n\r\ndef _add_notifiers(notifiers, handlers):\r\n    \"\"\" Adds a list of handlers to a specified notifiers list.\r\n    \"\"\"\r\n    for handler in handlers:"]
[21.284717, "o", "\r\n        if not isinstance(handler, WrapperTypes):\r\n            handler = StaticTraitChangeNotifyWrapper(handler)\r\n        notifiers.append(handler)\r\n\r\ndef _add_event_handlers(trait, cls, handlers):\r\n    \"\"\" Adds any specified event handlers defined for a trait by a class.\r\n    \"\"\"\r\n    events = trait.event\r\n    if events is not None:\r\n        if isinstance(events, str):\r\n            events = [events]\r\n        for event in events:\r\n            handlers.append(_get_method(cls, '_%s_changed' % event))\r\n            handlers.append(_get_method(cls, '_%s_fired' % event))\r\n\r\ndef _property_method(class_dict, name):\r\n    \"\"\" Returns the method associated with a particular class property\r\n    getter/setter.\r\n    \"\"\"\r\n    return class_dict.get(name)\r\n\r\ndef _create_property_observe_state(observe, property_name, cached):\r\n    \"\"\" Create the metadata for setting up an observer for Property.\r\n\r\n    Parameters\r\n    ----------\r\n    observe : str or list or Expression\r\n        As is accepted by HasTraits.observe expression argument\r\n        This is the value provided in Property(observe=...)\r\n    property_name : str\r\n        The name of the property trait.\r\n    cached : boolean\r\n        Whether the property is cached or not.\r\n\r\n    Returns\r\n    -------\r\n    state : dict\r\n        State to be used by _init_traits_observers\r\n    \"\"\"\r\n\r\n    def handler(instance, event):\r\n        if cached:\r\n            cache_name = TraitsCache + property_name\r\n            old = instance.__dict__.pop(cache_name, Undefined)\r\n        else:\r\n            old = Undefined\r\n        instance.trait_property_changed(property_name, old)\r\n\r\n    def handler_getter(instance, name):\r\n        return types.MethodType(handler, instance)\r\n    graphs = _compile_expression(observe)\r\n    return dict(graphs=graphs, dispatch='same', handler_getter=handler_getter, post_init=False)\r\n\r\ndef _compile_expression(expression):\r\n    \"\"\" Compile a user-supplied expression or list of expressions.\r\n\r\n    Converts a list of strings or ObserverExpressions to a list of\r\n    ObserverGraphs representing the observation patterns to be applied.\r\n\r\n    Parameters\r\n    ----------\r\n    expression : str or list or ObserverExpression\r\n        A description of what traits are being observed.\r\n        If this is a list, each item must be a string or an ObserverExpression.\r\n\r\n    Returns\r\n    -------\r\n    graphs : list of ObserverGraph\r\n        List of graphs representing the observation patterns to be applied\r\n        to the relevant objects and handlers.\r\n    \"\"\"\r\n    if isinstance(expression, list):\r\n        expressions = expression\r\n    else:\r\n        expressions = [expression]\r\n    graphs = []\r\n    for expr in expressions:\r\n        graphs.extend(observe_api.compile_str(expr) if isinstance(expr, str) else observe_api.compile_expr(expr))\r\n    return graphs\r\n_HasTraits = None\r\n\r\nclass MetaHasTraits(type):\r\n    \"\"\" Controls the creation of HasTraits classes.\r\n\r\n    The heavy work is done by the `update_traits_class_dict` function, which\r\n    takes the ``class_dict`` dictionary of class members and extracts and\r\n    processes the trait declarations in it. The trait declarations are then\r\n    added back to the class dictionary and passed off to the __new__ method\r\n    of the type superclass, to be added to the class.\r\n\r\n    \"\"\"\r\n\r\n    def __new__(cls, class_name, bases, class_dict):\r\n        update_traits_class_dict(class_name, bases, class_dict)\r\n        return type.__new__(cls, class_name, bases, class_dict)\r\n\r\ndef update_traits_class_dict(class_name, bases, class_dict):\r\n    \"\"\" Processes all of the traits related data in the class dictionary.\r\n\r\n    This is called during the construction of a new HasTraits class. The first\r\n    three parameters have the same interpretation as the corresponding\r\n    parameters of ``type.__new__``. This function modifies ``class_dict``\r\n    in-place.\r\n\r\n    Parameters\r\n    ----------\r\n    class_name : str\r\n        The name of the HasTraits class.\r\n    bases : tuple\r\n        The base classes for the HasTraits class.\r\n    class_dict : dict\r\n        A dictionary of class members.\r\n    \"\"\"\r\n    base_traits = {}\r\n    class_traits = {}\r\n    prefix_traits = {}\r\n    listeners = {}\r\n    prefix_list = []\r\n    view_elements = {}\r\n    observers = {}\r\n    hastraits_bases = [base for base in bases if base.__dict__.get(ClassTraits) is not None]\r\n    inherited_class_traits = [base.__dict__.get(ClassTraits) for base in hastraits_bases]\r\n    for (name, value) in list(class_dict.items()):\r\n        value = check_trait(value)\r\n        rc = isinstance(value, CTrait)\r\n        if not rc and isinstance(value, ForwardProperty):\r\n            rc = True\r\n            getter = _property_method(class_dict, '_get_' + name)\r\n            setter = _property_method(class_dict, '_set_' + name)\r\n            if setter is None and getter is not None:\r\n                if getattr(getter, 'settable', False):\r\n                    setter = HasTraits._set_traits_cache\r\n                elif getattr(getter, 'flushable', False):\r\n                    setter = HasTraits._flush_traits_cache\r\n            validate = _property_method(class_dict, '_validate_' + name)\r\n            if validate is None:\r\n                validate = value.validate\r\n            value = Property(getter, setter, validate, True, value.handler, **value.metadata)\r\n        if rc:\r\n            del class_dict[name]\r\n            if name[-1:] != '_':\r\n                base_traits[name] = class_traits[name] = value\r\n                value_type = value.type\r\n                if value_type == 'trait':\r\n                    handler = value.handler\r\n                    if handler is not None:\r\n                        if handler.has_items:\r\n                            items_trait = _clone_trait(handler.items_event(), value.__dict__)\r\n                            if items_trait.instance_handler == '_list_changed_handler':\r\n                                items_trait.instance_handler = '_list_items_changed_handler'\r\n                            class_traits[name + '_items'] = items_trait\r\n                        if handler.is_mapped:\r\n                            class_traits[name + '_'] = mapped_trait_for(value, name)\r\n                elif value_type == 'delegate':\r\n                    if value._listenable is not False:\r\n                        listeners[name] = ('delegate', get_delegate_pattern(name, value))\r\n                elif value_type == 'event':\r\n                    on_trait_change = value.on_trait_change\r\n                    if isinstance(on_trait_change, str):\r\n                        listeners[name] = ('event', on_trait_change)\r\n            else:\r\n                name = name[:-1]\r\n                prefix_list.append(name)\r\n                prefix_traits[name] = value\r\n        elif is_unbound_method_type(value):\r\n            pattern = getattr(value, 'on_trait_change', None)\r\n            if pattern is not None:\r\n                listeners[name] = ('method', pattern)\r\n            observer_states = getattr(value, '_observe_inputs', None)\r\n            if observer_states is not None:\r\n                observers[name] = observer_states\r\n        elif isinstance(value, property):\r\n            class_traits[name] = generic_trait\r\n        elif isinstance(value, AbstractViewElement):\r\n            view_elements[name] = value\r\n            del class_dict[name]\r\n        else:\r\n            for ct in inherited_class_traits:\r\n                if name in ct:\r\n                    ictrait = ct[name]\r\n                    if ictrait.type in CantHaveDefaultValue:\r\n                        raise TraitError(\"Cannot specify a default value for the %s trait '%s'. You must override the the trait definition instead.\" % (ictrait.type, name))\r\n                    class_traits[name] = ictrait(value)\r\n                    del class_dict[name]\r\n                    break\r\n    migrated_properties = {}\r\n    for base in hastraits_bases:\r\n        base_dict = base.__dict__\r\n        for (name, value) in base_dict.get(ListenerTraits).items():\r\n            if name not in class_traits and name not in class_dict:\r\n                listeners[name] = value\r\n        for (name, states) in base_dict[ObserverTraits].items():\r\n            if name not in class_traits and name not in class_dict:\r\n                observers[name] = states\r\n        for (name, value) in base_dict.get(BaseTraits).items():\r\n            if name not in base_traits:\r\n                property_info = value.property_fields\r\n                if property_info is not None:\r\n                    key = id(value)\r\n                    migrated_properties[key] = value = migrate_property(name, value, property_info, class_dict)\r\n                base_traits[name] = value\r\n"]
[21.285133, "o", "        for (name, value) in base_dict.get(ClassTraits).items():\r\n            if name not in class_traits:\r\n                property_info = value.property_fields\r\n                if property_info is not None:\r\n                    new_value = migrated_properties.get(id(value))\r\n                    if new_value is not None:\r\n                        value = new_value\r\n                    else:\r\n                        value = migrate_property(name, value, property_info, class_dict)\r\n                class_traits[name] = value\r\n        base_prefix_traits = base_dict.get(PrefixTraits)\r\n        for name in base_prefix_traits['*']:\r\n            if name not in prefix_list:\r\n                prefix_list.append(name)\r\n                prefix_traits[name] = base_prefix_traits[name]\r\n    if prefix_traits.get('') is None:\r\n        prefix_list.append('')\r\n        prefix_traits[''] = Python().as_ctrait()\r\n    prefix_traits['*'] = prefix_list\r\n    prefix_list.sort(key=len, reverse=True)\r\n    instance_traits = _get_instance_handlers(class_dict, hastraits_bases)\r\n    anytrait = _get_def(class_name, class_dict, bases, '_anytrait_changed')\r\n    if anytrait is not None:\r\n        anytrait = StaticAnytraitChangeNotifyWrapper(anytrait)\r\n        prefix_traits['@'] = anytrait\r\n    cloned = set()\r\n    for name in list(class_traits.keys()):\r\n        trait = class_traits[name]\r\n        handlers = [anytrait, _get_def(class_name, class_dict, bases, '_%s_changed' % name), _get_def(class_name, class_dict, bases, '_%s_fired' % name)]\r\n        instance_handler = trait.instance_handler\r\n        if instance_handler is not None and name in instance_traits or (instance_handler == '_list_items_changed_handler' and name[-6:] == '_items' and (name[:-6] in instance_traits)):\r\n            handlers.append(getattr(HasTraits, instance_handler))\r\n        events = trait.event\r\n        if events is not None:\r\n            if isinstance(events, str):\r\n                events = [events]\r\n            for event in events:\r\n                handlers.append(_get_def(class_name, class_dict, bases, '_%s_changed' % event))\r\n                handlers.append(_get_def(class_name, class_dict, bases, '_%s_fired' % event))\r\n        handlers = [h for h in handlers if h is not None]\r\n        default = _get_def(class_name, class_dict, [], '_%s_default' % name)\r\n        if len(handlers) > 0 or default is not None:\r\n            if name not in cloned:\r\n                cloned.add(name)\r\n                class_traits[name] = trait = _clone_trait(trait)\r\n            if len(handlers) > 0:\r\n                _add_notifiers(trait._notifiers(True), handlers)\r\n            if default is not None:\r\n                trait.set_default_value(DefaultValue.callable, default)\r\n        if trait.type == 'property' and trait.depends_on is not None:\r\n            cached = trait.cached\r\n            if cached is True:\r\n                cached = TraitsCache + name\r\n            depends_on = trait.depends_on\r\n            if isinstance(depends_on, SequenceTypes):\r\n                depends_on = ','.join(depends_on)\r\n            else:\r\n                depends_on = ' ' + depends_on\r\n            listeners[name] = ('property', cached, depends_on)\r\n        if trait.type == 'property' and trait.observe is not None:\r\n            observer_state = _create_property_observe_state(observe=trait.observe, property_name=name, cached=trait.cached)\r\n            observers[name] = [observer_state]\r\n    class_dict[BaseTraits] = base_traits\r\n    class_dict[ClassTraits] = class_traits\r\n    class_dict[InstanceTraits] = instance_traits\r\n    class_dict[PrefixTraits] = prefix_traits\r\n    class_dict[ListenerTraits] = listeners\r\n    class_dict[ObserverTraits] = observers\r\n    class_dict[ViewTraits] = view_elements\r\n\r\ndef migrate_property(name, property, property_info, class_dict):\r\n    \"\"\" Migrates an existing property to the class being defined\r\n    (allowing for method overrides).\r\n    \"\"\"\r\n    get = _property_method(class_dict, '_get_' + name)\r\n    set = _property_method(class_dict, '_set_' + name)\r\n    val = _property_method(class_dict, '_validate_' + name)\r\n    if get is not None or set is not None or val is not None:\r\n        (old_get, old_set, old_val) = property_info\r\n        return Property(get or old_get, set or old_set, val or old_val, True, **property.__dict__)\r\n    return property\r\n\r\ndef observe(expression, *, post_init=False, dispatch='same'):\r\n    \"\"\" Marks the wrapped method as being a handler to be called when the\r\n    specified traits change.\r\n\r\n    This decorator can be stacked, e.g.::\r\n\r\n        @observe(\"attr1\")\r\n        @observe(\"attr2\", post_init=True)\r\n        def updated(self, event):\r\n            ...\r\n\r\n    The decorated function must accept one argument which is the event object\r\n    representing the change. See :mod:`traits.observation.events` for details.\r\n\r\n    Parameters\r\n    ----------\r\n    expression : str or list or ObserverExpression\r\n        A description of what traits are being observed.\r\n        If this is a list, each item must be a string or Expression.\r\n        See :py:func:`HasTraits.observe` for details on the\r\n        semantics when passing a string.\r\n    post_init : boolean, optional\r\n        Whether the change handler should be attached after\r\n        the state is set when instantiating an object. Default is false, and\r\n        values provided to the instance constructor will trigger the\r\n        change handler to fire if the value is different from the\r\n        default. Set to true to avoid this change event.\r\n    dispatch : str, optional\r\n        A string indicating how the handler should be run. Default is to run\r\n        it on the same thread where the change occurs.\r\n        Possible values are:\r\n\r\n        =========== =======================================================\r\n        value       dispatch\r\n        =========== =======================================================\r\n        ``same``    Run notifications on the same thread where the change\r\n                    occurs. The notifications are executed immediately.\r\n        ``ui``      Run notifications on the UI thread. If the current\r\n                    thread is the UI thread, the notifications are executed\r\n                    immediately; otherwise, they are placed on the UI\r\n                    event queue.\r\n        =========== =======================================================\r\n\r\n    See Also\r\n    --------\r\n    HasTraits.observe\r\n    \"\"\"\r\n    graphs = _compile_expression(expression)\r\n\r\n    def observe_decorator(handler):\r\n        \"\"\" Create input arguments for HasTraits.observe and attach the input\r\n        to the callable.\r\n\r\n        The metaclass will then collect this information for calling\r\n        HasTraits.observe with the decorated function.\r\n\r\n        Parameters\r\n        ----------\r\n        handler : callable\r\n            Method of a subclass of HasTraits, with signature of the form\r\n            ``my_method(self, event)``.\r\n        \"\"\"\r\n        handler_signature = inspect.signature(handler)\r\n        try:\r\n            handler_signature.bind('self', 'event')\r\n        except TypeError:\r\n            warnings.warn(\"Dubious signature for observe-decorated method. The decorated method should be callable with a single positional argument in addition to 'self'. Did you forget to add an 'event' parameter?\", UserWarning, stacklevel=2)\r\n        try:\r\n            observe_inputs = handler._observe_inputs\r\n        except AttributeError:\r\n            observe_inputs = []\r\n            handler._observe_inputs = observe_inputs\r\n        observe_input = dict(graphs=graphs, dispatch=dispatch, post_init=post_init, handler_getter=getattr)\r\n        observe_inputs.append(observe_input)\r\n        return handler\r\n    return observe_decorator\r\n\r\ndef on_trait_change(name, post_init=False, dispatch='same'):\r\n    \"\"\" Marks the following method definition as being a handler for the\r\n        extended trait change specified by *name(s)*.\r\n\r\n        Refer to the documentation for the on_trait_change() method of\r\n        the **HasTraits** class for information on the correct syntax for\r\n        the *name* argument and the semantics of the *dispatch* keyword\r\n        argument.\r\n\r\n        A handler defined using this decorator is normally effective\r\n        immediately. However, if *post_init* is **True**, then the handler only\r\n        becomes effective after all object constructor arguments have been\r\n        processed. That is, trait values assigned as part of object\r\n        construction will not cause the handler to be invoked.\r\n\r\n        See Also\r\n        --------\r\n        observe : A newer API for defining traits notifications.\r\n    \"\"\"\r\n\r\n    def decorator(function):\r\n        function.on_trait_change = {'pattern': name, 'post_init': post_init, 'dispatch': dispatch}\r\n        return function\r\n    return decorator\r\n\r\ndef cached_property(function):\r\n    \"\"\" Marks the following method definition as being a \"cached property\".\r\n        That is, it is a property getter which, for performance reasons, caches\r\n        its most recently computed result in an attribute whose name is of the\r\n        form: *_traits_cache_name*, where *name* is the name of the property. A\r\n        method marked as being a cached property needs only to compute and\r\n        return its result. The @cached_property decorator automatically wraps\r\n        the decorated method in cache management code, eliminating the need to\r\n        write boilerplate cache management code explicitly. For example::\r\n\r\n            file_name = File\r\n            file_contents = Property(observe='file_name')\r\n\r\n            @cached_property\r\n            def _get_file_contents(self):\r\n                with open(self.file_name, 'rb') as fh:\r\n                    return fh.read()\r\n\r\n        In this example, accessing the *file_contents* trait calls the\r\n        _get_file_contents() method only once each time after the **file_name**\r\n        trait is modified. In all other cases, the cached value\r\n        **_file_contents**, which maintained by the @cached_property wrapper\r\n        code, is returned.\r\n\r\n        Note the use, in the example, of the **observe** metadata attribute\r\n        to specify that the value of **file_contents** depends on\r\n        **file_name**, so that _get_file_contents() is called only when\r\n        **file_name** changes. For details, see the traits.traits.Property()\r\n        function.\r\n    \"\"\"\r\n    name = TraitsCache + function.__name__[5:]\r\n\r\n    def decorator(self):\r\n        result = self.__dict__.get(name, Undefined)\r\n        if result is Undefined:\r\n            self.__dict__[name] = result = function(self)\r\n        return result\r\n    decorator.cached_property = True\r\n    return decorator\r\n\r\ndef property_depends_on(dependency, settable=False, flushable=False):\r\n    \"\"\" Marks the following method definition as being a \"cached property\"\r\n        that depends on the specified extended trait names. That is, it is a\r\n        property getter which, for performance reasons, caches its most\r\n        recently computed result in an attribute whose name is of the form:\r\n        *_traits_cache_name*, where *name* is the name of the property. A\r\n        method marked as being a cached property needs only to compute and\r\n        return its result. The @property_depends_on decorator automatically\r\n        wraps the decorated method in cache management code that will cache the\r\n        most recently computed value and flush the cache when any of the\r\n        specified dependencies are modified, thus eliminating the need to write\r\n        boilerplate cache management code explicitly. For example::\r\n\r\n            file_name = File\r\n            file_contents = Property\r\n\r\n            @property_depends_on('file_name')\r\n            def _get_file_contents(self):\r\n                with open(self.file_name, 'rb') as fh:\r\n                    return fh.read()\r\n\r\n        In this example, accessing the *file_contents* trait calls the\r\n        _get_file_contents() method only once each time after the **file_name**\r\n        trait is modified. In all other cases, the cached value\r\n        **_file_contents**, which is maintained by the @cached_property wrapper\r\n        code, is returned.\r\n    \"\"\"\r\n\r\n    def decorator(function):\r\n        name = TraitsCache + function.__name__[5:]\r\n\r\n        def wrapper(self):\r\n            result = self.__dict__.get(name, Undefined)\r\n            if result is Undefined:\r\n                self.__dict__[name] = result = function(self)\r\n            return result\r\n        wrapper.cached_property = True\r\n        wrapper.depends_on = dependency\r\n        wrapper.settable = settable\r\n        wrapper.flushable = flushable\r\n        return wrapper\r\n    return decorator\r\n\r\ndef weak_arg(arg):\r\n    \"\"\" Create a weak reference to arg and wrap the function so that the\r\n    dereferenced weakref is passed as the first argument. If arg has been\r\n    deleted then the function is not called.\r\n    \"\"\"\r\n    weak_arg = weakref.ref(arg)\r\n\r\n    def decorator(function):\r\n\r\n        def wrapper0():\r\n            arg = weak_arg()\r\n            if arg is not None:\r\n                return function(arg)\r\n\r\n        def wrapper1(arg1):\r\n            arg = weak_arg()\r\n            if arg is not None:"]
[21.285542, "o", "\r\n                return function(arg, arg1)\r\n\r\n        def wrapper2(arg1, arg2):\r\n            arg = weak_arg()\r\n            if arg is not None:\r\n                return function(arg, arg1, arg2)\r\n\r\n        def wrapper3(arg1, arg2, arg3):\r\n            arg = weak_arg()\r\n            if arg is not None:\r\n                return function(arg, arg1, arg2, arg3)\r\n\r\n        def wrapper4(arg1, arg2, arg3, arg4):\r\n            arg = weak_arg()\r\n            if arg is not None:\r\n                return function(arg, arg1, arg2, arg3, arg4)\r\n\r\n        def wrappern(*args):\r\n            arg = weak_arg()\r\n            if arg is not None:\r\n                function(arg, *args)\r\n        args = function.__code__.co_argcount - 1\r\n        if args == 0:\r\n            return wrapper0\r\n        elif args == 1:\r\n            return wrapper1\r\n        elif args == 2:\r\n            return wrapper2\r\n        elif args == 3:\r\n            return wrapper3\r\n        elif args == 4:\r\n            return wrapper4\r\n        else:\r\n            return wrappern\r\n    return decorator\r\n\r\nclass HasTraits(CHasTraits, metaclass=MetaHasTraits):\r\n    \"\"\" Enables any Python class derived from it to have trait attributes.\r\n\r\n    Most of the methods of HasTraits operated by default only on the trait\r\n    attributes explicitly defined in the class definition. They do not operate\r\n    on trait attributes defined by way of wildcards or by calling\r\n    **add_trait()**.\r\n    For example::\r\n\r\n        >>> class Person(HasTraits):\r\n        ...     name = Str\r\n        ...     age  = Int\r\n        ...     temp_ = Any\r\n        >>> bob = Person()\r\n        >>> bob.temp_lunch = 'sandwich'\r\n        >>> bob.add_trait('favorite_sport', Str('football'))\r\n        >>> print(bob.trait_names())\r\n        ['trait_added', 'age', 'name']\r\n\r\n    In this example, the trait_names() method returns only the *age* and\r\n    *name* attributes defined on the Person class. (The **trait_added**\r\n    attribute is an explicit trait event defined on the HasTraits class.)\r\n    The wildcard attribute *temp_lunch* and the dynamically-added trait\r\n    attribute *favorite_sport* are not listed.\r\n\r\n    Subclass should avoid defining new traits and/or methods with names\r\n    starting with \"trait\" or \"_trait\" to avoid overshadowing existing methods,\r\n    unless it has been documented as being safe to do so.\r\n    \"\"\"\r\n    _traits_cache__ = Any(private=True, transient=True)\r\n    wrappers = {'same': TraitChangeNotifyWrapper, 'extended': ExtendedTraitChangeNotifyWrapper, 'new': NewTraitChangeNotifyWrapper, 'fast_ui': FastUITraitChangeNotifyWrapper, 'ui': FastUITraitChangeNotifyWrapper}\r\n    trait_added = Event(Str())\r\n    trait_modified = Event()\r\n\r\n    def _trait_added_changed(self, name):\r\n        \"\"\" Handles a 'trait_added' event being fired.\r\n        \"\"\"\r\n        trait = self.trait(name)\r\n        if trait.type == 'delegate' and name[-6:] != '_items':\r\n            self._init_trait_delegate_listener(name, 'delegate', get_delegate_pattern(name, trait))\r\n\r\n    @classmethod\r\n    def add_class_trait(cls, name, *trait):\r\n        \"\"\" Adds a named trait attribute to this class.\r\n\r\n        Also adds the same attribute to all subclasses.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the attribute to add.\r\n        *trait :\r\n            A trait or a value that can be converted to a trait using Trait()\r\n            Trait definition of the attribute. It can be a single value or\r\n            a list equivalent to an argument list for the Trait() function.\r\n\r\n        \"\"\"\r\n        if len(trait) == 0:\r\n            raise ValueError('No trait definition was specified.')\r\n        if len(trait) > 1:\r\n            trait = Trait(*trait)\r\n        else:\r\n            trait = trait_for(trait[0])\r\n        cls._add_class_trait(name, trait, is_subclass=False)\r\n        for subclass in cls.trait_subclasses(True):\r\n            subclass._add_class_trait(name, trait, is_subclass=True)\r\n\r\n    @classmethod\r\n    def _add_class_trait(cls, name, trait, is_subclass):\r\n        \"\"\"\r\n        Add a named trait attribute to this class.\r\n\r\n  "]
[21.285902, "o", "      Does not affect subclasses.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the attribute to add.\r\n        trait : CTrait\r\n            The trait to be added.\r\n        is_subclass : bool\r\n            True if we're adding the trait to a strict subclass of the\r\n            original class that add_class_trait was called for. This is used\r\n            to decide how to behave if ``cls`` already has a trait named\r\n            ``name``: in that circumstance, if ``is_subclass`` is False, an\r\n            error will be raised, while if ``is_subclass`` is True, no trait\r\n            will be added.\r\n\r\n        Raises\r\n        ------\r\n        TraitError\r\n            If a trait with the given name already exists, and is_subclass\r\n            is ``False``.\r\n        \"\"\"\r\n        class_dict = cls.__dict__\r\n        prefix_traits = class_dict[PrefixTraits]\r\n        if name[-1:] == '_':\r\n            name = name[:-1]\r\n            if name in prefix_traits:\r\n                if is_subclass:\r\n                    return\r\n                raise TraitError(\"The '%s_' trait is already defined.\" % name)\r\n            prefix_traits[name] = trait\r\n            prefix_list = prefix_traits['*']\r\n            prefix_list.append(name)\r\n            prefix_list.sort(key=len, reverse=True)\r\n            return\r\n        class_traits = class_dict[ClassTraits]\r\n        if class_traits.get(name) is not None:\r\n            if is_subclass:\r\n                return\r\n            raise TraitError(\"The '%s' trait is already defined.\" % name)\r\n        handler = trait.handler\r\n        if handler is not None:\r\n            if handler.has_items:\r\n                cls._add_class_trait(name + '_items', handler.items_event(), is_subclass=is_subclass)\r\n            if handler.is_mapped:\r\n                cls._add_class_trait(name + '_', mapped_trait_for(trait, name), is_subclass=is_subclass)\r\n        if trait.is_base is not False:\r\n            class_dict[BaseTraits][name] = trait\r\n        handlers = [_get_method(cls, '_%s_changed' % name), _get_method(cls, '_%s_fired' % name)]\r\n        _add_event_handlers(trait, cls, handlers)\r\n        handlers.append(prefix_traits.get('@'))\r\n        handlers = [h for h in handlers if h is not None]\r\n        if len(handlers) > 0:\r\n            trait = _clone_trait(trait)\r\n            _add_notifiers(trait._notifiers(True), handlers)\r\n        class_traits[name] = trait\r\n\r\n    @classmethod\r\n    def set_trait_dispatch_handler(cls, name, klass, override=False):\r\n        \"\"\" Sets a trait notification dispatch handler.\r\n        \"\"\"\r\n        try:\r\n            if issubclass(klass, TraitChangeNotifyWrapper):\r\n                if not override and name in cls.wrappers:\r\n                    raise TraitError(\"A dispatch handler called '%s' has already been defined.\" % name)\r\n                cls.wrappers[name] = klass\r\n                return\r\n        except TypeError:\r\n            pass\r\n        raise TraitError('%s is not a subclass of TraitChangeNotifyWrapper.' % klass)\r\n\r\n    @classmethod\r\n    def trait_subclasses(cls, all=False):\r\n        \"\"\" Returns a list of the immediate (or all) subclasses of this class.\r\n\r\n        Parameters\r\n        ----------\r\n        all : bool\r\n            Indicates whether to return all subclasses of this class. If\r\n            False, only immediate subclasses are returned.\r\n\r\n        \"\"\"\r\n        if not all:\r\n            return cls.__subclasses__()\r\n        return cls._trait_subclasses([])\r\n\r\n    @classmethod\r\n    def _trait_subclasses(cls, subclasses):\r\n        for subclass in cls.__subclasses__():\r\n            if subclass not in subclasses:\r\n                subclasses.append(subclass)\r\n                subclass._trait_subclasses(subclasses)\r\n        return subclasses\r\n\r\n    def has_traits_interface(self, *interfaces):\r\n        \"\"\"Returns whether the object implements a specified traits interface.\r\n\r\n        Tests whether the object implements one or more of the interfaces\r\n        specified by *interfaces*. Return **True** if it does, and **False**\r\n        otherwise.\r\n\r\n        Parameters\r\n        -"]
[21.285946, "o", "---------\r\n        *interfaces :\r\n            One or more traits Interface (sub)classes.\r\n        \"\"\"\r\n        return isinstance(self, interfaces)\r\n\r\n    def __getstate__(self):\r\n        \"\"\" Returns a dictionary of traits to pickle.\r\n\r\n        In general, avoid overriding __getstate__ in subclasses. Instead, mark\r\n        traits that should not be pickled with 'transient = True' metadata.\r\n\r\n        In cases where this strategy is not sufficient, override __getstate__\r\n        in subclasses using the following pattern to remove items that should\r\n        not be persisted::\r\n\r\n            def __getstate__(self):\r\n                state = super().__getstate__()\r\n                for key in ['foo', 'bar']:\r\n                    if key in state:\r\n                        del state[key]\r\n                return state\r\n        \"\"\"\r\n        result = self.trait_get(transient=is_none)\r\n        dic = self.__dict__\r\n        result.update(dict([(name, dic[name]) for name in self.trait_names(type='delegate', transient=False) if name in dic]))\r\n        if self.has_traits_interface(ISerializable):\r\n            for (name, value) in result.items():\r\n                if not _is_serializable(value):\r\n                    raise TraitError(\"The '%s' trait of a '%s' instance contains the unserializable value: %s\" % (name, self.__class__.__name__, value))\r\n        result.setdefault('__traits_version__', TraitsVersion)\r\n        return result\r\n\r\n    def __reduce_ex__(self, protocol):\r\n        return (__newobj__, (self.__class__,), self.__getstate__())\r\n\r\n    def __setstate__(self, state, trait_change_notify=True):\r\n        \"\"\" Restores the previously pickled state of an object.\r\n        \"\"\"\r\n        pop = state.pop\r\n        if pop('__traits_version__', None) is None:\r\n            values = [(name, pop(name)) for name in pop('__HasTraits_restore__', [])]\r\n            self.__dict__.update(state)\r\n            self.trait_set(trait_change_notify=trait_change_notify, **dict(values))\r\n        else:\r\n            self._init_trait_listeners()\r\n            self._init_trait_observers()\r\n            self.trait_set(trait_change_notify=trait_change_notify, **state)\r\n            self._post_init_trait_listeners()\r\n            self._post_init_trait_observers()\r\n            self.traits_init()\r\n        self._trait_set_inited()\r\n\r\n    def trait_get(self, *names, **metadata):\r\n        \"\"\" Retrieve trait values for one or more traits.\r\n\r\n        This function can be called in one of three ways. In the first form,\r\n        the user passes the names of one or more traits to be retrieved::\r\n\r\n            my_object.trait_get(\"trait_name1\", \"trait_name2\")\r\n\r\n        In the second form, the user passes a list of zero or more names of\r\n        traits::\r\n\r\n            my_object.trait_get([\"trait_name1\", \"trait_name2\"])\r\n\r\n        In the final form, no trait names are passed, and all trait names\r\n        and trait values are returned, subject to the given metadata filters::\r\n\r\n            my_object.trait_get(transient=True, frombicated=False)\r\n\r\n        In all cases, a dictionary mapping trait names to trait values is\r\n        returned.\r\n\r\n        For the first two forms, if any name does not correspond to a defined\r\n        trait, it is not included in the result.\r\n\r\n        Parameters\r\n        ----------\r\n        *names\r\n            Names of the traits to look up, or a single positional argument\r\n            providing a sequence of trait names.\r\n        **metadata\r\n            Metadata information used to filter the traits to return. This\r\n            information is used only when no names are provided.\r\n\r\n        Returns\r\n        -------\r\n        result : dict\r\n            A dictionary mapping the selected trait names to their\r\n            corresponding values.\r\n        \"\"\"\r\n        result = {}\r\n        n = len(names)\r\n        if n == 1 and type(names[0]) in SequenceTypes:\r\n            names = names[0]\r\n        elif n == 0:\r\n            names = self.trait_names(**metadata)\r\n        missing = object()\r\n        for name in names:\r\n            value = getattr(self, name, missing)\r\n  "]
[21.285985, "o", "          if value is not missing:\r\n                result[name] = value\r\n        return result\r\n\r\n    def trait_set(self, trait_change_notify=True, **traits):\r\n        \"\"\" Shortcut for setting object trait attributes.\r\n\r\n        Treats each keyword argument to the method as the name of a trait\r\n        attribute and sets the corresponding trait attribute to the value\r\n        specified. This is a useful shorthand when a number of trait attributes\r\n        need to be set on an object, or a trait attribute value needs to be set\r\n        in a lambda function. For example, you can write::\r\n\r\n            person.trait_set(name='Bill', age=27)\r\n\r\n        instead of::\r\n\r\n            person.name = 'Bill'\r\n            person.age = 27\r\n\r\n        Parameters\r\n        ----------\r\n        trait_change_notify : bool\r\n            If **True** (the default), then each value assigned may generate a\r\n            trait change notification. If **False**, then no trait change\r\n            notifications will be generated. (see also: trait_setq)\r\n        **traits :\r\n            Key/value pairs, the trait attributes and their values to be\r\n            set\r\n\r\n        Returns\r\n        -------\r\n        self :\r\n            The method returns this object, after setting attributes.\r\n        \"\"\"\r\n        if not trait_change_notify:\r\n            self._trait_change_notify(False)\r\n            try:\r\n                for (name, value) in traits.items():\r\n                    setattr(self, name, value)\r\n            finally:\r\n                self._trait_change_notify(True)\r\n        else:\r\n            for (name, value) in traits.items():\r\n                setattr(self, name, value)\r\n        return self\r\n\r\n    def trait_setq(self, **traits):\r\n        \"\"\" Shortcut for setting object trait attributes.\r\n\r\n        Treats each keyword argument to the method as the name of a trait\r\n        attribute and sets the corresponding trait attribute to the value\r\n        specified. This is a useful shorthand when a number of trait attributes\r\n        need to be set on an object, or a trait attribute value needs to be set\r\n        in a lambda function. For example, you can write::\r\n\r\n            person.trait_setq(name='Bill', age=27)\r\n\r\n        instead of::\r\n\r\n            person.name = 'Bill'\r\n            person.age = 27\r\n\r\n        Parameters\r\n        ----------\r\n        **traits :\r\n            Key/value pairs, the trait attributes and their values to be set.\r\n            No trait change notifications will be generated for any values\r\n            assigned (see also: trait_set).\r\n\r\n        Returns\r\n        -------\r\n        self :\r\n            The method returns this object, after setting attributes.\r\n        \"\"\"\r\n        return self.trait_set(trait_change_notify=False, **traits)\r\n\r\n    def reset_traits(self, traits=None, **metadata):\r\n        \"\"\" Resets some or all of an object's trait attributes to their default\r\n        values.\r\n\r\n        Resets each of the traits whose names are specified in the *traits*\r\n        list to their default values. If *traits* is None or omitted, the\r\n        method resets all explicitly-defined object trait attributes to their\r\n        default values. Note that this does not affect wildcard trait\r\n        attributes or trait attributes added via add_trait(), unless they are\r\n        explicitly named in *traits*.\r\n\r\n        Parameters\r\n        ----------\r\n        traits : list of strings\r\n            Names of trait attributes to reset.\r\n\r\n        Returns\r\n        -------\r\n        unresetable : list of strings\r\n            A list of attributes that the method was unable to reset, which is\r\n            empty if all the attributes were successfully reset.\r\n        \"\"\"\r\n        unresetable = []\r\n        if traits is None:\r\n            traits = self.trait_names(**metadata)\r\n        for name in traits:\r\n            try:\r\n                delattr(self, name)\r\n            except (AttributeError, TraitError):\r\n                unresetable.append(name)\r\n        return unresetable\r\n\r\n    def copyable_trait_names(self, **metadata):\r\n        \"\"\" Returns the list o"]
[21.286651, "o", "f trait names to copy or clone by default.\r\n        \"\"\"\r\n        metadata.setdefault('transient', lambda t: t is not True)\r\n        return self.trait_names(**metadata)\r\n\r\n    def __dir__(self):\r\n        \"\"\" Returns the list of trait names when calling the dir() builtin on\r\n            the object. This enables tab-completion in IPython.\r\n        \"\"\"\r\n        return super().__dir__() + self.trait_names()\r\n\r\n    def clone_traits(self, traits=None, memo=None, copy=None, **metadata):\r\n        \"\"\"\r\n        TODO: Implement this function\r\n        \"\"\"\r\n        ...\r\n\r\n    def edit_traits(self, view=None, parent=None, kind=None, context=None, handler=None, id='', scrollable=None, **args):\r\n        \"\"\" Displays a user interface window for editing trait attribute\r\n        values.\r\n\r\n        Parameters\r\n        ----------\r\n        view : View or string\r\n            A View object (or its name) that defines a user interface for\r\n            editing trait attribute values of the current object. If the view\r\n            is defined as an attribute on this class, use the name of the\r\n            attribute. Otherwise, use a reference to the view object. If this\r\n            attribute is not specified, the View object returned by\r\n            trait_view() is used.\r\n        parent : toolkit control\r\n            The reference to a user interface component to use as the parent\r\n            window for the object's UI window.\r\n        kind : str\r\n            The type of user interface window to create. See the\r\n            **traitsui.view.kind_trait** trait for values and\r\n            their meanings. If *kind* is unspecified or None, the **kind**\r\n            attribute of the View object is used.\r\n        context : object or dictionary\r\n            A single object or a dictionary of string/object pairs, whose trait\r\n            attributes are to be edited. If not specified, the current object\r\n            is used.\r\n        handler : Handler\r\n            A handler object used for event handling in the dialog box. If\r\n            None, the default handler for Traits UI is used.\r\n        id : str\r\n            A unique ID for persisting preferences about this user interface,\r\n            such as size and position. If not specified, no user preferences\r\n            are saved.\r\n        scrollable : bool\r\n            Indicates whether the dialog box should be scrollable. When set to\r\n            True, scroll bars appear on the dialog box if it is not large\r\n            enough to display all of the items in the view at one time.\r\n\r\n        Returns\r\n        -------\r\n        A UI object.\r\n        \"\"\"\r\n        if context is None:\r\n            context = self\r\n        view = self.trait_view(view)\r\n        return view.ui(context, parent, kind, self.trait_view_elements(), handler, id, scrollable, args)\r\n\r\n    def trait_context(self):\r\n        \"\"\" Returns the default context to use for editing or configuring\r\n            traits.\r\n        \"\"\"\r\n        return {'object': self}\r\n\r\n    def trait_view(self, name=None, view_element=None):\r\n        \"\"\" Gets or sets a ViewElement associated with an object's class.\r\n\r\n        If both *name* and *view_element* are specified, the view element is\r\n        associated with *name* for the current object's class. (That is,\r\n        *view_element* is added to the ViewElements object associated with\r\n        the current object's class, indexed by *name*.)\r\n\r\n        If only *name* is specified, the function returns the view element\r\n        object associated with *name*, or None if *name* has no associated\r\n        view element. View elements retrieved by this function are those that\r\n        are bound to a class attribute in the class definition, or that are\r\n        associated with a name by a previous call to this method.\r\n\r\n        If neither *name* nor *view_element* is specified, the method returns a\r\n        View object, based on the following order of preference:\r\n\r\n        1. If there is a View object named ``traits_view`` associated with the\r\n           current object, it is returned.\r\n        2. If there is exactly one View object associated the current\r\n           object, it is returned.\r\n        3. Otherwise, it returns a View object containing items for all the\r\n           non-event trait attributes on the current object.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of a view element\r\n        view_element : ViewElement\r\n            View element to associate\r\n\r\n        Returns\r\n        -------\r\n        A view element.\r\n        \"\"\"\r\n        return self.__class__._trait_view(name, view_element, self.default_traits_view, self.trait_view_elements, self.visible_traits, self)\r\n\r\n    @classmethod\r\n    def class_trait_view(cls, name=None, view_element=None):\r\n        return cls._trait_view(name, view_element, cls.class_default_traits_view, cls.class_trait_view_elements, cls.class_visible_traits, None)\r\n\r\n    @classmethod\r\n    def _trait_view(cls, name, view_element, default_name, view_elements, trait_selector_f, handler):\r\n        \"\"\" Gets or sets a ViewElement associated with an object's class.\r\n        \"\"\"\r\n        if isinstance(name, AbstractViewElement):\r\n            return name\r\n        view_elements = view_elements()\r\n        if view_elements is None:\r\n            return None\r\n        if name:\r\n            if view_element is None:\r\n                result = view_elements.find(name)\r\n                if result is None and handler is not None:\r\n                    method = getattr(handler, name, None)\r\n                    if callable(method):\r\n                        result = method()\r\n                return result\r\n            view_elements.content[name] = view_element\r\n            return None\r\n        name = default_name()\r\n        if isinstance(name, AbstractViewElement):\r\n            return name\r\n        names = view_elements.filter_by()\r\n        if name in names:\r\n            return view_elements.find(name)\r\n        if handler is not None:\r\n            method = getattr(handler, name, None)\r\n            if callable(method):\r\n                result = method()\r\n                if isinstance(result, AbstractViewElement):\r\n                    return result\r\n        if len(names) == 1:\r\n            return view_elements.find(names[0])\r\n        from traitsui.api import View\r\n        return View(trait_selector_f(), buttons=['OK', 'Cancel'])\r\n\r\n    def default_traits_view(self):\r\n        \"\"\" Returns the name of the default traits view for the object's class.\r\n        \"\"\"\r\n        return self.__class__.class_default_traits_view()\r\n\r\n    @classmethod\r\n    def class_default_traits_view(cls):\r\n        \"\"\" Returns the name of the default traits view for the class.\r\n        \"\"\"\r\n        return DefaultTraitsView\r\n\r\n    def trait_views(self, klass=None):\r\n        \"\"\" Returns a list of the names of all view elements associated with\r\n        the current object's class.\r\n\r\n        If *klass* is specified, the list of names is filtered such that only\r\n        objects that are instances of the specified class are returned.\r\n\r\n        Parameters\r\n        ----------\r\n        klass : class\r\n            A class, such that all returned names must correspond to instances\r\n            of this class. Possible values include:\r\n\r\n            * Group\r\n            * Item\r\n            * View\r\n            * ViewElement\r\n            * ViewSubElement\r\n        \"\"\"\r\n        view_elements = self.__class__.__dict__[ViewTraits]\r\n        if isinstance(view_elements, dict):\r\n            view_elements = self._init_trait_view_elements()\r\n        return view_elements.filter_by(klass)\r\n\r\n    def trait_view_elements(self):\r\n        \"\"\" Returns the ViewElements object associated with the object's\r\n        class.\r\n\r\n        The returned object can be used to access all the view elements\r\n        associated with the class.\r\n        \"\"\"\r\n        return self.__class__.class_trait_view_elements()\r\n\r\n    @classmethod\r\n    def class_trait_view_elements(cls):\r\n        \"\"\" Returns the ViewElements object associated with the class.\r\n\r\n        The returned object can be used to access all the view elements\r\n        associated with the class.\r\n        \"\"\"\r\n        view_elements = cls.__dict__[ViewTraits]\r\n        if isinstance(view_elements, dict):\r\n            view_elements = cls._init_trait_view_elements()\r\n        return view_elements\r\n\r\n    @classmethod\r\n    def _init_trait_view_elements(cls):\r\n        \"\"\" Lazily Initialize the ViewElements object from a dictionary. \"\"\"\r\n        from traitsui.view_elements import ViewElements\r\n        hastraits_bases = [base for base in cls.__bases__ if ClassTraits in base.__dict__]\r\n        view_elements = ViewElements()\r\n        elements_dict = cls.__dict__[ViewTraits]\r\n        for (name, element) in elements_dict.items():\r\n            if name in view_elements.content:\r\n                raise TraitError(\"Duplicate definition for view element '%s'\" % name)\r\n            view_elements.content[name] = element\r\n            element.replace_include(view_elements)\r\n        for base in hastraits_bases:\r\n            parent_view_elements = base.class_trait_view_elements()\r\n            if parent_view_elements is not None:\r\n                view_elements.parents.append(parent_view_elements)\r\n        setattr(cls, ViewTraits, view_elements)\r\n        return view_elements\r\n\r\n    def configure_traits(self, filename=None, view=None, kind=None, edit=None, context=None, handler=None, id='', scrollable=None, **args):\r\n        \"\"\"Creates and displays a dialog box for editing values of trait\r\n        attributes, as if it were a complete, self-contained GUI application.\r\n\r\n        This method is intended for use in applications that do not normally\r\n        have a GUI. Control does not resume in the calling application until\r\n        the user closes the dialog box.\r\n\r\n        The method attempts to open and unpickle the contents of *filename*\r\n        before displaying the dialog box. When editing is complete, the method\r\n        attempts to pickle the updated contents of the object back to\r\n        *filename*. If the file referenced by *filename* does not exist, the\r\n        object is not modified before displaying the dialog box. If *filename*\r\n        is unspecified or None, no pickling or unpickling occurs.\r\n\r\n        If *edit* is True (the default), a dialog box for editing the\r\n        current object is displayed. If *edit* is False or None, no\r\n        dialog box is displayed. You can use ``edit=False`` if you want the\r\n        object to be restored from the contents of *filename*, without being\r\n        modified by the user.\r\n\r\n        Parameters\r\n        ----------\r\n        filename : str\r\n            The name (including path) of a file that contains a pickled\r\n            representation of the current object. When this parameter is\r\n            specified, the method reads the corresponding file (if it exists)\r\n            to restore the saved values of the object's traits before\r\n            displaying them. If the user confirms the dialog box (by clicking\r\n            **OK**), the new values are written to the file. If this parameter\r\n            is not specified, the values are loaded from the in-memory object,\r\n            and are not persisted when the dialog box is closed.\r\n\r\n            .. deprecated:: 6.0.0\r\n\r\n        view : View or str\r\n            A View object (or its name) that defines a user interface for\r\n            editing trait attribute values of the current object. If the view\r\n            is defined as an attribute on this class, use the name of the\r\n"]
[21.286691, "o", "            attribute. Otherwise, use a reference to the view object. If this\r\n            attribute is not specified, the View object returned by\r\n            trait_view() is used.\r\n        kind : str\r\n            The type of user interface window to create. See the\r\n            **traitsui.view.kind_trait** trait for values and\r\n            their meanings. If *kind* is unspecified or None, the **kind**\r\n            attribute of the View object is used.\r\n        edit : bool\r\n            Indicates whether to display a user interface. If *filename*\r\n            specifies an existing file, setting *edit* to False loads the\r\n            saved values from that file into the object without requiring\r\n            user interaction.\r\n\r\n            .. deprecated:: 6.2.0\r\n\r\n        context : object or dictionary\r\n            A single object or a dictionary of string/object pairs, whose trait\r\n            attributes are to be edited. If not specified, the current object\r\n            is used\r\n        handler : Handler\r\n            A handler object used for event handling in the dialog box. If\r\n            None, the default handler for Traits UI is used.\r\n        id : str\r\n            A unique ID for persisting preferences about this user interface,\r\n            such as size and position. If not specified, no user preferences\r\n            are saved.\r\n        scrollable : bool\r\n            Indicates whether the dialog box should be scrollable. When set to\r\n            True, scroll bars appear on the dialog box if it is not large\r\n            enough to display all of the items in the view at one time.\r\n\r\n        Returns\r\n        -------\r\n        True on success.\r\n        \"\"\"\r\n        if filename is not None:\r\n            message = 'Restoring from pickle will not be supported starting with traits 7.0.0'\r\n            warnings.warn(message, DeprecationWarning)\r\n            if os.path.exists(filename):\r\n                with open(filename, 'rb') as fd:\r\n                    self.copy_traits(pickle.Unpickler(fd).load())\r\n        if edit is None:\r\n            edit = True\r\n        else:\r\n            message = 'The edit argument to configure_traits is deprecated, and will be removed in Traits 7.0.0'\r\n            warnings.warn(message, DeprecationWarning)\r\n        if edit:\r\n            from traitsui.api import toolkit\r\n            if context is None:\r\n                context = self\r\n            rc = toolkit().view_application(context, self.trait_view(view), kind, handler, id, scrollable, args)\r\n            if rc and filename is not None:\r\n                with open(filename, 'wb') as fd:\r\n                    pickle.Pickler(fd, protocol=3).dump(self)\r\n            return rc\r\n        return True\r\n\r\n    def editable_traits(self):\r\n        \"\"\"Returns an alphabetically sorted list of the names of non-event\r\n        trait attributes associated with the current object.\r\n        \"\"\"\r\n        names = self.trait_names(type=not_event, editable=not_false)\r\n        names.sort()\r\n        return names\r\n\r\n    @classmethod\r\n    def class_editable_traits(cls):\r\n        \"\"\"Returns an alphabetically sorted list of the names of non-event\r\n        trait attributes associated with the current class.\r\n        \"\"\"\r\n        names = cls.class_trait_names(type=not_event, editable=not_false)\r\n        names.sort()\r\n        return names\r\n\r\n    def visible_traits(self):\r\n        \"\"\"Returns an alphabetically sorted list of the names of non-event\r\n        trait attributes associated with the current object, that should be GUI\r\n        visible\r\n        \"\"\"\r\n        return self.trait_names(type=not_event, visible=not_false)\r\n\r\n    @classmethod\r\n    def class_visible_traits(cls):\r\n        \"\"\"Returns an alphabetically sorted list of the names of non-event\r\n        trait attributes associated with the current class, that should be GUI\r\n        visible\r\n        \"\"\"\r\n        return cls.class_trait_names(type=not_event, visible=not_false)\r\n\r\n    def print_traits(self, show_help=False, **metadata):\r\n        \"\"\"Prints the values of all explicitly-defined, non-event trait\r\n        attributes "]
[21.286834, "o", "on the current object, in an easily readable format.\r\n\r\n        Parameters\r\n        ----------\r\n        show_help : bool\r\n            Indicates whether to display additional descriptive information.\r\n        \"\"\"\r\n        if len(metadata) > 0:\r\n            names = self.trait_names(**metadata)\r\n        else:\r\n            names = self.trait_names(type=not_event)\r\n        if len(names) == 0:\r\n            print('')\r\n            return\r\n        result = []\r\n        pad = max([len(x) for x in names]) + 1\r\n        maxval = 78 - pad\r\n        names.sort()\r\n        for name in names:\r\n            try:\r\n                value = repr(getattr(self, name)).replace('\\n', '\\\\n')\r\n                if len(value) > maxval:\r\n                    value = '%s...%s' % (value[:(maxval - 2) // 2], value[-((maxval - 3) // 2):])\r\n            except:\r\n                value = '<undefined>'\r\n            lname = (name + ':').ljust(pad)\r\n            if show_help:\r\n                result.append('%s %s\\n   The value must be %s.' % (lname, value, self.base_trait(name).setter.info()))\r\n            else:\r\n                result.append('%s %s' % (lname, value))\r\n        print('\\n'.join(result))\r\n\r\n    def _on_trait_change(self, handler, name=None, remove=False, dispatch='same', priority=False, target=None):\r\n        \"\"\"Causes the object to invoke a handler whenever a trait attribute\r\n        is modified, or removes the association.\r\n\r\n        Multiple handlers can be defined for the same object, or even for the\r\n        same trait attribute on the same object. If *name* is not specified or\r\n        is None, *handler* is invoked when any trait attribute on the\r\n        object is changed.\r\n\r\n        Parameters\r\n        ----------\r\n        handler : function\r\n            A trait notification function for the attribute specified by\r\n            *name*.\r\n        name : str\r\n            Specifies the trait attribute whose value changes trigger the\r\n            notification.\r\n        remove : bool\r\n            If True, removes the previously-set association between\r\n            *handler* and *name*; if False (the default), creates the\r\n            association.\r\n        \"\"\"\r\n        if type(name) is list:\r\n            for name_i in name:\r\n                self._on_trait_change(handler, name_i, remove, dispatch, priority, target)\r\n            return\r\n        name = name or 'anytrait'\r\n        if remove:\r\n            if name == 'anytrait':\r\n                notifiers = self._notifiers(False)\r\n            else:\r\n                trait = self._trait(name, 1)\r\n                if trait is None:\r\n                    return\r\n                notifiers = trait._notifiers(False)\r\n            if notifiers is not None:\r\n                for (i, notifier) in enumerate(notifiers):\r\n                    if notifier.equals(handler):\r\n                        del notifiers[i]\r\n                        notifier.dispose()\r\n                        break\r\n            return\r\n        if name == 'anytrait':\r\n            notifiers = self._notifiers(True)\r\n        else:\r\n            notifiers = self._trait(name, 2)._notifiers(True)\r\n        for notifier in notifiers:\r\n            if notifier.equals(handler):\r\n                break\r\n        else:\r\n            wrapper = self.wrappers[dispatch](handler, notifiers, target)\r\n            if priority:\r\n                notifiers.insert(0, wrapper)\r\n            else:\r\n                notifiers.append(wrapper)\r\n\r\n    def observe(self, handler, expression, *, remove=False, dispatch='same'):\r\n        \"\"\" Causes the object to invoke a handler whenever a trait attribute\r\n        matching a specified pattern is modified, or removes the association.\r\n\r\n        The *expression* parameter can be a single string or an Expression\r\n        object. A list of expressions is also accepted.\r\n\r\n        When *expression* is a string, its content should follow Traits Mini\r\n        Language semantics:\r\n\r\n        ============================== ======================================\r\n        Expression                       Meaning\r\n        ============================== =========="]
[21.287252, "o", "============================\r\n        ``item1.item2``                Observes trait *item2* on the object\r\n                                       under trait *item1*.\r\n                                       Changes to either *item1* or *item2*\r\n                                       cause a notification to be fired.\r\n        ``item1:item2``                Similar to the above, except changes\r\n                                       to *item1* will not fire events\r\n                                       (the ':' indicates no notifications).\r\n        ``[item1, item2, ..., itemN]`` A list which matches any of the\r\n                                       specified items. Each item can itself\r\n                                       be an expression.\r\n        ``items``                      Special keyword for observing a trait\r\n                                       named *items* or items inside a list /\r\n                                       dict / set.\r\n        ``+metadata_name``             Matches any trait on the object having\r\n                                       *metadata_name* metadata.\r\n        ============================== ======================================\r\n\r\n        All spaces will be ignored.\r\n\r\n        The :py:class:`ObserverExpression` object supports\r\n        the above features and more.\r\n\r\n        Parameters\r\n        ----------\r\n        handler : callable(event)\r\n            A callable that will be invoked when the observed trait changes.\r\n            It must accept one argument, which is an event object providing\r\n            information about the change.\r\n            See :py:mod:`traits.observation.events` for details.\r\n        expression : str or list or ObserverExpression\r\n            A description of what traits are being observed.\r\n            If this is a list, each item must be a string or an Expression.\r\n        remove : boolean, optional\r\n            Whether to remove the event handler. Default is to add the event\r\n            handler.\r\n        dispatch : str, optional\r\n            A string indicating how the handler should be run.\r\n            Default is to run on the same thread where the change occurs.\r\n\r\n            Possible values are:\r\n\r\n            =========== =======================================================\r\n            value       dispatch\r\n            =========== =======================================================\r\n            ``same``    Run notifications on the same thread where the change\r\n                        occurs. The notifications are executed immediately.\r\n            ``ui``      Run notifications on the UI thread. If the current\r\n                        thread is the UI thread, the notifications are executed\r\n                        immediately; otherwise, they are placed on the UI\r\n                        event queue.\r\n            =========== =======================================================\r\n\r\n        Raises\r\n        ------\r\n        NotifierNotFound\r\n            When attempting to remove a handler that doesn't exist.\r\n        \"\"\"\r\n        graphs = _compile_expression(expression)\r\n        observe_api.apply_observers(object=self, graphs=graphs, handler=handler, dispatcher=_ObserverDispatchers[dispatch], remove=remove)\r\n\r\n    def on_trait_change(self, handler, name=None, remove=False, dispatch='same', priority=False, deferred=False, target=None):\r\n        \"\"\"Causes the object to invoke a handler whenever a trait attribute\r\n        matching a specified pattern is modified, or removes the association.\r\n\r\n        Multiple handlers can be defined for the same object, or even for the\r\n        same trait attribute on the same object. If *name* is not specified or\r\n        is None, *handler* is invoked when any trait attribute on the\r\n        object is changed.\r\n\r\n        The *name* parameter is a single *xname* or a list of *xname* names,\r\n        where an *xname* is an extended name of the form::\r\n\r\n            xname2[('.'|':') xname2]*\r\n\r\n        An *xname2* is of the form::\r\n\r\n            (xname3 | '['xname3[','xname3]*']') ['*']\r\n\r\n        An *xname3* is of"]
[21.287296, "o", " the form::\r\n\r\n            xname | ['+'|'-'][name] | name['?' | ('+'|'-')[name]]\r\n\r\n        A *name* is any valid Python attribute name. The semantic meaning of\r\n        this notation is as follows:\r\n\r\n        ================================ ======================================\r\n        expression                       meaning\r\n        ================================ ======================================\r\n        ``item1.item2``                  means *item1* is a trait containing an\r\n                                         object (or objects if *item1* is a\r\n                                         list or dict) with a trait called\r\n                                         *item2*. Changes to either *item1* or\r\n                                         *item2* cause a notification to be\r\n                                         generated.\r\n        ``item1:item2``                  means *item1* is a trait containing an\r\n                                         object (or objects if *item1* is a\r\n                                         list or dict) with a trait called\r\n                                         *item2*. Changes to *item2* cause a\r\n                                         notification to be generated, while\r\n                                         changes to *item1* do not (i.e., the\r\n                                         ':' indicates that changes to the\r\n                                         *link* object should not be reported).\r\n        ``[item1, item2, ..., itemN]``   A list which matches any of the\r\n                                         specified items. Note that at the\r\n                                         topmost level, the surrounding square\r\n                                         brackets are optional.\r\n        ``name?``                        If the current object does not have an\r\n                                         attribute called *name*, the reference\r\n                                         can be ignored. If the '?' character\r\n                                         is omitted, the current object must\r\n                                         have a trait called *name*, otherwise\r\n                                         an exception will be raised.\r\n        ``prefix+``                      Matches any trait on the object whose\r\n                                         name begins with *prefix*.\r\n        ``+metadata_name``               Matches any trait on the object having\r\n                                         *metadata_name* metadata.\r\n        ``-metadata_name``               Matches any trait on the object which\r\n                                         does not have *metadata_name*\r\n                                         metadata.\r\n        ``prefix+metadata_name``         Matches any trait on the object whose\r\n                                         name begins with *prefix* and which\r\n                                         has *metadata_name* metadata.\r\n        ``prefix-metadata_name``         Matches any trait on the object\r\n                                         whose name begins with *prefix* and\r\n                                         which does not have *metadata_name*\r\n                                         metadata.\r\n        ``+``                            Matches all traits on the object.\r\n        ``pattern*``                     Matches object graphs where *pattern*\r\n                                         occurs one or more times (useful for\r\n                                         setting up listeners on recursive data\r\n                                         structures like trees or linked\r\n                                         lists).\r\n        ================================ ======================================\r\n\r\n        Some examples of valid names and their meaning are as follows:\r\n\r\n        ======================= ===============================================\r\n        example                 meaning\r\n        ======================= ===============================================\r\n        ``foo,bar,baz``         "]
[21.288229, "o", "Listen for trait changes to *object.foo*,\r\n                                *object.bar*, and *object.baz*.\r\n        ``['foo','bar','baz']`` Equivalent to 'foo,bar,baz', but may be more\r\n                                useful in cases where the individual items are\r\n                                computed.\r\n        ``foo.bar.baz``         Listen for trait changes to\r\n                                *object.foo.bar.baz* and report changes to\r\n                                *object.foo*, *object.foo.bar* or\r\n                                *object.foo.bar.baz*.\r\n        ``foo:bar:baz``         Listen for changes to *object.foo.bar.baz*, and\r\n                                only report changes to *object.foo.bar.baz*.\r\n        ``foo.[bar,baz]``       Listen for trait changes to *object.foo.bar*\r\n                                and *object.foo.baz*.\r\n        ``[left,right]*.name``  Listen for trait changes to the *name* trait of\r\n                                each node of a tree having *left* and *right*\r\n                                links to other tree nodes, and where *object*\r\n                                the method is applied to the root node of the\r\n                                tree.\r\n        ``+dirty``              Listen for trait changes on any trait in the\r\n                                *object* which has the 'dirty' metadata set.\r\n        ``foo.+dirty``          Listen for trait changes on any trait in\r\n                                *object.foo* which has the 'dirty' metadata\r\n                                set.\r\n        ``foo.[bar,-dirty]``    Listen for trait changes on *object.foo.bar* or\r\n                                any trait on *object.foo* which does not have\r\n                                'dirty' metadata set.\r\n        ======================= ===============================================\r\n\r\n\r\n        Note that any of the intermediate (i.e., non-final) links in a\r\n        pattern can be traits of type Instance, List or Dict. In the case\r\n        of List and Dict traits, the subsequent portion of the pattern is\r\n        applied to each item in the list, or value in the dictionary.\r\n\r\n        For example, if the self.children is a list, 'children.name'\r\n        listens for trait changes to the *name* trait for each item in the\r\n        self.children list.\r\n\r\n        Note that items added to or removed from a list or dictionary in\r\n        the pattern will cause the *handler* routine to be invoked as well,\r\n        since this is treated as an *implied* change to the item's trait\r\n        being monitored.\r\n\r\n        The signature of the *handler* supplied also has an effect on\r\n        how changes to intermediate traits are processed. The five valid\r\n        handler signatures are:\r\n\r\n        1. handler()\r\n        2. handler(new)\r\n        3. handler(name,new)\r\n        4. handler(object,name,new)\r\n        5. handler(object,name,old,new)\r\n\r\n        For signatures 1, 4 and 5, any change to any element of a path\r\n        being listened to invokes the handler with information about the\r\n        particular element that was modified (e.g., if the item being\r\n        monitored is 'foo.bar.baz', a change to 'bar' will call *handler*\r\n        with the following information:\r\n\r\n        - object: object.foo\r\n        - name:   bar\r\n        - old:    old value for object.foo.bar\r\n        - new:    new value for object.foo.bar\r\n\r\n        If one of the intermediate links is a List or Dict, the call to\r\n        *handler* may report an *_items* changed event. If in the previous\r\n        example, *bar* is a List, and a new item is added to *bar*, then\r\n        the information passed to *handler* would be:\r\n\r\n        - object: object.foo\r\n        - name:   bar_items\r\n        - old:    Undefined\r\n        - new:    TraitListEvent whose *added* trait contains the new item\r\n                  added to *bar*.\r\n\r\n        For signatures 2 and 3, the *handler* does not receive enough\r\n        information to discern between a change to the final trait being\r\n        listened to and a change to an intermediate link. In this case,\r\n        the event dispatcher will attempt to map a change to an\r\n        intermediate link to its effective change on the final trait. This\r\n        only works if all of the intermediate links are single values (such\r\n        as an Instance or Any trait) and not Lists or Dicts. If the modified\r\n        intermediate trait or any subsequent intermediate trait preceding\r\n        the final trait is a List or Dict, then a TraitError is raised,\r\n        since the effective value for the final trait cannot in general be\r\n        resolved unambiguously. To prevent TraitErrors in this case, use the\r\n        ':' separator to suppress notifications for changes to any of the\r\n        intermediate links.\r\n\r\n        Handler signature 1 also has the special characteristic that if a\r\n        final trait is a List or Dict, it will automatically handle '_items'\r\n        changed events for the final trait as well. This can be useful in\r\n        cases where the *handler* only needs to know that some aspect of the\r\n        final trait has been changed. For all other *handler* signatures,\r\n        you must explicitly specify the 'xxx_items' trait if you want to\r\n        be notified of changes to any of the items of the 'xxx' trait.\r\n\r\n        Parameters\r\n        ----------\r\n        handler : function\r\n            A trait notification function for the *name* trait attribute, with\r\n            one of the signatures described below.\r\n        name : str\r\n            The name of the trait attribute whose value changes trigger the\r\n            notification. The *name* can specify complex patterns of trait\r\n            changes using an extended *name* syntax, which is described below.\r\n        remove : bool\r\n            If True, removes the previously-set association between\r\n            *handler* and *name*; if False (the default), creates the\r\n            association.\r\n        dispatch : str\r\n            A string indicating the thread on which notifications must be run.\r\n            Possible values are:\r\n\r\n            =========== =======================================================\r\n            value       dispatch\r\n            =========== =======================================================\r\n            ``same``    Run notifications on the same thread as this one.\r\n            ``ui``      Run notifications on the UI thread. If the current\r\n                        thread is the UI thread, the notifications are executed\r\n                        immediately; otherwise, they are placed on the UI\r\n                        event queue.\r\n            ``fast_ui`` Alias for ``ui``.\r\n            ``new``     Run notifications in a new thread.\r\n            =========== =======================================================\r\n\r\n        See Also\r\n        --------\r\n        HasTraits.observe : A newer API for defining traits notifications.\r\n        \"\"\"\r\n        if isinstance(name, str) and extended_trait_pat.match(name) is None or name is None:\r\n            self._on_trait_change(handler, name, remove, dispatch, priority, target)\r\n            return\r\n        from .traits_listener import TraitsListener, ListenerParser, ListenerHandler, ListenerNotifyWrapper\r\n        if isinstance(name, list):\r\n            for name_i in name:\r\n                self.on_trait_change(handler, name=name_i, remove=remove, dispatch=dispatch, priority=priority, deferred=deferred, target=target)\r\n            return\r\n        name = (name or 'anytrait').strip()\r\n        if remove:\r\n            dict = self.__dict__.get(TraitsListener)\r\n            if dict is not None:\r\n                listeners = dict.get(name)\r\n                if listeners is not None:\r\n                    for (i, wrapper) in enumerate(listeners):\r\n                        if wrapper.equals(handler):\r\n                            del listeners[i]\r\n                            if len(listeners) == 0:\r\n                                del dict[name]\r\n                                if len(dict) == 0:\r\n                                    del self.__dict__[TraitsListener]\r\n                            wrapper.listener.unregister(self)\r\n                            wrapper.dispose()\r\n                            break\r\n        else:\r\n            dict = self.__dict__.setdefault(TraitsListener, {})\r\n            listeners = dict.setdefault(name, [])\r\n            for wrapper in listeners:\r\n                if wrapper.equals(handler):\r\n                    break\r\n            else:\r\n                lnw = ListenerNotifyWrapper(handler, self, name, None, target)\r\n                listener = ListenerParser(name, handler=ListenerHandler(handler), wrapped_handler_ref=weakref.ref(lnw), dispatch=dispatch, priority=priority, deferred=deferred, handler_type=lnw.type).listener\r\n                lnw.listener = listener\r\n                listener.register(self)\r\n                listeners.append(lnw)\r\n    on_trait_event = on_trait_change\r\n\r\n    def sync_trait(self, trait_name, object, alias=None, mutual=True, remove=False):\r\n        \"\"\"Synchronizes the value of a trait attribute on this object with a\r\n        trait attribute on another object.\r\n\r\n        In mutual synchronization, any change to the value of the specified\r\n        trait attribute of either object results in the same value being\r\n        assigned to the corresponding trait attribute of the other object.\r\n        In one-way synchronization, any change to the value of the attribute\r\n        on this object causes the corresponding trait attribute of *object* to\r\n        be updated, but not vice versa.\r\n\r\n        For ``List`` traits, the list's items are also synchronized, so that\r\n        mutations to this trait's list will be reflected in the synchronized\r\n        list (and vice versa in the case of mutual synchronization). For\r\n        ``Dict`` and ``Set`` traits, items are not synchronized.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the trait attribute on this object.\r\n        object : object\r\n            The object with which to synchronize.\r\n        alias : str\r\n            Name of the trait attribute on *other*; if None or omitted, same\r\n            as *name*.\r\n        mutual : bool or int\r\n            Indicates whether synchronization is mutual (True or non-zero)\r\n            or one-way (False or zero)\r\n        remove : bool or int\r\n            Indicates whether synchronization is being added (False or zero)\r\n            or removed (True or non-zero)\r\n        \"\"\"\r\n        if alias is None:\r\n            alias = trait_name\r\n        is_list = self._is_list_trait(trait_name) and object._is_list_trait(alias)\r\n        if remove:\r\n            info = self._get_sync_trait_info()\r\n            dic = info.get(trait_name)\r\n            if dic is not None:\r\n                key = (id(object), alias)\r\n                if key in dic:\r\n                    del dic[key]\r\n                    if len(dic) == 0:\r\n                        del info[trait_name]\r\n                        self._on_trait_change(self._sync_trait_modified, trait_name, remove=True)\r\n                        if is_list:\r\n                            self._on_trait_change(self._sync_trait_items_modified, trait_name + '_items', remove=True)\r\n            if mutual:\r\n                object.sync_trait(alias, self, trait_name, False, True)\r\n            return\r\n\r\n        def _sync_trait_listener_deleted(ref, info):\r\n            for (key, dic) in list(info.items()):\r\n                if key != '':\r\n                    for (name, value) in list(dic.items()):\r\n                        if ref is value[0]:\r\n                            del dic[name]\r\n                    if len(dic) == 0:\r\n                        del info[key]\r\n        info = self._get_sync_trait_info()\r\n        dic = info.setdefault(trait_name, {})\r\n        key = (id(object), alias)\r\n        callback = lambda ref: _sync_trait_listener_deleted(ref, info)\r\n        value = (weakref.ref(object, callback), alias)\r\n        if key not in dic:\r\n            if len(dic) == 0:\r\n                self._on_trait_change(self._sync_trait_modified, trait_name)\r\n                if is_list:\r\n                    self._on_trait_change(self._sync_trait_items_modified, trait_name + '_items')\r\n            dic[key] = value\r\n            setattr(object, alias, getattr(self, trait_name))\r\n        if mutual:\r\n            object.sync_trait(alias, self, trait_name, False)\r\n\r\n    def _get_sync_trait_info(self):\r\n        info = getattr(self, '__sync_trait__', None)\r\n        if info is None:\r\n            self.__dict__['__sync_trait__'] = info = {}\r\n            info[''] = {}\r\n        return info\r\n\r\n    def _sync_trait_modified(self, object, name, old, new):\r\n        info = self.__sync_trait__\r\n        if name not in info:\r\n            return\r\n        locked = info['']\r\n        locked[name] = None\r\n        for (object, object_name) in info[name].values():\r\n            object = object()\r\n            if object_name not in object._get_sync_trait_info()['']:\r\n                try:\r\n                    setattr(object, object_name, new)\r\n                except:\r\n                    pass\r\n        del locked[name]\r\n\r\n    def _sync_trait_items_modified(self, object, name, old, event):\r\n        n0 = event.index\r\n        n1 = n0 + len(event.removed)\r\n        name = name[:-6]\r\n        info = self.__sync_trait__\r\n        locked = info['']\r\n        locked[name] = None\r\n        for (object, object_name) in info[name].values():\r\n            object = object()\r\n            if object_name not in object._get_sync_trait_info()['']:\r\n                try:\r\n                    getattr(object, object_name)[n0:n1] = event.added\r\n                except:\r\n                    pass\r\n        del locked[name]\r\n\r\n    def _is_list_trait(self, trait_name):\r\n        handler = self.base_trait(trait_name).handler\r\n        return handler is not None and handler.default_value_type == DefaultValue.trait_list_object\r\n\r\n    def add_trait(self, name, *trait):\r\n        \"\"\"Adds a trait attribute to this object.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the attribute to add.\r\n        *trait :\r\n            Trait or a value that can be converted to a trait by Trait().\r\n            Trait definition for *name*. If more than one value is specified,\r\n            it is equivalent to passing the entire list of values to Trait().\r\n\r\n        \"\"\"\r\n        if len(trait) == 0:\r\n            raise ValueError('No trait definition was specified.')\r\n        if len(trait) > 1:\r\n            trait = Trait(*trait)\r\n        else:\r\n            trait = trait_for(trait[0])\r\n        handler = trait.handler\r\n        if handler is not None:\r\n            if handler.has_items:\r\n                self.add_trait(name + '_items', handler.items_event())\r\n            if handler.is_mapped:\r\n                self.add_trait(name + '_', mapped_trait_for(trait, name))\r\n        old_trait = self._trait(name, 0)\r\n        itrait_dict = self._instance_traits()\r\n        itrait_dict[name] = trait = _clone_trait(trait)\r\n        if old_trait is not None:\r\n            old_notifiers = old_trait._notifiers(False)\r\n            if old_notifiers is not None:\r\n                trait._notifiers(True).extend(old_notifiers)\r\n        else:\r\n            cls = self.__class__\r\n            handlers = [_get_method(cls, '_%s_changed' % name), _get_method(cls, '_%s_fired' % name)]\r\n            _add_event_handlers(trait, cls, handlers)\r\n            handlers.append(self.__prefix_traits__.get('@'))\r\n            handlers = [h for h in handlers if h is not None]\r\n            if len(handlers) > 0:\r\n                _add_notifiers(trait._notifiers(True), handlers)\r\n        if old_trait is None:\r\n            self.trait_added = name\r\n\r\n    def remove_trait(self, name):\r\n        \"\"\"Removes a trait attribute from this object.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the attribute to remove.\r\n\r\n        Returns\r\n        -------\r\n        result : bool\r\n            True if the trait was successfully removed.\r\n        \"\"\"\r\n        trait = self._trait(name, 0)\r\n        if trait is not None:\r\n            handler = trait.handler\r\n            if handler is not None:\r\n                if handler.has_items:\r\n                    self.remove_trait(name + '_items')\r\n                if handler.is_mapped:\r\n                    self.remove_trait(name + '_')\r\n            if name in self.__dict__:\r\n                del self.__dict__[name]\r\n"]
[21.288271, "o", "            itrait_dict = self._instance_traits()\r\n            if name in itrait_dict:\r\n                del itrait_dict[name]\r\n                return True\r\n        return False\r\n\r\n    def trait(self, name, force=False, copy=False):\r\n        \"\"\"Returns the trait definition for the *name* trait attribute.\r\n\r\n        If *force* is False (the default) and *name* is the name of an\r\n        implicitly defined trait attribute that has never been referenced\r\n        explicitly (i.e., has not yet been defined), the result is None. In\r\n        all other cases, the result is the trait definition object associated\r\n        with *name*.\r\n\r\n        If *copy* is True, and a valid trait definition is found for *name*,\r\n        a copy of the trait found is returned. In all other cases, the trait\r\n        definition found is returned unmodified (the default).\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the attribute whose trait definition is to be returned.\r\n        force : bool\r\n            Indicates whether to return a trait definition if *name* is\r\n            not explicitly defined.\r\n        copy : bool\r\n            Indicates whether to return the original trait definition or a\r\n            copy.\r\n        \"\"\"\r\n        mode = 0\r\n        if force:\r\n            mode = -1\r\n        result = self._trait(name, mode)\r\n        if not copy or result is None:\r\n            return result\r\n        return _clone_trait(result)\r\n\r\n    def validate_trait(self, name, value):\r\n        \"\"\" Validates whether a value is legal for a trait.\r\n\r\n        Returns the validated value if it is valid.\r\n        \"\"\"\r\n        return self.base_trait(name).validate(self, name, value)\r\n\r\n    def traits(self, **metadata):\r\n        \"\"\"Returns a dictionary containing the definitions of all of the trait\r\n        attributes of this object that match the set of *metadata* criteria.\r\n        Note that any traits with a name containing the suffix \"_items\" are\r\n        always excluded.\r\n\r\n        The keys of the returned dictionary are the trait attribute names, and\r\n        the values are their corresponding trait definition objects.\r\n\r\n        If no *metadata* information is specified, then all explicitly defined\r\n        trait attributes defined for the object are returned.\r\n\r\n        Otherwise, the *metadata* keyword dictionary is assumed to define a set\r\n        of search criteria for selecting trait attributes of interest. The\r\n        *metadata* dictionary keys correspond to the names of trait metadata\r\n        attributes to examine, and the values correspond to the values the\r\n        metadata attribute must have in order to be included in the search\r\n        results.\r\n\r\n        The *metadata* values either may be simple Python values like strings\r\n        or integers, or may be lambda expressions or functions that return True\r\n        if the trait attribute is to be included in the result. A lambda\r\n        expression or function must receive a single argument, which is the\r\n        value of the trait metadata attribute being tested. If more than one\r\n        metadata keyword is specified, a trait attribute must match the\r\n        metadata values of all keywords to be included in the result.\r\n\r\n        Parameters\r\n        ----------\r\n        **metadata :\r\n            Criteria for selecting trait attributes.\r\n        \"\"\"\r\n        traits = self.__base_traits__.copy()\r\n        for (name, trt) in self._instance_traits().items():\r\n            if name[-6:] != '_items':\r\n                traits[name] = trt\r\n        for name in self.__dict__.keys():\r\n            if name not in traits:\r\n                trait = self.trait(name)\r\n                if trait is not None:\r\n                    traits[name] = trait\r\n        if len(metadata) == 0:\r\n            return traits\r\n        for (meta_name, meta_eval) in list(metadata.items()):\r\n            if type(meta_eval) is not FunctionType:\r\n                metadata[meta_name] = _SimpleTest(meta_eval)\r\n        result = {}\r\n        for (name, trait) in traits.items():\r\n            for (meta_name, meta_eval"]
[21.289148, "o", ") in metadata.items():\r\n                if not meta_eval(getattr(trait, meta_name, None)):\r\n                    break\r\n            else:\r\n                result[name] = trait\r\n        return result\r\n\r\n    @classmethod\r\n    def class_traits(cls, **metadata):\r\n        \"\"\"Returns a dictionary containing the definitions of all of the trait\r\n        attributes of the class that match the set of *metadata* criteria.\r\n\r\n        The keys of the returned dictionary are the trait attribute names, and\r\n        the values are their corresponding trait definition objects.\r\n\r\n        If no *metadata* information is specified, then all explicitly defined\r\n        trait attributes defined for the class are returned.\r\n\r\n        Otherwise, the *metadata* keyword dictionary is assumed to define a set\r\n        of search criteria for selecting trait attributes of interest. The\r\n        *metadata* dictionary keys correspond to the names of trait metadata\r\n        attributes to examine, and the values correspond to the values the\r\n        metadata attribute must have in order to be included in the search\r\n        results.\r\n\r\n        The *metadata* values either may be simple Python values like strings\r\n        or integers, or may be lambda expressions or functions that return\r\n        **True** if the trait attribute is to be included in the result. A\r\n        lambda expression or function must receive a single argument, which is\r\n        the value of the trait metadata attribute being tested. If more than\r\n        one metadata keyword is specified, a trait attribute must match the\r\n        metadata values of all keywords to be included in the result.\r\n\r\n        Parameters\r\n        ----------\r\n        **metadata :\r\n            Criteria for selecting trait attributes.\r\n        \"\"\"\r\n        if len(metadata) == 0:\r\n            return cls.__base_traits__.copy()\r\n        result = {}\r\n        for (meta_name, meta_eval) in list(metadata.items()):\r\n            if type(meta_eval) is not FunctionType:\r\n                metadata[meta_name] = _SimpleTest(meta_eval)\r\n        for (name, trait) in cls.__base_traits__.items():\r\n            for (meta_name, meta_eval) in metadata.items():\r\n                if not meta_eval(getattr(trait, meta_name, None)):\r\n                    break\r\n            else:\r\n                result[name] = trait\r\n        return result\r\n\r\n    def trait_names(self, **metadata):\r\n        \"\"\"Returns a list of the names of all trait attributes whose\r\n        definitions match the set of *metadata* criteria specified.\r\n\r\n        This method is similar to the traits() method, but returns only the\r\n        names of the matching trait attributes, not the trait definitions.\r\n\r\n        Parameters\r\n        ----------\r\n        **metadata :\r\n            Criteria for selecting trait attributes.\r\n        \"\"\"\r\n        return list(self.traits(**metadata).keys())\r\n\r\n    @classmethod\r\n    def class_trait_names(cls, **metadata):\r\n        \"\"\"Returns a list of the names of all trait attributes whose\r\n        definitions match the set of *metadata* criteria specified.\r\n\r\n        This method is similar to the traits() method, but returns only the\r\n        names of the matching trait attributes, not the trait definitions.\r\n\r\n        Parameters\r\n        ----------\r\n        **metadata :\r\n            Criteria for selecting trait attributes.\r\n        \"\"\"\r\n        return list(cls.class_traits(**metadata).keys())\r\n\r\n    def _set_traits_cache(self, name, value):\r\n        \"\"\" Explicitly sets the value of a cached property.\r\n        \"\"\"\r\n        cached = TraitsCache + name\r\n        old_value = self.__dict__.get(cached, Undefined)\r\n        self.__dict__[cached] = value\r\n        if old_value != value:\r\n            self.trait_property_changed(name, old_value, value)\r\n\r\n    def _flush_traits_cache(self, name, value):\r\n        \"\"\" Explicitly flushes the value of a cached property.\r\n        \"\"\"\r\n        self.trait_property_changed(name, self.__dict__.pop(TraitsCache + name, Undefined))\r\n\r\n    def __prefix_trait__(self, name, is_set):\r\n        \"\"\" Return the trait definition for a specified name when there is\r\n        no explicit definition in the class.\r\n        \"\"\"\r\n        if name[:2] == '__' and name[-2:] == '__':\r\n            if name == '__class__':\r\n                return generic_trait\r\n            if is_set:\r\n                return any_trait\r\n            raise AttributeError(\"'%s' object has no attribute '%s'\" % (self.__class__.__name__, name))\r\n        if name[-1:] == '_':\r\n            trait = self._trait(name[:-1], 0)\r\n            if trait is not None and trait.type == 'delegate':\r\n                return _clone_trait(trait)\r\n        prefix_traits = self.__prefix_traits__\r\n        for prefix in prefix_traits['*']:\r\n            if prefix == name[:len(prefix)]:\r\n                trait = prefix_traits[prefix]\r\n                cls = self.__class__\r\n                handlers = [_get_method(cls, '_%s_changed' % name), _get_method(cls, '_%s_fired' % name)]\r\n                _add_event_handlers(trait, cls, handlers)\r\n                handlers.append(prefix_traits.get('@'))\r\n                handlers = [h for h in handlers if h is not None]\r\n                if len(handlers) > 0:\r\n                    trait = _clone_trait(trait)\r\n                    _add_notifiers(trait._notifiers(True), handlers)\r\n                return trait\r\n        raise SystemError(\"Trait class look-up failed for attribute '%s' for an object of type '%s'\" % (name, self.__class__.__name__))\r\n\r\n    def add_trait_listener(self, object, prefix=''):\r\n        \"\"\" Add (Java-style) event listener to an object. \"\"\"\r\n        self._trait_listener(object, prefix, False)\r\n\r\n    def remove_trait_listener(self, object, prefix=''):\r\n        \"\"\" Remove (Java-style) event listener to an object. \"\"\"\r\n        self._trait_listener(object, prefix, True)\r\n\r\n    def _trait_listener(self, object, prefix, remove):\r\n        if prefix[-1:] != '_':\r\n            prefix += '_'\r\n        n = len(prefix)\r\n        traits = self.__base_traits__\r\n        for name in self._each_trait_method(object):\r\n            if name[:n] == prefix:\r\n                if name[-8:] == '_changed':\r\n                    short_name = name[n:-8]\r\n                    if short_name in traits:\r\n                        self._on_trait_change(getattr(object, name), short_name, remove=remove)\r\n                    elif short_name == 'anytrait':\r\n                        self._on_trait_change(getattr(object, name), remove=remove)\r\n                elif name[:-6] == '_fired':\r\n                    short_name = name[n:-6]\r\n                    if short_name in traits:\r\n                        self._on_trait_change(getattr(object, name), short_name, remove=remove)\r\n                    elif short_name == 'anytrait':\r\n                        self._on_trait_change(getattr(object, name), remove=remove)\r\n\r\n    def _each_trait_method(self, object):\r\n        \"\"\" Generates each (name, method) pair for a specified object.\r\n        \"\"\"\r\n        dic = {}\r\n        for klass in object.__class__.__mro__:\r\n            for (name, method) in klass.__dict__.items():\r\n                if is_unbound_method_type(method) and name not in dic:\r\n                    dic[name] = True\r\n                    yield name\r\n\r\n    def _instance_changed_handler(self, name, old, new):\r\n        \"\"\" Handles adding/removing listeners for a generic 'Instance' trait.\r\n        \"\"\"\r\n        arg_lists = self._get_instance_handlers(name)\r\n        if old is not None:\r\n            for args in arg_lists:\r\n                old.on_trait_change(*args, remove=True)\r\n        if new is not None:\r\n            for args in arg_lists:\r\n                new.on_trait_change(*args)\r\n\r\n    def _list_changed_handler(self, name, old, new):\r\n        \"\"\" Handles adding/removing listeners for a generic 'List(Instance)'\r\n            trait.\r\n        \"\"\"\r\n        arg_lists = self._get_instance_handlers(name)\r\n        for item in old:\r\n            for args in arg_lists:\r\n                item.on_trait_change(*args, remove=True)\r\n        for item in new:\r\n            for args in arg_lists:\r\n                item.on_trait_change(*args)\r\n\r\n    def _list_items_changed_handler(self, name, not_used, event):\r\n        \"\"\" Handles adding/removing listeners for a generic 'List(Instance)'\r\n            trait.\r\n        \"\"\"\r\n        arg_lists = self._get_instance_handlers(name[:-6])\r\n        for item in event.removed:\r\n            for args in arg_lists:\r\n                item.on_trait_change(*args, remove=True)\r\n        for item in event.added:\r\n            for args in arg_lists:\r\n                item.on_trait_change(*args)\r\n\r\n    def _get_instance_handlers(self, name):\r\n        \"\"\" Returns a list of (name, method) pairs for a specified 'Instance'\r\n            or 'List(Instance)' trait name:\r\n        \"\"\"\r\n        return [(getattr(self, method_name), item_name) for (method_name, item_name) in self.__class__.__instance_traits__[name]]\r\n\r\n    def _post_init_trait_listeners(self):\r\n        \"\"\" Initializes the object's statically parsed, but dynamically\r\n            registered, traits listeners (called at object creation and\r\n            unpickling times).\r\n        \"\"\"\r\n        for (name, data) in self.__class__.__listener_traits__.items():\r\n            if data[0] == 'method':\r\n                config = data[1]\r\n                if config['post_init']:\r\n                    self.on_trait_change(getattr(self, name), config['pattern'], deferred=True, dispatch=config['dispatch'])\r\n\r\n    def _init_trait_listeners(self):\r\n        \"\"\" Initializes the object's statically parsed, but dynamically\r\n            registered, traits listeners (called at object creation and\r\n            unpickling times).\r\n        \"\"\"\r\n        for (name, data) in self.__class__.__listener_traits__.items():\r\n            getattr(self, '_init_trait_%s_listener' % data[0])(name, *data)\r\n\r\n    def _init_trait_method_listener(self, name, kind, config):\r\n        \"\"\" Sets up the listener for a method with the @on_trait_change\r\n            decorator.\r\n        \"\"\"\r\n        if not config['post_init']:\r\n            self.on_trait_change(getattr(self, name), config['pattern'], deferred=True, dispatch=config['dispatch'])\r\n\r\n    def _init_trait_event_listener(self, name, kind, pattern):\r\n        \"\"\" Sets up the listener for an event with on_trait_change metadata.\r\n        \"\"\"\r\n\r\n        @weak_arg(self)\r\n        def notify(self):\r\n            setattr(self, name, True)\r\n        self.on_trait_change(notify, pattern, target=self)\r\n\r\n    def _init_trait_property_listener(self, name, kind, cached, pattern):\r\n        \"\"\" Sets up the listener for a property with 'depends_on' metadata.\r\n        \"\"\"\r\n        if cached is None:\r\n\r\n            @weak_arg(self)\r\n            def notify(self):\r\n                self.trait_property_changed(name, None)\r\n        else:\r\n            cached_old = cached + ':old'\r\n\r\n            @weak_arg(self)\r\n            def pre_notify(self):\r\n                dict = self.__dict__\r\n                old = dict.get(cached_old, Undefined)\r\n                if old is Undefined:\r\n                    dict[cached_old] = dict.pop(cached, None)\r\n            self.on_trait_change(pre_notify, pattern, priority=True, target=self)\r\n\r\n            @weak_arg(self)\r\n            def notify(self):\r\n                old = self.__dict__.pop(cached_old, Undefined)\r\n                if old is not Undefined:\r\n                    self.trait_property_changed(name, old)\r\n        self.on_trait_change(notify, pattern, target=self)\r\n\r\n    def _init_trait_delegate_listener(self, name, kind, pattern):\r\n        \"\"\" Sets up the listener for a delegate trait.\r\n        \"\"\"\r\n        name_pattern = self._trait_delegate_name(name, pattern)\r\n        target_name_len = len(name_pattern.split(':')[-1])\r\n\r\n        @weak_arg(self)\r\n        def notify(self, object, notify_name, old, new):\r\n            self.trait_property_changed(name + notify_name[target_name_len:], old, new)\r\n        self.on_trait_change(notify, name_pattern, target=self)\r\n        self.__dict__.setdefault(ListenerTraits, {})[name] = notify\r\n\r\n    def _remove_trait_delegate_listener(self, name, remove):\r\n        \"\"\" Removes a delegate listener when the local delegate value is set.\r\n        \"\"\"\r\n        dict = self.__dict__.setdefault(ListenerTraits, {})\r\n        if remove:\r\n            if name in dict:\r\n                self.on_trait_change(dict[name], self._trait_delegate_name(name, self.__class__.__listener_traits__[name][1]), remove=True)\r\n                del dict[name]\r\n                if len(dict) == 0:\r\n                    del self.__dict__[ListenerTraits]\r\n            return\r\n        if name not in dict:\r\n            self._init_trait_delegate_listener(name, 0, self.__class__.__listener_traits__[name][1])\r\n\r\n    def _init_trait_observers(self):\r\n        \"\"\" Initialize observers prior to setting object state.\r\n        \"\"\"\r\n        for (name, states) in self.__class__.__observer_traits__.items():\r\n            for state in states:\r\n                if not state['post_init']:\r\n                    observe_api.apply_observers(object=self, handler=state['handler_getter'](self, name), graphs=state['graphs'], dispatcher=_ObserverDispatchers[state['dispatch']])\r\n\r\n    def _post_init_trait_observers(self):\r\n        \"\"\" Initialize observers after setting object state.\r\n        \"\"\"\r\n        for (name, states) in self.__class__.__observer_traits__.items():\r\n            for state in states:\r\n                if state['post_init']:\r\n                    observe_api.apply_observers(object=self, handler=state['handler_getter'](self, name), graphs=state['graphs'], dispatcher=_ObserverDispatchers[state['dispatch']])\r\n\r\n    def _trait_delegate_name(self, name, pattern):\r\n        \"\"\" Returns the fully-formed 'on_trait_change' name for a specified\r\n            delegate.\r\n        \"\"\"\r\n        if pattern[-1] == '*':\r\n            pattern = '%s%s%s' % (pattern[:-1], self.__class__.__prefix__, name)\r\n        return pattern\r\n_HasTraits = HasTraits\r\n\r\nclass HasStrictTraits(HasTraits):\r\n    \"\"\" This class guarantees that any object attribute that does not have an\r\n    explicit or wildcard trait definition results in an exception.\r\n\r\n    This feature can be useful in cases where a more rigorous software\r\n    engineering approach is being used than is typical for Python programs. It\r\n    also helps prevent typos and spelling mistakes in attribute names from\r\n    going unnoticed; a misspelled attribute name typically causes an exception.\r\n    \"\"\"\r\n    _ = Disallow\r\n\r\nclass HasRequiredTraits(HasStrictTraits):\r\n    \"\"\" This class builds on the functionality of HasStrictTraits and ensures\r\n    that any object attribute with `required=True` in its metadata must be\r\n    passed as an argument on object initialization.\r\n\r\n    This can be useful in cases where an object has traits which are required\r\n    for it to function correctly.\r\n\r\n    Raises\r\n    ------\r\n    TraitError\r\n        If a required trait is not passed as an argument.\r\n\r\n    Examples\r\n    --------\r\n    A class with required traits:\r\n\r\n    >>> class RequiredTest(HasRequiredTraits):\r\n    ...     required_trait = Any(required=True)\r\n    ...     non_required_trait = Any()\r\n\r\n    Creating an instance of a HasRequiredTraits subclass:\r\n\r\n    >>> test_instance = RequiredTest(required_trait=13, non_required_trait=11)\r\n    >>> test_instance2 = RequiredTest(required_trait=13)\r\n\r\n    Forgetting to specify a required trait:\r\n\r\n    >>> test_instance = RequiredTest(non_required_trait=11)\r\n    traits.trait_errors.TraitError: The following required traits were not\r\n    provided: required_trait.\r\n    \"\"\"\r\n\r\n    def __init__(self, **traits):\r\n        missing_required_traits = [name for name in self.trait_names(required=True) if name not in traits]\r\n        if missing_required_traits:\r\n            raise TraitError('The following required traits were not provided: {}.'.format(', '.join(sorted(missing_required_traits))))\r\n        super().__init__(**traits)\r\n\r\nclass HasPrivateTraits(HasTraits):\r\n    \"\"\" This class ensures that any public object attribute that does not have\r\n    an explicit or wildcard trait definition results in an exception, but\r\n    \"private\" attributes (whose names start with '_') have an initial value of\r\n    **None**, and are not type-checked.\r\n\r\n    This feature is useful in cases where a class needs private attributes to\r\n    keep track of its internal object state, which are not part of the class's\r\n    public API. Such attributes do not need to be type-checked, because they\r\n    are manipulated only by the (presumably correct) methods of the class\r\n    itself.\r\n    \"\"\"\r\n    __ = Any(private=True, transient=True)\r\n    _ = Disallow\r\n\r\nclass ABCMetaHasTraits(abc.ABCMeta, MetaHasTraits):\r\n    \"\"\" A MetaHasTraits subclass which also inherits from\r\n    abc.ABCMeta.\r\n\r\n    .. note:: The ABCMeta class is cooperative and behaves nicely\r\n        with MetaHasTraits, provided it is inherited first.\r\n    \"\"\"\r\n    pass\r\n"]
[21.2892, "o", "\r\nclass ABCHasTraits(HasTraits, metaclass=ABCMetaHasTraits):\r\n    \"\"\" A HasTraits subclass which enables the features of Abstract\r\n    Base Classes (ABC). See the 'abc' module in the standard library\r\n    for more information.\r\n\r\n    \"\"\"\r\n\r\nclass ABCHasStrictTraits(ABCHasTraits):\r\n    \"\"\" A HasTraits subclass which behaves like HasStrictTraits but\r\n    also enables the features of Abstract Base Classes (ABC). See the\r\n    'abc' module in the standard library for more information.\r\n\r\n    \"\"\"\r\n    _ = Disallow\r\n\r\nclass Vetoable(HasStrictTraits):\r\n    \"\"\" Defines a 'vetoable' request object and an associated event.\r\n    \"\"\"\r\n    veto = Bool(False)\r\n\r\n    def _veto_changed(self, state):\r\n        self._trait_veto_notify(state)\r\nVetoableEvent = Event(Vetoable)\r\n\r\nclass MetaInterface(ABCMetaHasTraits):\r\n    \"\"\" Meta class for interfaces.\r\n\r\n    Historically, there were some differences between interfaces\r\n    and ABCs in Traits, but now Interface is a near synonym for\r\n    ABCHasTraits.\r\n    \"\"\"\r\n\r\nclass Interface(HasTraits, metaclass=MetaInterface):\r\n    \"\"\" The base class for all interfaces.\r\n    \"\"\"\r\n\r\ndef provides(*protocols):\r\n    \"\"\" Class decorator to declare the protocols that a class provides.\r\n\r\n    Parameters\r\n    ----------\r\n    *protocols :\r\n        A list of protocols (Interface classes or Python ABCs) that the\r\n        decorated class provides.\r\n\r\n    \"\"\"\r\n    from abc import ABCMeta\r\n    if len(protocols) == 0:\r\n        return lambda klass: klass\r\n    for protocol in protocols:\r\n        if not issubclass(type(protocol), ABCMeta):\r\n            raise TraitError(\"All arguments to 'provides' must be subclasses of Interface or be a Python ABC.\")\r\n\r\n    def wrapped_class(klass):\r\n        for protocol in protocols:\r\n            type(protocol).register(protocol, klass)\r\n        if CHECK_INTERFACES:\r\n            from .interface_checker import check_implements\r\n            warnings.warn('In the future, the @provides decorator will not perform interface checks. Set has_traits.CHECK_INTERFACES to 0 to suppress this warning.', DeprecationWarning, stacklevel=2)\r\n            check_implements(klass, protocols, CHECK_INTERFACES)\r\n        return klass\r\n    return wrapped_class\r\n\r\ndef isinterface(klass):\r\n    \"\"\" Return True if the class is an Interface. \"\"\"\r\n    return isinstance(klass, MetaInterface)\r\n\r\nclass ISerializable(Interface):\r\n    \"\"\" A class that implemented ISerializable requires that all HasTraits\r\n        objects saved as part of its state also implement ISerializable.\r\n    \"\"\"\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[26.031577, "i", "less has_traits.py\n"]
[26.031812, "o", "less has_traits.py\r\n\u001b[?2004l\r"]
[26.032363, "o", "bash: less: command not found\r\n"]
[26.032752, "o", "\u001b[?2004h"]
[26.0328, "o", "root@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[31.21624, "i", "grep -E 'def (clone_traits|__deepcopy__|copy_traits|all_trait_names|base_trait)' has_traits.py\n"]
[31.216847, "o", "grep -E 'def (clone_traits|__deepcopy__|copy_traits|all_trait_names|base_trait)' has_traits.py \r"]
[31.216872, "o", "\u001bM\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[C\u001b[Ky\r\n\u001b[?2004l\r"]
[31.219423, "o", "    def clone_traits(self, traits=None, memo=None, copy=None, **metadata):\r\n"]
[31.219945, "o", "\u001b[?2004h"]
[31.219968, "o", "root@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[53.953767, "i", "grep -E 'def __deepcopy__' has_traits.py\n"]
[53.954191, "o", "grep -E 'def __deepcopy__' has_traits.py\r\n\u001b[?2004l\r"]
[53.955904, "o", "\u001b[?2004h"]
[53.955996, "o", "root@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[75.362021, "i", "grep -E 'def copy_traits' has_traits.py\n"]
[75.362232, "o", "grep -E 'def copy_traits' has_traits.py\r\n\u001b[?2004l\r"]
[75.363898, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[86.543908, "i", "grep -E 'def all_trait_names' has_traits.py\n"]
[86.544151, "o", "grep -E 'def all_trait_names' has_traits.py\r\n\u001b[?2004l\r"]
[86.545574, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[111.632337, "i", "grep -E 'def base_trait' has_traits.py\n"]
[111.632563, "o", "grep -E 'def base_trait' has_traits.py\r\n\u001b[?2004l\r"]
[111.634012, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[143.278134, "i", "sed -i '/def clone_traits/a \\\n    def __deepcopy__(self, memo):\\\n        pass\\\n\\\n    def copy_traits(self, traits=None, memo=None):\\\n        pass\\\n\\\n    def all_trait_names(self):\\\n        pass\\\n\\\n    def base_trait(self, name):\\\n        pass' has_traits.py\n"]
[143.278471, "o", "sed -i '/def clone_traits/a \\\r\n\u001b[?2004l\r"]
[143.278569, "o", "\u001b[?2004h> "]
[143.278762, "o", "    def __deepcopy__(self, memo):\\\r\n\u001b[?2004l\r\u001b[?2004h"]
[143.278813, "o", "> "]
[143.278927, "o", "        pass\\\r\n\u001b[?2004l\r\u001b[?2004h> \\\r\n"]
[143.27898, "o", "\u001b[?2004l\r\u001b[?2004h> "]
[143.279303, "o", "    def copy_traits(self, traits=None, memo=None):\\\r\n\u001b[?2004l\r"]
[143.279369, "o", "\u001b[?2004h> "]
[143.279501, "o", "        pass\\\r\n\u001b[?2004l\r"]
[143.2796, "o", "\u001b[?2004h> \\\r\n\u001b[?2004l\r"]
[143.279718, "o", "\u001b[?2004h> "]
[143.27995, "o", "    def all_trait_names(self):\\\r\n\u001b[?2004l\r"]
[143.280013, "o", "\u001b[?2004h> "]
[143.280156, "o", "        pass\\\r\n\u001b[?2004l\r"]
[143.280222, "o", "\u001b[?2004h> \\\r\n\u001b[?2004l\r"]
[143.280286, "o", "\u001b[?2004h> "]
[143.280589, "o", "    def base_trait(self, name):\\\r\n\u001b[?2004l\r"]
[143.280654, "o", "\u001b[?2004h> "]
[143.280907, "o", "        pass' has_traits.py\r\n\u001b[?2004l\r"]
[143.32714, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[144.285395, "i", "cat has_traits.py\n"]
[144.285709, "o", "cat has_traits.py\r\n\u001b[?2004l\r"]
[144.287694, "o", "\"\"\" Defines the HasTraits class, along with several useful subclasses and\r\n    associated metaclasses.\r\n\"\"\"\r\nimport abc\r\nimport copy as copy_module\r\nimport inspect\r\nimport os\r\nimport pickle\r\nimport re\r\nimport types\r\nimport warnings\r\nimport weakref\r\nfrom types import FunctionType\r\nfrom . import __version__ as TraitsVersion\r\nfrom .constants import DefaultValue, TraitKind\r\nfrom .ctrait import CTrait, __newobj__\r\nfrom .ctraits import CHasTraits\r\nfrom .observation import api as observe_api\r\nfrom .traits import ForwardProperty, Property, Trait, generic_trait\r\nfrom .trait_types import Any, Bool, Disallow, Event, Python, Str\r\nfrom .trait_notifiers import ExtendedTraitChangeNotifyWrapper, FastUITraitChangeNotifyWrapper, NewTraitChangeNotifyWrapper, StaticAnytraitChangeNotifyWrapper, StaticTraitChangeNotifyWrapper, TraitChangeNotifyWrapper, ui_dispatch\r\nfrom .trait_base import SequenceTypes, TraitsCache, Undefined, is_none, not_event, not_false\r\nfrom .trait_errors import TraitError\r\nfrom .trait_converters import check_trait, mapped_trait_for, trait_for\r\nCHECK_INTERFACES = 0\r\n\r\nclass AbstractViewElement(abc.ABC):\r\n    pass\r\nWrapperTypes = (StaticAnytraitChangeNotifyWrapper, StaticTraitChangeNotifyWrapper)\r\nBaseTraits = '__base_traits__'\r\nClassTraits = '__class_traits__'\r\nPrefixTraits = '__prefix_traits__'\r\nListenerTraits = '__listener_traits__'\r\nObserverTraits = '__observer_traits__'\r\nViewTraits = '__view_traits__'\r\nInstanceTraits = '__instance_traits__'\r\nDefaultTraitsView = 'traits_view'\r\nCantHaveDefaultValue = ('event', 'delegate', 'constant')\r\nDeferredCopy = ('delegate', 'property')\r\nextended_trait_pat = re.compile('.*[ :\\\\+\\\\-,\\\\.\\\\*\\\\?\\\\[\\\\]]')\r\nany_trait = Any().as_ctrait()\r\n_ObserverDispatchers = {'same': observe_api.dispatch_same, 'ui': ui_dispatch}\r\n\r\ndef _clone_trait(clone, metadata=None):\r\n    \"\"\" Creates a clone of a specified trait.\r\n    \"\"\"\r\n    trait = CTrait(TraitKind.trait)\r\n    trait.clone(clone)\r\n    if clone.__dict__ is not None:\r\n        trait.__dict__ = clone.__dict__.copy()\r\n    if metadata is not None:\r\n        trait.__dict__.update(metadata)\r\n    return trait\r\n\r\ndef _get_method(cls, method):\r\n    \"\"\" Get the definition of a specified method (if any). \"\"\"\r\n    result = getattr(cls, method, None)\r\n    if result is not None and is_unbound_method_type(result):\r\n        return result\r\n    return None\r\n\r\ndef _get_def(class_name, class_dict, bases, method):\r\n    \"\"\" Gets the definition of a specified method (if any).\r\n    \"\"\"\r\n    if method[0:2] == '__':\r\n        method = '_%s%s' % (class_name.lstrip('_'), method)\r\n    result = class_dict.get(method)\r\n    if result is not None and is_unbound_method_type(result) and (getattr(result, 'on_trait_change', None) is None) and (getattr(result, '_observe_inputs', None) is None):\r\n        return result\r\n    for base in bases:\r\n        result = getattr(base, method, None)\r\n        if result is not None and is_unbound_method_type(result) and (getattr(result, 'on_trait_change', None) is None) and (getattr(result, '_observe_inputs', None) is None):\r\n            return result\r\n    return None\r\n\r\ndef is_unbound_method_type(method):\r\n    \"\"\" Check for something that looks like an unbound class method.\r\n\r\n    This is used in practice to identify magic-named _name_changed\r\n    and _name_fired methods.\r\n\r\n    \"\"\"\r\n    return inspect.isfunction(method) or inspect.ismethoddescriptor(method)\r\n\r\ndef _is_serializable(value):\r\n    \"\"\" Returns whether or not a specified value is serializable.\r\n    \"\"\"\r\n    if isinstance(value, (list, tuple)):\r\n        for item in value:\r\n            if not _is_serializable(item):\r\n                return False\r\n        return True\r\n    if isinstance(value, dict):\r\n        for (name, item) in value.items():\r\n            if not _is_serializable(name) or not _is_serializable(item):\r\n                return False\r\n        return True\r\n    return not isinstance(value, HasTraits) or value.has_traits_interface(ISerializable)\r\n\r\ndef _get_instance_handlers(class_dict, bases):\r\n    \"\"\" Returns a dictionary of potential 'Instance' or 'List(Instance)'\r\n        handlers.\r\n    \"\"\"\r\n    instance_traits = {}\r\n    for base in bases:\r\n        for (name, base_arg_lists) in base.__dict__.get(InstanceTraits).items():\r\n            arg_lists = instance_traits.get(name)\r\n            if arg_lists is None:\r\n                instance_traits[name] = base_arg_lists[:]\r\n            else:\r\n                for arg_list in base_arg_lists:\r\n                    if arg_list not in arg_lists:\r\n                        arg_lists.append(arg_list)\r\n    for (name, value) in class_dict.items():\r\n        if name[:1] == '_' and is_unbound_method_type(value):\r\n            n = 13\r\n            col = name.find('_changed_for_')\r\n            if col < 2:\r\n                n = 11\r\n                col = name.find('_fired_for_')\r\n            if col >= 2:\r\n                key = name[col + n:]\r\n                if key != '':\r\n                    arg_list = (name, name[1:col])\r\n                    arg_lists = instance_traits.setdefault(key, [])\r\n                    if arg_list not in arg_lists:\r\n                        arg_lists.append(arg_list)\r\n    return instance_traits\r\n\r\ndef get_delegate_pattern(name, trait):\r\n    \"\"\" Returns the correct 'delegate' listener pattern for a specified name\r\n    and delegate trait.\r\n    \"\"\"\r\n    prefix = trait._prefix\r\n    if prefix == '':\r\n        prefix = name\r\n    elif len(prefix) > 1 and prefix[-1] == '*':\r\n        prefix = prefix[:-1] + name\r\n    return ' %s:%s' % (trait._delegate, prefix)\r\n\r\nclass _SimpleTest:\r\n\r\n    def __init__(self, value):\r\n        self.value = value\r\n\r\n    def __call__(self, test):\r\n        return test == self.value\r\n\r\ndef _add_notifiers(notifiers, handlers):\r\n    \"\"\" Adds a list of handlers to a specified notifiers list.\r\n    \"\"\"\r\n    for handler in handlers:\r\n        if not isinstance(handler, WrapperTypes):\r\n            handler = StaticTraitChangeNotifyWrapper(handler)\r\n        notifiers.append(handler)\r\n\r\ndef _add_event_handlers(trait, cls, handlers):\r\n    \"\"\" Adds any specified event handlers defined for a trait by a class.\r\n    \"\"\"\r\n    events = trait.event\r\n    if events is not None:\r\n        if isinstance(events, str):\r\n            events = [events]\r\n        for event in events:\r\n            handlers.append(_get_method(cls, '_%s_changed' % event))\r\n            handlers.append(_get_method(cls, '_%s_fired' % event))\r\n\r\ndef _property_method(class_dict, name):\r\n    \"\"\" Returns the method associated with a particular class property\r\n    getter/setter.\r\n    \"\"\"\r\n    return class_dict.get(name)\r\n\r\ndef _create_property_observe_state(observe, property_name, cached):\r\n    \"\"\" Create the metadata for setting up an observer for Property.\r\n\r\n    Parameters\r\n    ----------\r\n    observe : str or list or Expression\r\n        As is accepted by HasTraits.observe expression argument\r\n        This is the value provided in Property(observe=...)\r\n    property_name : str\r\n        The name of the property trait.\r\n    cached : boolean\r\n        Whether the property is cached or not.\r\n\r\n    Returns\r\n    -------\r\n    state : dict\r\n        State to be used by _init_traits_observers\r\n    \"\"\"\r\n\r\n    def handler(instance, event):\r\n        if cached:\r\n            cache_name = TraitsCache + property_name\r\n            old = instance.__dict__.pop(cache_name, Undefined)\r\n        else:\r\n            old = Undefined\r\n        instance.trait_property_changed(property_name, old)\r\n\r\n    def handler_getter(instance, name):\r\n        return types.MethodType(handler, instance)\r\n    graphs = _compile_expression(observe)\r\n    return dict(graphs=graphs, dispatch='same', handler_getter=handler_getter, post_init=False)\r\n\r\ndef _compile_expression(expression):\r\n    \"\"\" Compile a user-supplied expression or list of expressions.\r\n\r\n    Converts a list of strings or ObserverExpressions to a list of\r\n    ObserverGraphs representing the observation patterns to be applied.\r\n\r\n    Parameters\r\n    ----------\r\n    expression : str or list or ObserverExpression\r\n        A description of what traits are being observed.\r\n        If this is a list, each item must be a string or an ObserverExpression.\r\n\r\n    Returns\r\n    -------\r\n    graphs : list of ObserverGraph\r\n        List of graphs representing the observation patterns to be applied\r\n        to the relevant objects and handlers.\r\n    \"\"\"\r\n    if isinstance(expression, list):\r\n        expressions = expression\r\n    else:\r\n        expressions = [expression]\r\n    graphs = []\r\n    for expr in expressions:\r\n        graphs.extend(observe_api.compile_str(expr) if isinstance(expr, str) else observe_api.compile_expr(expr))\r\n    return graphs\r\n_HasTraits = None\r\n\r\nclass MetaHasTraits(type):\r\n    \"\"\" Controls the creation of HasTraits classes.\r\n\r\n    The heavy work is done by the `update_traits_class_dict` function, which\r\n    takes the ``class_dict`` dictionary of class members and extracts and\r\n    processes the trait declarations in it. The trait declarations are then\r\n    added back to the class dictionary and passed off to the __new__ method\r\n    of the type superclass, to be added to the class.\r\n\r\n    \"\"\"\r\n\r\n    def __new__(cls, class_name, bases, class_dict):\r\n        update_traits_class_dict(class_name, bases, class_dict)\r\n        return type.__new__(cls, class_name, bases, class_dict)\r\n\r\ndef update_traits_class_dict(class_name, bases, class_dict):\r\n    \"\"\" Processes all of the traits related data in the class dictionary.\r\n\r\n    This is called during the construction of a new HasTraits class. The first\r\n    three parameters have the same interpretation as the corresponding\r\n    parameters of ``type.__new__``. This function modifies ``class_dict``\r\n    in-place.\r\n\r\n    Parameters\r\n    ----------\r\n    class_name : str\r\n        The name of the HasTraits class.\r\n    bases : tuple\r\n        The base classes for the HasTraits class.\r\n    class_dict : dict\r\n        A dictionary of class members.\r\n    \"\"\"\r\n    base_traits = {}\r\n    class_traits = {}\r\n    prefix_traits = {}\r\n    listeners = {}\r\n    prefix_list = []\r\n    view_elements = {}\r\n    observers = {}\r\n    hastraits_bases = [base for base in bases if base.__dict__.get(ClassTraits) is not None]\r\n    inherited_class_traits = [base.__dict__.get(ClassTraits) for base in hastraits_bases]\r\n    for (name, value) in list(class_dict.items()):\r\n        value = check_trait(value)\r\n        rc = isinstance(value, CTrait)\r\n        if not rc and isinstance(value, ForwardProperty):\r\n            rc = True\r\n            getter = _property_method(class_dict, '_get_' + name)\r\n            setter = _property_method(class_dict, '_set_' + name)\r\n            if setter is None and getter is not None:\r\n                if getattr(getter, 'settable', False):\r\n                    setter = HasTraits._set_traits_cache\r\n                elif getattr(getter, 'flushable', False):\r\n                    setter = HasTraits._flush_traits_cache\r\n            validate = _property_method(class_dict, '_validate_' + name)\r\n            if validate is None:\r\n                validate = value.validate\r\n            value = Property(getter, setter, validate, True, value.handler, **value.metadata)\r\n        if rc:\r\n            del class_dict[name]\r\n            if name[-1:] != '_':\r\n                base_traits[name] = class_traits[name] = value\r\n                value_type = value.type\r\n                if value_type == 'trait':\r\n                    handler = value.handler\r\n                    if handler is not None:\r\n                        if handler.has_items:\r\n                            items_trait = _clone_trait(handler.items_event(), value.__dict__)\r\n                            if items_trait.instance_handler == '_list_changed_handler':\r\n                                items_trait.instance_handler = '_list_items_changed_handler'\r\n                            class_traits[name + '_items'] = items_trait\r\n                        if handler.is_mapped:\r\n                            class_traits[name + '_'] = mapped_trait_for(value, name)\r\n                elif value_type == 'delegate':\r\n                    if value._listenable is not False:\r\n                        listeners[name] = ('delegate', get_delegate_pattern(name, value))\r\n                elif value_type == 'event':\r\n                    on_trait_change = value.on_trait_change\r\n                    if isinstance(on_trait_change, str):\r\n                        listeners[name] = ('event', on_trait_change)\r\n            else:\r\n                name = name[:-1]\r\n                prefix_list.append(name)\r\n                prefix_traits[name] = value\r\n        elif is_unbound_method_type(value):\r\n            pattern = getattr(value, 'on_trait_change', None)\r\n            if pattern is not None:\r\n                listeners[name] = ('method', pattern)\r\n            observer_states = getattr(value, '_observe_inputs', None)\r\n            if observer_states is not None:\r\n                observers[name] = observer_states\r\n        elif isinstance(value, property):\r\n            class_traits[name] = generic_trait\r\n        elif isinstance(value, AbstractViewElement):\r\n            view_elements[name] = value\r\n            del class_dict[name]\r\n        else:\r\n            for ct in inherited_class_traits:\r\n                if name in ct:\r\n                    ictrait = ct[name]\r\n                    if ictrait.type in CantHaveDefaultValue:\r\n                        raise TraitError(\"Cannot specify a default value for the %s trait '%s'. You must override the the trait definition instead.\" % (ictrait.type, name))\r\n                    class_traits[name] = ictrait(value)\r\n                    del class_dict[name]\r\n                    break\r\n    migrated_properties = {}\r\n    for base in hastraits_bases:\r\n        base_dict = base.__dict__\r\n        for (name, value) in base_dict.get(ListenerTraits).items():\r\n            if name not in class_traits and name not in class_dict:\r\n                listeners[name] = value\r\n        for (name, states) in base_dict[ObserverTraits].items():\r\n            if name not in class_traits and name not in class_dict:\r\n                observers[name] = states\r\n        for (name, value) in base_dict.get(BaseTraits).items():\r\n            if name not in base_traits:\r\n                property_info = value.property_fields\r\n                if property_info is not None:\r\n                    key = id(value)\r\n                    migrated_properties[key] = value = migrate_property(name, value, property_info, class_dict)\r\n                base_traits[name] = value\r\n        for (name, value) in base_dict.get(ClassTraits).items():\r\n            if name not in class_traits:\r\n                property_info = value.property_fields\r\n                if property_info is not None:\r\n                    new_value = migrated_properties.get(id(value))\r\n                    if new_value is not None:\r\n                        value = new_value\r\n                    else:\r\n                        value = migrate_property(name, value, property_info, class_dict)\r\n                class_traits[name] = value\r\n        base_prefix_traits = base_dict.get(PrefixTraits)\r\n        for name in base_prefix_traits['*']:\r\n            if name not in prefix_list:\r\n                prefix_list.append(name)\r\n                prefix_traits[name] = base_prefix_traits[name]\r\n    if prefix_traits.get('') is None:\r\n        prefix_list.append('')\r\n        prefix_traits[''] = Python().as_ctrait()\r\n    prefix_traits['*'] = prefix_list\r\n    prefix_list.sort(key=len, reverse=True)\r\n    instance_traits = _get_instance_handlers(class_dict, hastraits_bases)\r\n    anytrait = _get_def(class_name, class_dict, bases, '_anytrait_changed')\r\n    if anytrait is not None:\r\n        anytrait = StaticAnytraitChangeNotifyWrapper(anytrait)\r\n        prefix_traits['@'] = anytrait\r\n    cloned = set()\r\n    for name in list(class_traits.keys()):\r\n        trait = class_traits[name]\r\n        handlers = [anytrait, _get_def(class_name, class_dict, bases, '_%s_changed' % name), _get_def(class_name, class_dict, bases, '_%s_fired' % name)]\r\n        instance_handler = trait.instance_handler\r\n        if instance_handler is not None and name in instance_traits or (instance_handler == '_list_items_changed_handler' and name[-6:] == '_items' and (name[:-6] in instance_traits)):\r\n            handlers.append(getattr(HasTraits, instance_handler))\r\n        events = trait.event\r\n        if events is not None:\r\n            if isinstance(events, str):\r\n                events = [events]\r\n            for event in events:\r\n                handlers.append(_get_def(class_name, class_dict, bases, '_%s_changed' % event))\r\n                handlers.append(_get_def(class_name, class_dict, bases, '_%s_fired' % event))\r\n        handlers = [h for h in handlers if h is not None]\r\n        default = _get_def(class_name, class_dict, [], '_%s_default' % name)\r\n        if len(handlers) > 0 or default is not None:\r\n            if name not in cloned:\r\n                cloned.add(name)\r\n                class_traits[name] = trait = _clone_trait(trait)\r\n            if len(handlers) > 0:\r\n                _add_notifiers(trait._notifiers(True), handlers)\r\n            if default is not None:\r\n                trait.set_default_value(DefaultValue.callable, default)\r\n        if trait.type == 'property' and trait.depends_on is not None:\r\n            cached = trait.cached\r\n            if cached is True:\r\n                cached = TraitsCache + name\r\n            depends_on = trait.depends_on\r\n            if isinstance(depends_on, SequenceTypes):\r\n                depends_on = ','.join(depends_on)\r\n            else:\r\n                depends_on = ' ' + depends_on\r\n            listeners[name] = ('property', cached, depends_on)\r\n        if trait.type == 'property' and trait.observe is not None:\r\n            observer_state = _create_property_observe_state(observe=trait.observe, property_name=name, cached=trait.cached)\r\n            observers[name] = [observer_state]\r\n    class_dict[BaseTraits] = base_traits\r\n    class_dict[ClassTraits] = class_traits\r\n    class_dict[InstanceTraits] = instance_traits\r\n    class_dict[PrefixTraits] = prefix_traits\r\n    class_dict[ListenerTraits] = listeners\r\n    class_dict[ObserverTraits] = observers\r\n    class_dict[ViewTraits] = view_elements\r\n\r\ndef migrate_property(name, property, property_info, class_dict):\r\n    \"\"\" Migrates an existing property to the class being defined\r\n    (allowing for method overrides).\r\n    \"\"\"\r\n    get = _property_method(class_dict, '_get_' + name)\r\n    set = _property_method(class_dict, '_set_' + name)\r\n    val = _property_method(class_dict, '_validate_' + name)\r\n    if get is not None or set is not None or val is not None:\r\n        (old_get, old_set, old_val) = property_info\r\n        return Property(get or old_get, set or old_set, val or old_val, True, **property.__dict__)\r\n    return property\r\n\r\ndef observe(expression, *, post_init=False, dispatch='same'):\r\n    \"\"\" Marks the wrapped method as being a handler to be called when the\r\n    specified traits change.\r\n\r\n    This decorator can be stacked, e.g.::\r\n\r\n        @observe(\"attr1\")\r\n        @observe(\"attr2\", post_init=True)\r\n        def updated(self, event):\r\n            ...\r\n\r\n    The decorated function must accept one argument which is the event object\r\n    representing the change. See :mod:`traits.observation.events` for details.\r\n\r\n    Parameters\r\n    ----------\r\n    expression : str or list or ObserverExpression\r\n        A description of what traits are being observed.\r\n        If this is a list, each item must be a string or Expression.\r\n        See :py:func:`HasTraits.observe` for details on the\r\n        semantics when passing a string.\r\n    post_init : boolean, optional\r\n        Whether the change handler should be attached after\r\n        the state is set when instantiating an object. Default is false, and\r\n        values provided to the instance constructor will trigger the\r\n        change handler to fire if the value is different from the\r\n        default. Set to true to avoid this change event.\r\n    dispatch : str, optional\r\n        A string indicating how the handler should be run. Default is to run\r\n        it on the same thread where the change occurs.\r\n        Possible values are:\r\n\r\n        =========== =======================================================\r\n        value       dispatch\r\n        =========== =======================================================\r\n        ``same``    Run notifications on the same thread where the change\r\n                    occurs. The notifications are executed immediately.\r\n        ``ui``      Run notifications on the UI thread. If the current\r\n                    thread is the UI thread, the notifications are executed\r\n                    immediately; otherwise, they are placed on the UI\r\n                    event queue.\r\n        =========== =======================================================\r\n\r\n    See Also\r\n    --------\r\n    HasTraits.observe\r\n    \"\"\"\r\n    graphs = _compile_expression(expression)\r\n\r\n    def observe_decorator(handler):\r\n        \"\"\" Create input arguments for HasTraits.observe and attach the input\r\n        to the callable.\r\n\r\n        The metaclass will then collect this information for calling\r\n        HasTraits.observe with the decorated function.\r\n\r\n        Parameters\r\n        ----------\r\n        handler : callable\r\n            Method of a subclass of HasTraits, with signature of the form\r\n            ``my_method(self, event)``.\r\n        \"\"\"\r\n        handler_signature = inspect.signature(handler)\r\n        try:\r\n            handler_signature.bind('self', 'event')\r\n        except TypeError:\r\n            warnings.warn(\"Dubious signature for observe-decorated method. The decorated method should be callable with a single positional argument in addition to 'self'. Did you forget to add an 'event' parameter?\", UserWarning, stacklevel=2)\r\n        try:\r\n            observe_inputs = handler._observe_inputs\r\n        except AttributeError:\r\n            observe_inputs = []\r\n            handler._observe_inputs = observe_inputs\r\n        observe_input = dict(graphs=graphs, dispatch=dispatch, post_init=post_init, handler_getter=getattr)\r\n        observe_inputs.append(observe_input)\r\n        return handler\r\n    return observe_decorator\r\n\r\ndef on_trait_change(name, post_init=False, dispatch='same'):\r\n    \"\"\" Marks the following method definition as being a handler for the\r\n        extended trait change specified by *name(s)*.\r\n\r\n        Refer to the documentation for the on_trait_change() method of\r\n        the **HasTraits** class for information on the correct syntax for\r\n        the *name* argument and the semantics of the *dispatch* keyword\r\n        argument.\r\n\r\n        A handler defined using this decorator is normally effective\r\n        immediately. However, if *post_init* is **True**, then the handler only\r\n        becomes effective after all object constructor arguments have been\r\n        processed. That is, trait values assigned as part of object\r\n        construction will not cause the handler to be invoked.\r\n\r\n        See Also\r\n        --------\r\n        observe : A newer API for defining traits notifications.\r\n    \"\"\"\r\n\r\n    def decorator(function):\r\n        function.on_trait_change = {'pattern': name, 'post_init': post_init, 'dispatch': dispatch}\r\n        return function\r\n    return decorator\r\n\r\ndef cached_property(function):\r\n    \"\"\" Marks the following method definition as being a \"cached property\".\r\n        That is, it is a property getter which, for performance reasons, caches\r\n        its most recently computed result in an attribute whose name is of the\r\n        form: *_traits_cache_name*, where *name* is the name of the property. A\r\n        method marked as being a cached property needs only to compute and\r\n        return its result. The @cached_property decorator automatically wraps\r\n        the decorated method in cache management code, eliminating the need to\r\n        write boilerplate cache management code explicitly. For example::\r\n\r\n            file_name = File\r\n            file_contents = Property(observe='file_name')\r\n\r\n            @cached_property\r\n            def _get_file_contents(self):\r\n                with open(self.file_name, 'rb') as fh:\r\n                    return fh.read()\r\n\r\n        In this example, accessing the *file_contents* trait calls the\r\n        _get_file_contents() method only once each time after the **file_name**\r\n        trait is modified. In all other cases, the cached value\r\n        **_file_contents**, which maintained by the @cached_property wrapper\r\n        code, is returned.\r\n\r\n        Note the use, in the example, of the **observe** metadata attribute\r\n        to specify that the value of **file_contents** depends on\r\n        **file_name**, so that _get_file_contents() is called only when\r\n        **file_name** changes. For details, see the traits.traits.Property()\r\n        function.\r\n    \"\"\"\r\n    name = TraitsCache + function.__name__[5:]\r\n\r\n    def decorator(self):\r\n        result = self.__dict__.get(name, Undefined)\r\n        if result is Undefined:\r\n            self.__dict__[name] = result = function(self)\r\n        return result\r\n    decorator.cached_property = True\r\n    return decorator\r\n\r\ndef property_depends_on(dependency, settable=False, flushable=False):\r\n    \"\"\" Marks the following method definition as being a \"cached property\"\r\n        that depends on the specified extended trait names. That is, it is a\r\n        property getter which, for performance reasons, caches its most\r\n        recently computed result in an attribute whose name is of the form:\r\n        *_traits_cache_name*, where *name* is the name of the property. A\r\n        method marked as being a cached property needs only to compute and\r\n        return its result. The @property_depends_on decorator automatically\r\n        wraps the decorated method in cache management code that will cache the\r\n        most recently computed value and flush the cache when any of the\r\n        specified dependencies are modified, thus eliminating the need to write\r\n        boilerplate cache management code explicitly. For example::\r\n\r\n            file_name = File\r\n            file_contents = Property\r\n\r\n            @property_depends_on('file_name')\r\n            def _get_file_contents(self):\r\n                with open(self.file_name, 'rb') as fh:\r\n                    return fh.read()\r\n\r\n        In this example, accessing the *file_contents* trait calls the\r\n        _get_file_contents() method only once each time after the **file_name**\r\n        trait is modified. In all other cases, the cached value\r\n        **_file_contents**, which is maintained by the @cached_property wrapper\r\n        code, is returned.\r\n    \"\"\"\r\n\r\n    def decorator(function):\r\n        name = TraitsCache + function.__name__[5:]\r\n\r\n        def wrapper(self):\r\n            result = self.__dict__.get(name, Undefined)\r\n            if result is Undefined:\r\n                self.__dict__[name] = result = function(self)\r\n            return result\r\n        wrapper.cached_property = True\r\n        wrapper.depends_on = dependency\r\n        wrapper.settable = settable\r\n        wrapper.flushable = flushable\r\n        return wrapper\r\n    return decorator\r\n\r\ndef weak_arg(arg):\r\n    \"\"\" Create a weak reference to arg and wrap the function so that the\r\n    dereferenced weakref is passed as the first argument. If arg has been\r\n    deleted then the function is not called.\r\n    \"\"\"\r\n    weak_arg = weakref.ref(arg)\r\n\r\n    def decorator(function):\r\n\r\n        def wrapper0():\r\n            arg = weak_arg()\r\n            if arg is not None:\r\n                return function(arg)\r\n\r\n        def wrapper1(arg1):\r\n            arg = weak_arg()\r\n            if arg is not None:\r\n                return function(arg, arg1)\r\n\r\n        def wrapper2(arg1, arg2):\r\n            arg = weak_arg()\r\n            if arg is not None:\r\n                return function(arg, arg1, arg2)\r\n\r\n        def wrapper3(arg1, arg2, arg3):\r\n            arg = weak_arg()\r\n            if arg is not None:\r\n                return function(arg, arg1, arg2, arg3)\r\n\r\n        def wrapper4(arg1, arg2, arg3, arg4):\r\n            arg = weak_arg()\r\n            if arg is not None:\r\n                return function(arg, arg1, arg2, arg3, arg4)\r\n\r\n        def wrappern(*args):\r\n            arg = weak_arg()\r\n            if arg is not None:\r\n                function(arg, *args)\r\n        args = function.__code__.co_argcount - 1\r\n        if args == 0:\r\n            return wrapper0\r\n        elif args == 1:\r\n            return wrapper1\r\n        elif args == 2:\r\n            return wrapper2\r\n        elif args == 3:\r\n            return wrapper3\r\n        elif args == 4:\r\n            return wrapper4\r\n        else:\r\n            return wrappern\r\n    return decorator\r\n\r\nclass HasTraits(CHasTraits, metaclass=MetaHasTraits):\r\n    \"\"\" Enables any Python class derived from it to have trait attributes.\r\n\r\n    Most of the methods of HasTraits operated by default only on the trait\r\n    attributes explicitly defined in the class definition. They do not operate\r\n    on trait attributes defined by way of wildcards or by calling\r\n    **add_trait()**.\r\n    For example::\r\n\r\n        >>> class Person(HasTraits):\r\n        ...     name = Str\r\n        ...     age  = Int\r\n        ...     temp_ = Any\r\n        >>> bob = Person()\r\n        >>> bob.temp_lunch = 'sandwich'\r\n        >>> bob.add_trait('favorite_sport', Str('football'))\r\n        >>> print(bob.trait_names())\r\n        ['trait_added', 'age', 'name']\r\n\r\n    In this example, the trait_names() method returns only the *age* and\r\n    *name* attributes defined on the Person class. (The **trait_added**\r\n    attribute is an explicit trait event defined on the HasTraits class.)\r\n    The wildcard attribute *temp_lunch* and the dynamically-added trait\r\n    attribute *favorite_sport* are not listed.\r\n\r\n    Subclass should avoid defining new traits and/or methods with names\r\n    starting with \"trait\" or \"_trait\" to avoid overshadowing existing methods,\r\n    unless it has been documented as being safe to do so.\r\n    \"\"\"\r\n    _traits_cache__ = Any(private=True, transient=True)\r\n    wrappers = {'same': TraitChangeNotifyWrapper, 'extended': ExtendedTraitChangeNotifyWrapper, 'new': NewTraitChangeNotifyWrapper, 'fast_ui': FastUITraitChangeNotifyWrapper, 'ui': FastUITraitChangeNotifyWrapper}\r\n    trait_added = Event(Str())\r\n    trait_modified = Event()\r\n\r\n    def _trait_added_changed(self, name):\r\n        \"\"\" Handles a 'trait_added' event being fired.\r\n        \"\"\"\r\n        trait = self.trait(name)\r\n        if trait.type == 'delegate' and name[-6:] != '_items':\r\n            self._init_trait_delegate_listener(name, 'delegate', get_delegate_pattern(name, trait))\r\n\r\n    @classmethod\r\n    def add_class_trait(cls, name, *trait):\r\n        \"\"\" Adds a named trait attribute to this class.\r\n\r\n        Also adds the same attribute to all subclasses.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the attribute to add.\r\n        *trait :\r\n            A trait or a value that can be converted to a trait using Trait()\r\n            Trait definition of the attribute. It can be a single value or\r\n            a list equivalent to an argument list for the Trait() function.\r\n\r\n        \"\"\"\r\n        if len(trait) == 0:\r\n            raise ValueError('No trait definition was specified.')\r\n        if len(trait) > 1:\r\n            trait = Trait(*trait)\r\n        else:\r\n            trait = trait_for(trait[0])\r\n        cls._add_class_trait(name, trait, is_subclass=False)\r\n        for subclass in cls.trait_subclasses(True):\r\n            subclass._add_class_trait(name, trait, is_subclass=True)\r\n\r\n    @classmethod\r\n    def _add_class_trait(cls, name, trait, is_subclass):\r\n        \"\"\"\r\n        Add a named trait attribute to this class.\r\n\r\n        Does not affect subclasses.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the attribute to add.\r\n        trait : CTrait\r\n            The trait to be added.\r\n        is_subclass : bool\r\n            True if we're adding the trait to a strict subclass of the\r\n            original class that add_class_trait was called for. This is used\r\n            to decide how to behave if ``cls`` already has a trait named\r\n            ``name``: in that circumstance, if ``is_subclass`` is False, an\r\n            error will be raised, while if ``is_subclass`` is True, no trait\r\n            will be added.\r\n\r\n        Raises\r\n        ------\r\n        TraitError\r\n"]
[144.287897, "o", "            If a trait with the given name already exists, and is_subclass\r\n            is ``False``.\r\n        \"\"\"\r\n        class_dict = cls.__dict__\r\n        prefix_traits = class_dict[PrefixTraits]\r\n        if name[-1:] == '_':\r\n            name = name[:-1]\r\n            if name in prefix_traits:\r\n                if is_subclass:\r\n                    return\r\n                raise TraitError(\"The '%s_' trait is already defined.\" % name)\r\n            prefix_traits[name] = trait\r\n            prefix_list = prefix_traits['*']\r\n            prefix_list.append(name)\r\n            prefix_list.sort(key=len, reverse=True)\r\n            return\r\n        class_traits = class_dict[ClassTraits]\r\n        if class_traits.get(name) is not None:\r\n            if is_subclass:\r\n                return\r\n            raise TraitError(\"The '%s' trait is already defined.\" % name)\r\n        handler = trait.handler\r\n        if handler is not None:\r\n            if handler.has_items:\r\n                cls._add_class_trait(name + '_items', handler.items_event(), is_subclass=is_subclass)\r\n            if handler.is_mapped:\r\n                cls._add_class_trait(name + '_', mapped_trait_for(trait, name), is_subclass=is_subclass)\r\n        if trait.is_base is not False:\r\n            class_dict[BaseTraits][name] = trait\r\n        handlers = [_get_method(cls, '_%s_changed' % name), _get_method(cls, '_%s_fired' % name)]\r\n        _add_event_handlers(trait, cls, handlers)\r\n        handlers.append(prefix_traits.get('@'))\r\n        handlers = [h for h in handlers if h is not None]\r\n        if len(handlers) > 0:\r\n            trait = _clone_trait(trait)\r\n            _add_notifiers(trait._notifiers(True), handlers)\r\n        class_traits[name] = trait\r\n\r\n    @classmethod\r\n    def set_trait_dispatch_handler(cls, name, klass, override=False):\r\n        \"\"\" Sets a trait notification dispatch handler.\r\n        \"\"\"\r\n        try:\r\n            if issubclass(klass, TraitChangeNotifyWrapper):\r\n                if not override and name in cls.wrappers:\r\n                    raise TraitError(\"A dispatch handler called '%s' has already been defined.\" % name)\r\n                cls.wrappers[name] = klass\r\n                return\r\n        except TypeError:\r\n            pass\r\n        raise TraitError('%s is not a subclass of TraitChangeNotifyWrapper.' % klass)\r\n\r\n    @classmethod\r\n    def trait_subclasses(cls, all=False):\r\n        \"\"\" Returns a list of the immediate (or all) subclasses of this class.\r\n\r\n        Parameters\r\n        ----------\r\n        all : bool\r\n            Indicates whether to return all subclasses of this class. If\r\n            False, only immediate subclasses are returned.\r\n\r\n        \"\"\"\r\n        if not all:\r\n            return cls.__subclasses__()\r\n        return cls._trait_subclasses([])\r\n\r\n    @classmethod\r\n    def _trait_subclasses(cls, subclasses):\r\n        for subclass in cls.__subclasses__():\r\n            if subclass not in subclasses:\r\n                subclasses.append(subclass)\r\n                subclass._trait_subclasses(subclasses)\r\n        return subclasses\r\n\r\n    def has_traits_interface(self, *interfaces):\r\n        \"\"\"Returns whether the object implements a specified traits interface.\r\n\r\n        Tests whether the object implements one or more of the interfaces\r\n        specified by *interfaces*. Return **True** if it does, and **False**\r\n        otherwise.\r\n\r\n        Parameters\r\n        ----------\r\n        *interfaces :\r\n            One or more traits Interface (sub)classes.\r\n        \"\"\"\r\n        return isinstance(self, interfaces)\r\n\r\n    def __getstate__(self):\r\n        \"\"\" Returns a dictionary of traits to pickle.\r\n\r\n        In general, avoid overriding __getstate__ in subclasses. Instead, mark\r\n        traits that should not be pickled with 'transient = True' metadata.\r\n\r\n        In cases where this strategy is not sufficient, override __getstate__\r\n        in subclasses using the following pattern to remove items that should\r\n        not be persisted::\r\n\r\n            def __getstate__(self):\r\n                state = super().__getstate__()\r\n                for k"]
[144.287955, "o", "ey in ['foo', 'bar']:\r\n                    if key in state:\r\n                        del state[key]\r\n                return state\r\n        \"\"\"\r\n        result = self.trait_get(transient=is_none)\r\n        dic = self.__dict__\r\n        result.update(dict([(name, dic[name]) for name in self.trait_names(type='delegate', transient=False) if name in dic]))\r\n        if self.has_traits_interface(ISerializable):\r\n            for (name, value) in result.items():\r\n                if not _is_serializable(value):\r\n                    raise TraitError(\"The '%s' trait of a '%s' instance contains the unserializable value: %s\" % (name, self.__class__.__name__, value))\r\n        result.setdefault('__traits_version__', TraitsVersion)\r\n        return result\r\n\r\n    def __reduce_ex__(self, protocol):\r\n        return (__newobj__, (self.__class__,), self.__getstate__())\r\n\r\n    def __setstate__(self, state, trait_change_notify=True):\r\n        \"\"\" Restores the previously pickled state of an object.\r\n        \"\"\"\r\n        pop = state.pop\r\n        if pop('__traits_version__', None) is None:\r\n            values = [(name, pop(name)) for name in pop('__HasTraits_restore__', [])]\r\n            self.__dict__.update(state)\r\n            self.trait_set(trait_change_notify=trait_change_notify, **dict(values))\r\n        else:\r\n            self._init_trait_listeners()\r\n            self._init_trait_observers()\r\n            self.trait_set(trait_change_notify=trait_change_notify, **state)\r\n            self._post_init_trait_listeners()\r\n            self._post_init_trait_observers()\r\n            self.traits_init()\r\n        self._trait_set_inited()\r\n\r\n    def trait_get(self, *names, **metadata):\r\n        \"\"\" Retrieve trait values for one or more traits.\r\n\r\n        This function can be called in one of three ways. In the first form,\r\n        the user passes the names of one or more traits to be retrieved::\r\n\r\n            my_object.trait_get(\"trait_name1\", \"trait_name2\")\r\n\r\n        In the second form, the user passes a list of zero or more names of\r\n        traits::\r\n\r\n            my_object.trait_get([\"trait_name1\", \"trait_name2\"])\r\n\r\n        In the final form, no trait names are passed, and all trait names\r\n        and trait values are returned, subject to the given metadata filters::\r\n\r\n            my_object.trait_get(transient=True, frombicated=False)\r\n\r\n        In all cases, a dictionary mapping trait names to trait values is\r\n        returned.\r\n\r\n        For the first two forms, if any name does not correspond to a defined\r\n        trait, it is not included in the result.\r\n\r\n        Parameters\r\n        ----------\r\n        *names\r\n            Names of the traits to look up, or a single positional argument\r\n            providing a sequence of trait names.\r\n        **metadata\r\n            Metadata information used to filter the traits to return. This\r\n            information is used only when no names are provided.\r\n\r\n        Returns\r\n        -------\r\n        result : dict\r\n            A dictionary mapping the selected trait names to their\r\n            corresponding values.\r\n        \"\"\"\r\n        result = {}\r\n        n = len(names)\r\n        if n == 1 and type(names[0]) in SequenceTypes:\r\n            names = names[0]\r\n        elif n == 0:\r\n            names = self.trait_names(**metadata)\r\n        missing = object()\r\n        for name in names:\r\n            value = getattr(self, name, missing)\r\n            if value is not missing:\r\n                result[name] = value\r\n        return result\r\n\r\n    def trait_set(self, trait_change_notify=True, **traits):\r\n        \"\"\" Shortcut for setting object trait attributes.\r\n\r\n        Treats each keyword argument to the method as the name of a trait\r\n        attribute and sets the corresponding trait attribute to the value\r\n        specified. This is a useful shorthand when a number of trait attributes\r\n        need to be set on an object, or a trait attribute value needs to be set\r\n        in a lambda function. For example, you can write::\r\n\r\n            person.trait_set(name='Bill', age=27)\r\n\r\n        instead of::\r\n\r\n            pers"]
[144.288881, "o", "on.name = 'Bill'\r\n            person.age = 27\r\n\r\n        Parameters\r\n        ----------\r\n        trait_change_notify : bool\r\n            If **True** (the default), then each value assigned may generate a\r\n            trait change notification. If **False**, then no trait change\r\n            notifications will be generated. (see also: trait_setq)\r\n        **traits :\r\n            Key/value pairs, the trait attributes and their values to be\r\n            set\r\n\r\n        Returns\r\n        -------\r\n        self :\r\n            The method returns this object, after setting attributes.\r\n        \"\"\"\r\n        if not trait_change_notify:\r\n            self._trait_change_notify(False)\r\n            try:\r\n                for (name, value) in traits.items():\r\n                    setattr(self, name, value)\r\n            finally:\r\n                self._trait_change_notify(True)\r\n        else:\r\n            for (name, value) in traits.items():\r\n                setattr(self, name, value)\r\n        return self\r\n\r\n    def trait_setq(self, **traits):\r\n        \"\"\" Shortcut for setting object trait attributes.\r\n\r\n        Treats each keyword argument to the method as the name of a trait\r\n        attribute and sets the corresponding trait attribute to the value\r\n        specified. This is a useful shorthand when a number of trait attributes\r\n        need to be set on an object, or a trait attribute value needs to be set\r\n        in a lambda function. For example, you can write::\r\n\r\n            person.trait_setq(name='Bill', age=27)\r\n\r\n        instead of::\r\n\r\n            person.name = 'Bill'\r\n            person.age = 27\r\n\r\n        Parameters\r\n        ----------\r\n        **traits :\r\n            Key/value pairs, the trait attributes and their values to be set.\r\n            No trait change notifications will be generated for any values\r\n            assigned (see also: trait_set).\r\n\r\n        Returns\r\n        -------\r\n        self :\r\n            The method returns this object, after setting attributes.\r\n        \"\"\"\r\n        return self.trait_set(trait_change_notify=False, **traits)\r\n\r\n    def reset_traits(self, traits=None, **metadata):\r\n        \"\"\" Resets some or all of an object's trait attributes to their default\r\n        values.\r\n\r\n        Resets each of the traits whose names are specified in the *traits*\r\n        list to their default values. If *traits* is None or omitted, the\r\n        method resets all explicitly-defined object trait attributes to their\r\n        default values. Note that this does not affect wildcard trait\r\n        attributes or trait attributes added via add_trait(), unless they are\r\n        explicitly named in *traits*.\r\n\r\n        Parameters\r\n        ----------\r\n        traits : list of strings\r\n            Names of trait attributes to reset.\r\n\r\n        Returns\r\n        -------\r\n        unresetable : list of strings\r\n            A list of attributes that the method was unable to reset, which is\r\n            empty if all the attributes were successfully reset.\r\n        \"\"\"\r\n        unresetable = []\r\n        if traits is None:\r\n            traits = self.trait_names(**metadata)\r\n        for name in traits:\r\n            try:\r\n                delattr(self, name)\r\n            except (AttributeError, TraitError):\r\n                unresetable.append(name)\r\n        return unresetable\r\n\r\n    def copyable_trait_names(self, **metadata):\r\n        \"\"\" Returns the list of trait names to copy or clone by default.\r\n        \"\"\"\r\n        metadata.setdefault('transient', lambda t: t is not True)\r\n        return self.trait_names(**metadata)\r\n\r\n    def __dir__(self):\r\n        \"\"\" Returns the list of trait names when calling the dir() builtin on\r\n            the object. This enables tab-completion in IPython.\r\n        \"\"\"\r\n        return super().__dir__() + self.trait_names()\r\n\r\n    def clone_traits(self, traits=None, memo=None, copy=None, **metadata):\r\n    def __deepcopy__(self, memo):\r\n        pass\r\n\r\n    def copy_traits(self, traits=None, memo=None):\r\n        pass\r\n\r\n    def all_trait_names(self):\r\n        pass\r\n\r\n    def base_trait(self, name):\r\n        pass\r\n        \"\"\"\r\n        TODO: Implement this function\r\n        \"\"\"\r\n        ...\r\n\r\n    def edit_traits(self, view=None, parent=None, kind=None, context=None, handler=None, id='', scrollable=None, **args):\r\n        \"\"\" Displays a user interface window for editing trait attribute\r\n        values.\r\n\r\n        Parameters\r\n        ----------\r\n        view : View or string\r\n            A View object (or its name) that defines a user interface for\r\n            editing trait attribute values of the current object. If the view\r\n            is defined as an attribute on this class, use the name of the\r\n            attribute. Otherwise, use a reference to the view object. If this\r\n            attribute is not specified, the View object returned by\r\n            trait_view() is used.\r\n        parent : toolkit control\r\n            The reference to a user interface component to use as the parent\r\n            window for the object's UI window.\r\n        kind : str\r\n            The type of user interface window to create. See the\r\n            **traitsui.view.kind_trait** trait for values and\r\n            their meanings. If *kind* is unspecified or None, the **kind**\r\n            attribute of the View object is used.\r\n        context : object or dictionary\r\n            A single object or a dictionary of string/object pairs, whose trait\r\n            attributes are to be edited. If not specified, the current object\r\n            is used.\r\n        handler : Handler\r\n            A handler object used for event handling in the dialog box. If\r\n            None, the default handler for Traits UI is used.\r\n        id : str\r\n            A unique ID for persisting preferences about this user interface,\r\n            such as size and position. If not specified, no user preferences\r\n            are saved.\r\n        scrollable : bool\r\n            Indicates whether the dialog box should be scrollable. When set to\r\n            True, scroll bars appear on the dialog box if it is not large\r\n            enough to display all of the items in the view at one time.\r\n\r\n        Returns\r\n        -------\r\n        A UI object.\r\n        \"\"\"\r\n        if context is None:\r\n            context = self\r\n        view = self.trait_view(view)\r\n        return view.ui(context, parent, kind, self.trait_view_elements(), handler, id, scrollable, args)\r\n\r\n    def trait_context(self):\r\n        \"\"\" Returns the default context to use for editing or configuring\r\n            traits.\r\n        \"\"\"\r\n        return {'object': self}\r\n\r\n    def trait_view(self, name=None, view_element=None):\r\n        \"\"\" Gets or sets a ViewElement associated with an object's class.\r\n\r\n        If both *name* and *view_element* are specified, the view element is\r\n        associated with *name* for the current object's class. (That is,\r\n        *view_element* is added to the ViewElements object associated with\r\n        the current object's class, indexed by *name*.)\r\n\r\n        If only *name* is specified, the function returns the view element\r\n        object associated with *name*, or None if *name* has no associated\r\n        view element. View elements retrieved by this function are those that\r\n        are bound to a class attribute in the class definition, or that are\r\n        associated with a name by a previous call to this method.\r\n\r\n        If neither *name* nor *view_element* is specified, the method returns a\r\n        View object, based on the following order of preference:\r\n\r\n        1. If there is a View object named ``traits_view`` associated with the\r\n           current object, it is returned.\r\n        2. If there is exactly one View object associated the current\r\n           object, it is returned.\r\n        3. Otherwise, it returns a View object containing items for all the\r\n           non-event trait attributes on the current object.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of a view element\r\n        view_element : ViewElement\r\n            View element to associate\r\n\r\n        Returns\r\n        -------\r\n        A view element.\r\n        \"\"\"\r\n        return self.__class__._trait_view(name, view_element, self.default_traits_view, self.trait_view_elements, self.visible_traits, self)\r\n\r\n    @classmethod\r\n    def class_trait_view(cls, name=None, view_element=None):\r\n        return cls._trait_view(name, view_element, cls.class_default_traits_view, cls.class_trait_view_elements, cls.class_visible_traits, None)\r\n\r\n    @classmethod\r\n    def _trait_view(cls, name, view_element, default_name, view_elements, trait_selector_f, handler):\r\n        \"\"\" Gets or sets a ViewElement associated with an object's class.\r\n        \"\"\"\r\n        if isinstance(name, AbstractViewElement):\r\n            return name\r\n        view_elements = view_elements()\r\n        if view_elements is None:\r\n            return None\r\n        if name:\r\n            if view_element is None:\r\n                result = view_elements.find(name)\r\n                if result is None and handler is not None:\r\n                    method = getattr(handler, name, None)\r\n                    if callable(method):\r\n                        result = method()\r\n                return result\r\n            view_elements.content[name] = view_element\r\n            return None\r\n        name = default_name()\r\n        if isinstance(name, AbstractViewElement):\r\n            return name\r\n        names = view_elements.filter_by()\r\n        if name in names:\r\n            return view_elements.find(name)\r\n        if handler is not None:\r\n            method = getattr(handler, name, None)\r\n            if callable(method):\r\n                result = method()\r\n                if isinstance(result, AbstractViewElement):\r\n                    return result\r\n        if len(names) == 1:\r\n            return view_elements.find(names[0])\r\n        from traitsui.api import View\r\n        return View(trait_selector_f(), buttons=['OK', 'Cancel'])\r\n\r\n    def default_traits_view(self):\r\n        \"\"\" Returns the name of the default traits view for the object's class.\r\n        \"\"\"\r\n        return self.__class__.class_default_traits_view()\r\n\r\n    @classmethod\r\n    def class_default_traits_view(cls):\r\n        \"\"\" Returns the name of the default traits view for the class.\r\n        \"\"\"\r\n        return DefaultTraitsView\r\n\r\n    def trait_views(self, klass=None):\r\n        \"\"\" Returns a list of the names of all view elements associated with\r\n        the current object's class.\r\n\r\n        If *klass* is specified, the list of names is filtered such that only\r\n        objects that are instances of the specified class are returned.\r\n\r\n        Parameters\r\n        ----------\r\n        klass : class\r\n            A class, such that all returned names must correspond to instances\r\n            of this class. Possible values include:\r\n\r\n            * Group\r\n            * Item\r\n            * View\r\n            * ViewElement\r\n            * ViewSubElement\r\n        \"\"\"\r\n        view_elements = self.__class__.__dict__[ViewTraits]\r\n        if isinstance(view_elements, dict):\r\n            view_elements = self._init_trait_view_elements()\r\n        return view_elements.filter_by(klass)\r\n\r\n    def trait_view_elements(self):\r\n        \"\"\" Returns the ViewElements object associated with the object's\r\n        class.\r\n\r\n        The returned object can be used to access all the view elements\r\n        associated with the class.\r\n        \"\"\"\r\n        return self.__class__.class_trait_view_elements()\r\n\r\n    @classmethod\r\n    def class_trait_view_elements(cls):\r\n        \"\"\" Returns the ViewElements object associated with the class.\r\n\r\n        The returned object can be used to access all the view elements\r\n        associated with the class.\r\n        \"\"\"\r\n        view_elements = cls.__dict__[ViewTraits]\r\n        if isinstance(view_elements, dict):\r\n            view_elements = cls._init_trait_view_elements()\r\n        return view_elements\r\n\r\n    @classmethod\r\n    def _init_trait_view_elements(cls):\r\n        \"\"\" Lazily Initialize the ViewElements object from a dictionary. \"\"\"\r\n        from traitsui.view_elements import ViewElements\r\n        hastraits_bases = [base for base in cls.__bases__ if ClassTraits in base.__dict__]\r\n        view_elements = ViewElements()\r\n        elements_dict = cls.__dict__[ViewTraits]\r\n        for (name, element) in elements_dict.items():\r\n            if name in view_elements.content:\r\n                raise TraitError(\"Duplicate definition for view element '%s'\" % name)\r\n            view_elements.content[name] = element\r\n            element.replace_include(view_elements)\r\n        for base in hastraits_bases:\r\n            parent_view_elements = base.class_trait_view_elements()\r\n            if parent_view_elements is not None:\r\n                view_elements.parents.append(parent_view_elements)\r\n        setattr(cls, ViewTraits, view_elements)\r\n        return view_elements\r\n\r\n    def configure_traits(self, filename=None, view=None, kind=None, edit=None, context=None, handler=None, id='', scrollable=None, **args):\r\n        \"\"\"Creates and displays a dialog box for editing values of trait\r\n        attributes, as if it were a complete, self-contained GUI application.\r\n\r\n        This method is intended for use in applications that do not normally\r\n        have a GUI. Control does not resume in the calling application until\r\n        the user closes the dialog box.\r\n\r\n        The method attempts to open and unpickle the contents of *filename*\r\n        before displaying the dialog box. When editing is complete, the method\r\n        attempts to pickle the updated contents of the object back to\r\n        *filename*. If the file referenced by *filename* does not exist, the\r\n        object is not modified before displaying the dialog box. If *filename*\r\n        is unspecified or None, no pickling or unpickling occurs.\r\n\r\n        If *edit* is True (the default), a dialog box for editing the\r\n        current object is displayed. If *edit* is False or None, no\r\n        dialog box is displayed. You can use ``edit=False`` if you want the\r\n        object to be restored from the contents of *filename*, without being\r\n        modified by the user.\r\n\r\n        Parameters\r\n        ----------\r\n        filename : str\r\n            The name (including path) of a file that contains a pickled\r\n            representation of the current object. When this parameter is\r\n            specified, the method reads the corresponding file (if it exists)\r\n            to restore the saved values of the object's traits before\r\n            displaying them. If the user confirms the dialog box (by clicking\r\n            **OK**), the new values are written to the file. If this parameter\r\n            is not specified, the values are loaded from the in-memory object,\r\n            and are not persisted when the dialog box is closed.\r\n\r\n            .. deprecated:: 6.0.0\r\n\r\n        view : View or str\r\n            A View object (or its name) that defines a user interface for\r\n            editing trait attribute values of the current object. If the view\r\n            is defined as an attribute on this class, use the name of the\r\n            attribute. Otherwise, use a reference to the view object. If this\r\n            attribute is not specified, the View object returned by\r\n            trait_view() is used.\r\n        kind : str\r\n            The type of user interface window to create. See the\r\n            **traitsui.view.kind_trait** trait for values and\r\n            their meanings. If *kind* is unspecified or None, the **kind**\r\n            attribute of the View object is used.\r\n        edit : bool\r\n            Indicates whether to display a user interface. If *filename*\r\n            specifies an existing file, setting *edit* to False loads the\r\n            saved values from that file into the object without requiring\r\n            user interaction.\r\n\r\n            .. deprecated:: 6.2.0\r\n\r\n        context : object or dictionary\r\n            A single object or a dictionary of string/object pairs, whose trait\r\n            attributes are to be edited. If not specified, the current object\r\n            is used\r\n        handler : Handler\r\n            A handler object used for event handling in the dialog box. If\r\n            None, the default handler for Traits UI is used.\r\n        id : str\r\n            A unique ID for persisting preferences about this user interface,\r\n            such as size and position. If not specified, no user preferences\r\n            are saved.\r\n        scrollable : bool\r\n            Indicates whether the dialog box should be scrollable. When set to\r\n            True, scroll bars appear on the dialog box if it is not large\r\n            enough to display all of the items in the view at one time.\r\n\r\n        Returns\r\n        -------\r\n        True on success.\r\n        \"\"\"\r\n        if filename is not None:\r\n            message = 'Restoring from pickle will not be supported starting with traits 7.0.0'\r\n            warnings.warn(message, DeprecationWarning)\r\n            if os.path.exists(filename):\r\n                with open(filename, 'rb') as fd:\r\n                    self.copy_traits(pickle.Unpickler(fd).load())\r\n        if edit is None:\r\n            edit = True\r\n        else:\r\n            message = 'The edit argument to configure_traits is deprecated, and will be removed in Traits 7.0.0'\r\n            warnings.warn(message, DeprecationWarning)\r\n        if edit:\r\n            from traitsui.api import toolkit\r\n            if context is None:\r\n                context = self\r\n            rc = toolkit().view_application(context, self.trait_view(view), kind, handler, id, scrollable, args)\r\n            if rc and filename is not None:\r\n                with open(filename, 'wb') as fd:\r\n                    pickle.Pickler(fd, protocol=3).dump(self)\r\n            return rc\r\n        return True\r\n\r\n    def editable_traits(self):\r\n        \"\"\"Returns an alphabetically sorted list of the names of non-event\r\n        trait attributes associated with the current object.\r\n        \"\"\"\r\n        names = self.trait_names(type=not_event, editable=not_false)\r\n        names.sort()\r\n        return names\r\n\r\n    @classmethod\r\n    def class_editable_traits(cls):\r\n        \"\"\"Returns an alphabetically sorted list of the names of non-event\r\n        trait attributes associated with the current class.\r\n        \"\"\"\r\n        names = cls.class_trait_names(type=not_event, editable=not_false)\r\n        names.sort()\r\n        return names\r\n\r\n    def visible_traits(self):\r\n        \"\"\"Returns an alphabetically sorted list of the names of non-event\r\n        trait attributes associated with the current object, that should be GUI\r\n        visible\r\n        \"\"\"\r\n        return self.trait_names(type=not_event, visible=not_false)\r\n\r\n    @classmethod\r\n    def class_visible_traits(cls):\r\n        \"\"\"Returns an alphabetically sorted list of the names of non-event\r\n        trait attributes associated with the current class, that should be GUI\r\n        visible\r\n        \"\"\"\r\n        return cls.class_trait_names(type=not_event, visible=not_false)\r\n\r\n    def print_traits(self, show_help=False, **metadata):\r\n        \"\"\"Prints the values of all explicitly-defined, non-event trait\r\n        attributes on the current object, in an easily readable format.\r\n\r\n        Parameters\r\n        ----------\r\n        show_help : bool\r\n            Indicates whether to display additional descriptive information.\r\n        \"\"\"\r\n        if len(metadata) > 0:\r\n            names = self.trait_names(**metadata)\r\n        else:\r\n            names = self.trait_names(type=not_event)\r\n        if len(names) == 0:\r\n            print('')\r\n            return\r\n        result = []\r\n        pad = max([len(x) for x in names]) + 1\r\n        maxval = 78 - pad\r\n        names.sort()\r\n        for name in names:\r\n            try:\r\n                value = repr(getattr(self, name)).replace('\\n', '\\\\n')\r\n                if len(value) > maxval:\r\n                    value = '%s...%s' % (value[:(maxval - 2) // 2], value[-((maxval - 3) // 2):])\r\n            except:\r\n                value = '<undefined>'\r\n            lname = (name + ':').ljust(pad)\r\n            if show_help:\r\n                result.append('%s %s\\n   The value must be %s.' % (lname, value, self.base_trait(name).setter.info()))\r\n            else:\r\n                result.append('%s %s' % (lname, value))\r\n        print('\\n'.join(result))\r\n\r\n    def _on_trait_change(self, handler, name=None, remove=False, dispatch='same', priority=False, target=None):\r\n        \"\"\"Causes the object to invoke a handler whenever a trait attribute\r\n        is modified, or removes the association.\r\n\r\n        Multiple handlers can be defined for the same object, or even for the\r\n        same trait attribute on the same object. If *name* is not specified or\r\n        is None, *handler* is invoked when any trait attribute on the\r\n        object is changed.\r\n\r\n        Parameters\r\n        ----------\r\n        handler : function\r\n            A trait notification function for the attribute specified by\r\n            *name*.\r\n        name : str\r\n            Specifies the trait attribute whose value changes trigger the\r\n            notification.\r\n        remove : bool\r\n            If True, removes the previously-set association between\r\n            *handler* and *name*; if False (the default), creates the\r\n            association.\r\n        \"\"\"\r\n        if type(name) is list:\r\n            for name_i in name:\r\n                self._on_trait_change(handler, name_i, remove, dispatch, priority, target)\r\n            return\r\n        name = name or 'anytrait'\r\n        if remove:\r\n            if name == 'anytrait':\r\n                notifiers = self._notifiers(False)\r\n            else:\r\n                trait = self._trait(name, 1)\r\n                if trait is None:\r\n                    return\r\n                notifiers = trait._notifiers(False)\r\n            if notifiers is not None:\r\n                for (i, notifier) in enumerate(notifiers):\r\n                    if notifier.equals(handler):\r\n                        del notifiers[i]\r\n                        notifier.dispose()\r\n                        break\r\n            return\r\n        if name == 'anytrait':\r\n            notifiers = self._notifiers(True)\r\n        else:\r\n            notifiers = self._trait(name, 2)._notifiers(True)\r\n        for notifier in notifiers:\r\n            if notifier.equals(handler):\r\n                break\r\n        else:\r\n            wrapper = self.wrappers[dispatch](handler, notifiers, target)\r\n            if priority:\r\n                notifiers.insert(0, wrapper)\r\n            else:\r\n                notifiers.append(wrapper)\r\n\r\n    def observe(self, handler, expression, *, remove=False, dispatch='same'):\r\n        \"\"\" Causes the object to invoke a handler whenever a trait attribute\r\n        matching a specified pattern is modified, or removes the association.\r\n\r\n        The *expression* parameter can be a single string or an Expression\r\n        object. A list of expressions is also accepted.\r\n\r\n        When *expression* is a string, its content should follow Traits Mini\r\n        Language semantics:\r\n\r\n        ============================== ======================================\r\n        Expression                       Meaning\r\n        ============================== ======================================\r\n        ``item1.item2``                Observes trait *item2* on the object\r\n                                       under trait *item1*.\r\n                                       Changes to either *item1* or *item2*\r\n                                       cause a notification to be fired.\r\n        ``item1:item2``                Similar to the above, except changes\r\n                                       to *item1* will not fire events\r\n                                       (the ':' indicates no notifications).\r\n        ``[item1, item2, ..., itemN]`` A list which matches any of the\r\n                                       specified items. Each item can itself\r\n                                       be an expression.\r\n        ``items``                      Special keyword for observing a trait\r\n                                       named *items* or items inside a list /\r\n                                       dict / set.\r\n        ``+metadata_name``             Matches any trait on the object having\r\n                                       *metadata_name* metadata.\r\n        ============================== ======================================\r\n\r\n        All spaces will be ignored.\r\n\r\n        The :py:class:`ObserverExpression` object supports\r\n        the above features and more.\r\n\r\n        Parameters\r\n        ----------\r\n        handler : callable(event)\r\n            A callable that will be invoked when the observed trait changes.\r\n            It must accept one argument, which is an event object providing\r\n            information about the change.\r\n            See :py:mod:`traits.observation.events` for details.\r\n        expression : str or list or ObserverExpression\r\n            A description of what traits are being observed.\r\n            If this is a list, each item must be a string or an Expression.\r\n        remove : boolean, optional\r\n            Whether to remove the event handler. Default is to add the event\r\n            handler.\r\n        dispatch : str, optional\r\n            A string indicating how the handler should be run.\r\n            Default is to run on the same thread where the change occurs.\r\n\r\n            Possible values are:\r\n\r\n            =========== =======================================================\r\n            value       dispatch\r\n            =========== =======================================================\r\n            ``same``    Run notifications on the same thread where the change\r\n                        occurs. The notifications are executed immediately.\r\n            ``ui``      Run notifications on the UI thread. If the current\r\n                        thread is the UI thread, the notifications are executed\r\n                        immediately; otherwise, they are placed on the UI\r\n                        event queue.\r\n            =========== =======================================================\r\n\r\n        Raises\r\n        ------\r\n        NotifierNotFound\r\n            When attempting to remove a handler that doesn't exist.\r\n        \"\"\"\r\n        graphs = _compile_expression(expression)\r\n        observe_api.apply_observers(object=self, graphs=graphs, handler=handler, dispatcher=_ObserverDispatchers[dispatch], remove=remove)\r\n\r\n    def on_trait_change(self, handler, name=None, remove=False, dispatch='same', priority=False, deferred=False, target=None):\r\n        \"\"\"Causes the object to invoke a handler whenever a trait attribute\r\n        matching a specified pattern is modified, or removes the association.\r\n\r\n        Multiple handlers can be defined for the same object, or even for the\r\n        same trait attribute on the same object. If *name* is not specified or\r\n        is None, *handler* is invoked when any trait attribute on the\r\n        object is changed.\r\n\r\n        The *name* parameter is a single *xname* or a list of *xname* names,\r\n        where an *xname* is an extended name of the form::\r\n\r\n            xname2[('.'|':') xname2]*\r\n\r\n        An *xname2* is of the form::\r\n\r\n            (xname3 | '['xname3[','xname3]*']') ['*']\r\n\r\n        An *xname3* is of the form::\r\n\r\n            xname | ['+'|'-'][name] | name['?' | ('+'|'-')[name]]\r\n\r\n        A *name* is any valid Python attribute name. The semantic meaning of\r\n        this notation is as follows:\r\n\r\n        ================================ ======================================\r\n        expression                       meaning\r\n        ================================ ======================================\r\n        ``item1.item2``                  means *item1* is a trait containing an\r\n                                         object (or objects if *item1* is a\r\n                                         list or dict) with a trait called\r\n                                         *item2*. Changes to either *item1* or\r\n                                         *item2* cause a notification to be\r\n                                         generated.\r\n        ``item1:item2``                  means *item1* is a trait containing an\r\n                                         object (or objects if *item1* is a\r\n                                         list or dict) with a trait called\r\n                                         *item2*. Changes to *item2* cause a\r\n                                         notification to be generated, while\r\n                                         changes to *item1* do not (i.e., the\r\n                                         ':' indicates that changes to the\r\n                                         *link* object should not be reported).\r\n        ``[item1, item2, ..., itemN]``   A list which matches any of the\r\n                                         specified items. Note that at the\r\n                                         topmost level, the surrounding square\r\n                                         brackets are optional.\r\n        ``name?``                        If the current object does not have an\r\n                                         attribute called *name*, the reference\r\n                                         can be ignored. If the '?' character\r\n                                         is omitted, the current object must\r\n                                         have a trait called *name*, otherwise\r\n                                         an exception will be raised.\r\n        ``prefix+``                      Matches any trait on the object whose\r\n                                         name begins with *prefix*.\r\n        ``+metadata_name``               Matches any trait on the object having\r\n                                         *metadata_name* metadata.\r\n        ``-metadata_name``               Matches any trait on the object which\r\n                                         does not have *metadata_name*\r\n                                         metadata.\r\n        ``prefix+metadata_name``         Matches any trait on the object whose\r\n                                         name begins with *prefix* and which\r\n                                         has *metadata_name* metadata.\r\n        ``prefix-metadata_name``         Matches any trait on the object\r\n                                         whose name begins with *prefix* and\r\n                                         which does not have *metadata_name*\r\n                                         metadata.\r\n        ``+``                            Matches all traits on the object.\r\n        ``pattern*``                     Matches object graphs where *pattern*\r\n                                         occurs one or more times (useful for\r\n                                         setting up listeners on recursive data\r\n                                         structures like trees or linked\r\n                                         lists).\r\n        ================================ ======================================\r\n\r\n        Some examples of valid names and their meaning are as follows:\r\n\r\n        ======================= ===============================================\r\n        example                 meaning\r\n        ======================= ===============================================\r\n        ``foo,bar,baz``         Listen for trait changes to *object.foo*,\r\n                                *object.bar*, and *object.baz*.\r\n        ``['foo','bar','baz']`` Equivalent to 'foo,bar,baz', but may be more\r\n                                useful in cases where the individual items are\r\n                                computed.\r\n        ``foo.bar.baz``         Listen for trait changes to\r\n                                *object.foo.bar.baz* and report changes to\r\n                                *object.foo*, *object.foo.bar* or\r\n                                *object.foo.bar.baz*.\r\n        ``foo:bar:baz``         Listen for changes to *object.foo.bar.baz*, and\r\n                                only report changes to *object.foo.bar.baz*.\r\n        ``foo.[bar,baz]``       Listen for trait changes to *object.foo.bar*\r\n                                and *object.foo.baz*.\r\n        ``[left,right]*.name``  Listen for trait changes to the *name* trait of\r\n                                each node of a tree having *left* and *right*\r\n                                links to other tree nodes, and where *object*\r\n                                the method is applied to the root node of the\r\n                                tree.\r\n        ``+dirty``              Listen for trait changes on any trait in the\r\n                                *object* which has the 'dirty' metadata set.\r\n        ``foo.+dirty``          Listen for trait changes on any trait in\r\n                                *object.foo* which has the 'dirty' metadata\r\n                                set.\r\n        ``foo.[bar,-dirty]``    Listen for trait changes on *object.foo.bar* or\r\n                                any trait on *object.foo* which does not have\r\n                                'dirty' metadata set.\r\n        ======================= ===============================================\r\n\r\n\r\n        Note that any of the intermediate (i.e., non-final) links in a\r\n        pattern can be traits of type Instance, List or Dict. In the case\r\n        of List and Dict traits, the subsequent portion of the pattern is\r\n        applied to each item in the list, or value in the dictionary.\r\n\r\n        For example, if the self.children is a list, 'children.name'\r\n        listens for trait changes to the *name* trait for each item in the\r\n        self.children list.\r\n\r\n        Note that items added to or removed from a list or dictionary in\r\n        the pattern will cause the *handler* routine to be invoked as well,\r\n        since this is treated as an *implied* change to the item's trait\r\n        being monitored.\r\n\r\n        The signature of the *handler* supplied also has an effect on\r\n        how changes to intermediate traits are processed. The five valid\r\n        handler signatures are:\r\n\r\n        1. handler()\r\n        2. handler(new)\r\n        3. handler(name,new)\r\n        4. handler(object,name,new)\r\n        5. handler(object,name,old,new)\r\n\r\n        For signatures 1, 4 and 5, any change to any element of a path\r\n        being listened to invokes the handler with information about the\r\n        particular element that was modified (e.g., if the item being\r\n        monitored is 'foo.bar.baz', a change to 'bar' will call *handler*\r\n        with the following information:\r\n\r\n        - object: object.foo\r\n        - name:   bar\r\n        - old:    old value for object.foo.bar\r\n        - new:    new value for object.foo.bar\r\n\r\n"]
[144.288962, "o", "        If one of the intermediate links is a List or Dict, the call to\r\n        *handler* may report an *_items* changed event. If in the previous\r\n        example, *bar* is a List, and a new item is added to *bar*, then\r\n        the information passed to *handler* would be:\r\n\r\n        - object: object.foo\r\n        - name:   bar_items\r\n        - old:    Undefined\r\n        - new:    TraitListEvent whose *added* trait contains the new item\r\n                  added to *bar*.\r\n\r\n        For signatures 2 and 3, the *handler* does not receive enough\r\n        information to discern between a change to the final trait being\r\n        listened to and a change to an intermediate link. In this case,\r\n        the event dispatcher will attempt to map a change to an\r\n        intermediate link to its effective change on the final trait. This\r\n        only works if all of the intermediate links are single values (such\r\n        as an Instance or Any trait) and not Lists or Dicts. If the modified\r\n        intermediate trait or any subsequent intermediate trait preceding\r\n        the final trait is a List or Dict, then a TraitError is raised,\r\n        since the effective value for the final trait cannot in general be\r\n        resolved unambiguously. To prevent TraitErrors in this case, use the\r\n        ':' separator to suppress notifications for changes to any of the\r\n        intermediate links.\r\n\r\n        Handler signature 1 also has the special characteristic that if a\r\n        final trait is a List or Dict, it will automatically handle '_items'\r\n        changed events for the final trait as well. This can be useful in\r\n        cases where the *handler* only needs to know that some aspect of the\r\n        final trait has been changed. For all other *handler* signatures,\r\n        you must explicitly specify the 'xxx_items' trait if you want to\r\n        be notified of changes to any of the items of the 'xxx' trait.\r\n\r\n        Parameters\r\n        ----------\r\n        handler : function\r\n            A trait notification function for the *name* trait attribute, with\r\n            one of the signatures described below.\r\n        name : str\r\n            The name of the trait attribute whose value changes trigger the\r\n            notification. The *name* can specify complex patterns of trait\r\n            changes using an extended *name* syntax, which is described below.\r\n        remove : bool\r\n            If True, removes the previously-set association between\r\n            *handler* and *name*; if False (the default), creates the\r\n            association.\r\n        dispatch : str\r\n            A string indicating the thread on which notifications must be run.\r\n            Possible values are:\r\n\r\n            =========== =======================================================\r\n            value       dispatch\r\n            =========== =======================================================\r\n            ``same``    Run notifications on the same thread as this one.\r\n            ``ui``      Run notifications on the UI thread. If the current\r\n                        thread is the UI thread, the notifications are executed\r\n                        immediately; otherwise, they are placed on the UI\r\n                        event queue.\r\n            ``fast_ui`` Alias for ``ui``.\r\n            ``new``     Run notifications in a new thread.\r\n            =========== =======================================================\r\n\r\n        See Also\r\n        --------\r\n        HasTraits.observe : A newer API for defining traits notifications.\r\n        \"\"\"\r\n        if isinstance(name, str) and extended_trait_pat.match(name) is None or name is None:\r\n            self._on_trait_change(handler, name, remove, dispatch, priority, target)\r\n            return\r\n        from .traits_listener import TraitsListener, ListenerParser, ListenerHandler, ListenerNotifyWrapper\r\n        if isinstance(name, list):\r\n            for name_i in name:\r\n                self.on_trait_change(handler, name=name_i, remove=remove, dispatch=dispatch, priority=priority, deferred=deferred, target=target)\r\n    "]
[144.289631, "o", "        return\r\n        name = (name or 'anytrait').strip()\r\n        if remove:\r\n            dict = self.__dict__.get(TraitsListener)\r\n            if dict is not None:\r\n                listeners = dict.get(name)\r\n                if listeners is not None:\r\n                    for (i, wrapper) in enumerate(listeners):\r\n                        if wrapper.equals(handler):\r\n                            del listeners[i]\r\n                            if len(listeners) == 0:\r\n                                del dict[name]\r\n                                if len(dict) == 0:\r\n                                    del self.__dict__[TraitsListener]\r\n                            wrapper.listener.unregister(self)\r\n                            wrapper.dispose()\r\n                            break\r\n        else:\r\n            dict = self.__dict__.setdefault(TraitsListener, {})\r\n            listeners = dict.setdefault(name, [])\r\n            for wrapper in listeners:\r\n                if wrapper.equals(handler):\r\n                    break\r\n            else:\r\n                lnw = ListenerNotifyWrapper(handler, self, name, None, target)\r\n                listener = ListenerParser(name, handler=ListenerHandler(handler), wrapped_handler_ref=weakref.ref(lnw), dispatch=dispatch, priority=priority, deferred=deferred, handler_type=lnw.type).listener\r\n                lnw.listener = listener\r\n                listener.register(self)\r\n                listeners.append(lnw)\r\n    on_trait_event = on_trait_change\r\n\r\n    def sync_trait(self, trait_name, object, alias=None, mutual=True, remove=False):\r\n        \"\"\"Synchronizes the value of a trait attribute on this object with a\r\n        trait attribute on another object.\r\n\r\n        In mutual synchronization, any change to the value of the specified\r\n        trait attribute of either object results in the same value being\r\n        assigned to the corresponding trait attribute of the other object.\r\n        In one-way synchronization, any change to the value of the attribute\r\n        on this object causes the corresponding trait attribute of *object* to\r\n        be updated, but not vice versa.\r\n\r\n        For ``List`` traits, the list's items are also synchronized, so that\r\n        mutations to this trait's list will be reflected in the synchronized\r\n        list (and vice versa in the case of mutual synchronization). For\r\n        ``Dict`` and ``Set`` traits, items are not synchronized.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the trait attribute on this object.\r\n        object : object\r\n            The object with which to synchronize.\r\n        alias : str\r\n            Name of the trait attribute on *other*; if None or omitted, same\r\n            as *name*.\r\n        mutual : bool or int\r\n            Indicates whether synchronization is mutual (True or non-zero)\r\n            or one-way (False or zero)\r\n        remove : bool or int\r\n            Indicates whether synchronization is being added (False or zero)\r\n            or removed (True or non-zero)\r\n        \"\"\"\r\n        if alias is None:\r\n            alias = trait_name\r\n        is_list = self._is_list_trait(trait_name) and object._is_list_trait(alias)\r\n        if remove:\r\n            info = self._get_sync_trait_info()\r\n            dic = info.get(trait_name)\r\n            if dic is not None:\r\n                key = (id(object), alias)\r\n                if key in dic:\r\n                    del dic[key]\r\n                    if len(dic) == 0:\r\n                        del info[trait_name]\r\n                        self._on_trait_change(self._sync_trait_modified, trait_name, remove=True)\r\n                        if is_list:\r\n                            self._on_trait_change(self._sync_trait_items_modified, trait_name + '_items', remove=True)\r\n            if mutual:\r\n                object.sync_trait(alias, self, trait_name, False, True)\r\n            return\r\n\r\n        def _sync_trait_listener_deleted(ref, info):\r\n            for (key, dic) in list(info.items()):\r\n                if key != '':\r\n                    for (name, value) in list(dic.items()):\r\n                        if ref is value[0]:\r\n                            del dic[name]\r\n                    if len(dic) == 0:\r\n                        del info[key]\r\n        info = self._get_sync_trait_info()\r\n        dic = info.setdefault(trait_name, {})\r\n        key = (id(object), alias)\r\n        callback = lambda ref: _sync_trait_listener_deleted(ref, info)\r\n        value = (weakref.ref(object, callback), alias)\r\n        if key not in dic:\r\n            if len(dic) == 0:\r\n                self._on_trait_change(self._sync_trait_modified, trait_name)\r\n                if is_list:\r\n                    self._on_trait_change(self._sync_trait_items_modified, trait_name + '_items')\r\n            dic[key] = value\r\n            setattr(object, alias, getattr(self, trait_name))\r\n        if mutual:\r\n            object.sync_trait(alias, self, trait_name, False)\r\n\r\n    def _get_sync_trait_info(self):\r\n        info = getattr(self, '__sync_trait__', None)\r\n        if info is None:\r\n            self.__dict__['__sync_trait__'] = info = {}\r\n            info[''] = {}\r\n        return info\r\n\r\n    def _sync_trait_modified(self, object, name, old, new):\r\n        info = self.__sync_trait__\r\n        if name not in info:\r\n            return\r\n        locked = info['']\r\n        locked[name] = None\r\n        for (object, object_name) in info[name].values():\r\n            object = object()\r\n            if object_name not in object._get_sync_trait_info()['']:\r\n                try:\r\n                    setattr(object, object_name, new)\r\n                except:\r\n                    pass\r\n        del locked[name]\r\n\r\n    def _sync_trait_items_modified(self, object, name, old, event):\r\n        n0 = event.index\r\n        n1 = n0 + len(event.removed)\r\n        name = name[:-6]\r\n        info = self.__sync_trait__\r\n        locked = info['']\r\n        locked[name] = None\r\n        for (object, object_name) in info[name].values():\r\n            object = object()\r\n            if object_name not in object._get_sync_trait_info()['']:\r\n                try:\r\n                    getattr(object, object_name)[n0:n1] = event.added\r\n                except:\r\n                    pass\r\n        del locked[name]\r\n\r\n    def _is_list_trait(self, trait_name):\r\n        handler = self.base_trait(trait_name).handler\r\n        return handler is not None and handler.default_value_type == DefaultValue.trait_list_object\r\n\r\n    def add_trait(self, name, *trait):\r\n        \"\"\"Adds a trait attribute to this object.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the attribute to add.\r\n        *trait :\r\n            Trait or a value that can be converted to a trait by Trait().\r\n            Trait definition for *name*. If more than one value is specified,\r\n            it is equivalent to passing the entire list of values to Trait().\r\n\r\n        \"\"\"\r\n        if len(trait) == 0:\r\n            raise ValueError('No trait definition was specified.')\r\n        if len(trait) > 1:\r\n            trait = Trait(*trait)\r\n        else:\r\n            trait = trait_for(trait[0])\r\n        handler = trait.handler\r\n        if handler is not None:\r\n            if handler.has_items:\r\n                self.add_trait(name + '_items', handler.items_event())\r\n            if handler.is_mapped:\r\n                self.add_trait(name + '_', mapped_trait_for(trait, name))\r\n        old_trait = self._trait(name, 0)\r\n        itrait_dict = self._instance_traits()\r\n        itrait_dict[name] = trait = _clone_trait(trait)\r\n        if old_trait is not None:\r\n            old_notifiers = old_trait._notifiers(False)\r\n            if old_notifiers is not None:\r\n                trait._notifiers(True).extend(old_notifiers)\r\n        else:\r\n            cls = self.__class__\r\n            handlers = [_get_method(cls, '_%s_changed' % name), _get_method(cls, '_%s_fired' % name)]\r\n            _add_event_handlers(trait, cls, handlers)\r\n            handlers.append(self.__prefix_traits__.get('@'))\r\n            handlers = [h for h in handlers if h is not None]\r\n            if len(handlers) > 0:\r\n                _add_notifiers(trait._notifiers(True), handlers)\r\n        if old_trait is None:\r\n            self.trait_added = name\r\n\r\n    def remove_trait(self, name):\r\n        \"\"\"Removes a trait attribute from this object.\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the attribute to remove.\r\n\r\n        Returns\r\n        -------\r\n        result : bool\r\n            True if the trait was successfully removed.\r\n        \"\"\"\r\n        trait = self._trait(name, 0)\r\n        if trait is not None:\r\n            handler = trait.handler\r\n            if handler is not None:\r\n                if handler.has_items:\r\n                    self.remove_trait(name + '_items')\r\n                if handler.is_mapped:\r\n                    self.remove_trait(name + '_')\r\n            if name in self.__dict__:\r\n                del self.__dict__[name]\r\n            itrait_dict = self._instance_traits()\r\n            if name in itrait_dict:\r\n                del itrait_dict[name]\r\n                return True\r\n        return False\r\n\r\n    def trait(self, name, force=False, copy=False):\r\n        \"\"\"Returns the trait definition for the *name* trait attribute.\r\n\r\n        If *force* is False (the default) and *name* is the name of an\r\n        implicitly defined trait attribute that has never been referenced\r\n        explicitly (i.e., has not yet been defined), the result is None. In\r\n        all other cases, the result is the trait definition object associated\r\n        with *name*.\r\n\r\n        If *copy* is True, and a valid trait definition is found for *name*,\r\n        a copy of the trait found is returned. In all other cases, the trait\r\n        definition found is returned unmodified (the default).\r\n\r\n        Parameters\r\n        ----------\r\n        name : str\r\n            Name of the attribute whose trait definition is to be returned.\r\n        force : bool\r\n            Indicates whether to return a trait definition if *name* is\r\n            not explicitly defined.\r\n        copy : bool\r\n            Indicates whether to return the original trait definition or a\r\n            copy.\r\n        \"\"\"\r\n        mode = 0\r\n        if force:\r\n            mode = -1\r\n        result = self._trait(name, mode)\r\n        if not copy or result is None:\r\n            return result\r\n        return _clone_trait(result)\r\n\r\n    def validate_trait(self, name, value):\r\n        \"\"\" Validates whether a value is legal for a trait.\r\n\r\n        Returns the validated value if it is valid.\r\n        \"\"\"\r\n        return self.base_trait(name).validate(self, name, value)\r\n\r\n    def traits(self, **metadata):\r\n        \"\"\"Returns a dictionary containing the definitions of all of the trait\r\n        attributes of this object that match the set of *metadata* criteria.\r\n        Note that any traits with a name containing the suffix \"_items\" are\r\n        always excluded.\r\n\r\n        The keys of the returned dictionary are the trait attribute names, and\r\n        the values are their corresponding trait definition objects.\r\n\r\n        If no *metadata* information is specified, then all explicitly defined\r\n        trait attributes defined for the object are returned.\r\n\r\n        Otherwise, the *metadata* keyword dictionary is assumed to define a set\r\n        of search criteria for selecting trait attributes of interest. The\r\n        *metadata* dictionary keys correspond to the names of trait metadata\r\n        attributes to examine, and the values correspond to the values the\r\n        metadata attribute must have in order to be included in the search\r\n        results.\r\n\r\n        The *metadata* values either may be simple Python values like strings\r\n        or integers, or may be lambda expressions or functions that return True\r\n        if the trait attribute is to be included in the result. A lambda\r\n        expression or function must receive a single argument, which is the\r\n        value of the trait metadata attribute being tested. If more than one\r\n        metadata keyword is specified, a trait attribute must match the\r\n        metadata values of all keywords to be included in the result.\r\n\r\n        Parameters\r\n        ----------\r\n        **metadata :\r\n            Criteria for selecting trait attributes.\r\n        \"\"\"\r\n        traits = self.__base_traits__.copy()\r\n        for (name, trt) in self._instance_traits().items():\r\n            if name[-6:] != '_items':\r\n                traits[name] = trt\r\n        for name in self.__dict__.keys():\r\n            if name not in traits:\r\n                trait = self.trait(name)\r\n                if trait is not None:\r\n                    traits[name] = trait\r\n        if len(metadata) == 0:\r\n            return traits\r\n        for (meta_name, meta_eval) in list(metadata.items()):\r\n            if type(meta_eval) is not FunctionType:\r\n                metadata[meta_name] = _SimpleTest(meta_eval)\r\n        result = {}\r\n        for (name, trait) in traits.items():\r\n            for (meta_name, meta_eval) in metadata.items():\r\n                if not meta_eval(getattr(trait, meta_name, None)):\r\n                    break\r\n            else:\r\n                result[name] = trait\r\n        return result\r\n\r\n    @classmethod\r\n    def class_traits(cls, **metadata):\r\n        \"\"\"Returns a dictionary containing the definitions of all of the trait\r\n        attributes of the class that match the set of *metadata* criteria.\r\n\r\n        The keys of the returned dictionary are the trait attribute names, and\r\n        the values are their corresponding trait definition objects.\r\n\r\n        If no *metadata* information is specified, then all explicitly defined\r\n        trait attributes defined for the class are returned.\r\n\r\n        Otherwise, the *metadata* keyword dictionary is assumed to define a set\r\n        of search criteria for selecting trait attributes of interest. The\r\n        *metadata* dictionary keys correspond to the names of trait metadata\r\n        attributes to examine, and the values correspond to the values the\r\n        metadata attribute must have in order to be included in the search\r\n        results.\r\n\r\n        The *metadata* values either may be simple Python values like strings\r\n        or integers, or may be lambda expressions or functions that return\r\n        **True** if the trait attribute is to be included in the result. A\r\n        lambda expression or function must receive a single argument, which is\r\n        the value of the trait metadata attribute being tested. If more than\r\n        one metadata keyword is specified, a trait attribute must match the\r\n        metadata values of all keywords to be included in the result.\r\n\r\n        Parameters\r\n        ----------\r\n        **metadata :\r\n            Criteria for selecting trait attributes.\r\n        \"\"\"\r\n        if len(metadata) == 0:\r\n            return cls.__base_traits__.copy()\r\n        result = {}\r\n        for (meta_name, meta_eval) in list(metadata.items()):\r\n            if type(meta_eval) is not FunctionType:\r\n                metadata[meta_name] = _SimpleTest(meta_eval)\r\n        for (name, trait) in cls.__base_traits__.items():\r\n            for (meta_name, meta_eval) in metadata.items():\r\n                if not meta_eval(getattr(trait, meta_name, None)):\r\n                    break\r\n            else:\r\n                result[name] = trait\r\n        return result\r\n\r\n    def trait_names(self, **metadata):\r\n        \"\"\"Returns a list of the names of all trait attributes whose\r\n        definitions match the set of *metadata* criteria specified.\r\n\r\n        This method is similar to the traits() method, but returns only the\r\n        names of the matching trait attributes, not the trait definitions.\r\n\r\n        Parameters\r\n        ----------\r\n        **metadata :\r\n            Criteria for selecting trait attributes.\r\n        \"\"\"\r\n        return list(self.traits(**metadata).keys())\r\n\r\n    @classmethod\r\n    def class_trait_names(cls, **metadata):\r\n        \"\"\"Returns a list of the names of all trait attributes whose\r\n        definitions match the set of *metadata* criteria specified.\r\n\r\n        This method is similar to the traits() method, but returns only the\r\n        names of the matching trait attributes, not the trait definitions.\r\n\r\n        Parameters\r\n        ----------\r\n        **metadata :\r\n            Criteria for selecting trait attributes.\r\n        \"\"\"\r\n        return list(cls.class_traits(**metadata).keys())\r\n\r\n    def _set_traits_cache(self, name, value):\r\n        \"\"\" Explicitly sets the value of a cached property.\r\n        \"\"\"\r\n        cached = TraitsCache + name\r\n        old_value = self.__dict__.get(cached, Undefined)\r\n        self.__dict__[cached] = value\r\n        if old_value != value:\r\n            self.trait_property_changed(name, old_value, value)\r\n\r\n    def _flush_traits_cache(self, name, value):\r\n        \"\"\" Explicitly flushes the value of a cached property.\r\n        \"\"\"\r\n        self.trait_property_changed(name, self.__dict__.pop(TraitsCache + name, Undefined))\r\n\r\n    def __prefix_trait__(self, name, is_set):\r\n        \"\"\" Return the trait definition for a specified name when there is\r\n        no explicit definition in the class.\r\n        \"\"\"\r\n        if name[:2] == '__' and name[-2:] == '__':\r\n            if name == '__class__':\r\n                return generic_trait\r\n            if is_set:\r\n                return any_trait\r\n            raise AttributeError(\"'%s' object has no attribute '%s'\" % (self.__class__.__name__, name))\r\n        if name[-1:] == '_':\r\n            trait = self._trait(name[:-1], 0)\r\n            if trait is not None and trait.type == 'delegate':\r\n                return _clone_trait(trait)\r\n        prefix_traits = self.__prefix_traits__\r\n        for prefix in prefix_traits['*']:\r\n            if prefix == name[:len(prefix)]:\r\n                trait = prefix_traits[prefix]\r\n                cls = self.__class__\r\n                handlers = [_get_method(cls, '_%s_changed' % name), _get_method(cls, '_%s_fired' % name)]\r\n                _add_event_handlers(trait, cls, handlers)\r\n                handlers.append(prefix_traits.get('@'))\r\n                handlers = [h for h in handlers if h is not None]\r\n                if len(handlers) > 0:\r\n                    trait = _clone_trait(trait)\r\n                    _add_notifiers(trait._notifiers(True), handlers)\r\n                return trait\r\n        raise SystemError(\"Trait class look-up failed for attribute '%s' for an object of type '%s'\" % (name, self.__class__.__name__))\r\n\r\n    def add_trait_listener(self, object, prefix=''):\r\n        \"\"\" Add (Java-style) event listener to an object. \"\"\"\r\n        self._trait_listener(object, prefix, False)\r\n\r\n    def remove_trait_listener(self, object, prefix=''):\r\n        \"\"\" Remove (Java-style) event listener to an object. \"\"\"\r\n        self._trait_listener(object, prefix, True)\r\n\r\n    def _trait_listener(self, object, prefix, remove):\r\n        if prefix[-1:] != '_':\r\n            prefix += '_'\r\n        n = len(prefix)\r\n        traits = self.__base_traits__\r\n        for name in self._each_trait_method(object):\r\n            if name[:n] == prefix:\r\n                if name[-8:] == '_changed':\r\n                    short_name = name[n:-8]\r\n                    if short_name in traits:\r\n                        self._on_trait_change(getattr(object, name), short_name, remove=remove)\r\n                    elif short_name == 'anytrait':\r\n                        self._on_trait_change(getattr(object, name), remove=remove)\r\n                elif name[:-6] == '_fired':\r\n                    short_name = name[n:-6]\r\n                    if short_name in traits:\r\n                        self._on_trait_change(getattr(object, name), short_name, remove=remove)\r\n                    elif short_name == 'anytrait':\r\n                        self._on_trait_change(getattr(object, name), remove=remove)\r\n\r\n    def _each_trait_method(self, object):\r\n        \"\"\" Generates each (name, method) pair for a specified object.\r\n        \"\"\"\r\n        dic = {}\r\n        for klass in object.__class__.__mro__:\r\n            for (name, method) in klass.__dict__.items():\r\n                if is_unbound_method_type(method) and name not in dic:\r\n                    dic[name] = True\r\n                    yield name\r\n\r\n    def _instance_changed_handler(self, name, old, new):\r\n        \"\"\" Handles adding/removing listeners for a generic 'Instance' trait.\r\n        \"\"\"\r\n        arg_lists = self._get_instance_handlers(name)\r\n        if old is not None:\r\n            for args in arg_lists:\r\n                old.on_trait_change(*args, remove=True)\r\n        if new is not None:\r\n            for args in arg_lists:\r\n                new.on_trait_change(*args)\r\n\r\n    def _list_changed_handler(self, name, old, new):\r\n        \"\"\" Handles adding/removing listeners for a generic 'List(Instance)'\r\n            trait.\r\n        \"\"\"\r\n        arg_lists = self._get_instance_handlers(name)\r\n        for item in old:\r\n            for args in arg_lists:\r\n                item.on_trait_change(*args, remove=True)\r\n        for item in new:\r\n            for args in arg_lists:\r\n                item.on_trait_change(*args)\r\n\r\n    def _list_items_changed_handler(self, name, not_used, event):\r\n        \"\"\" Handles adding/removing listeners for a generic 'List(Instance)'\r\n            trait.\r\n        \"\"\"\r\n        arg_lists = self._get_instance_handlers(name[:-6])\r\n        for item in event.removed:\r\n            for args in arg_lists:\r\n                item.on_trait_change(*args, remove=True)\r\n        for item in event.added:\r\n            for args in arg_lists:\r\n                item.on_trait_change(*args)\r\n\r\n    def _get_instance_handlers(self, name):\r\n        \"\"\" Returns a list of (name, method) pairs for a specified 'Instance'\r\n            or 'List(Instance)' trait name:\r\n        \"\"\"\r\n        return [(getattr(self, method_name), item_name) for (method_name, item_name) in self.__class__.__instance_traits__[name]]\r\n\r\n    def _post_init_trait_listeners(self):\r\n        \"\"\" Initializes the object's statically parsed, but dynamically\r\n            registered, traits listeners (called at object creation and\r\n            unpickling times).\r\n        \"\"\"\r\n        for (name, data) in self.__class__.__listener_traits__.items():\r\n            if data[0] == 'method':\r\n                config = data[1]\r\n                if config['post_init']:\r\n                    self.on_trait_change(getattr(self, name), config['pattern'], deferred=True, dispatch=config['dispatch'])\r\n\r\n    def _init_trait_listeners(self):\r\n        \"\"\" Initializes the object's statically parsed, but dynamically\r\n            registered, traits listeners (called at object creation and\r\n            unpickling times).\r\n        \"\"\"\r\n        for (name, data) in self.__class__.__listener_traits__.items():\r\n            getattr(self, '_init_trait_%s_listener' % data[0])(name, *data)\r\n\r\n    def _init_trait_method_listener(self, name, kind, config):\r\n        \"\"\" Sets up the listener for a method with the @on_trait_change\r\n            decorator.\r\n        \"\"\"\r\n        if not config['post_init']:\r\n            self.on_trait_change(getattr(self, name), config['pattern'], deferred=True, dispatch=config['dispatch'])\r\n\r\n    def _init_trait_event_listener(self, name, kind, pattern):\r\n        \"\"\" Sets up the listener for an event with on_trait_change metadata.\r\n        \"\"\"\r\n\r\n        @weak_arg(self)\r\n        def notify(self):\r\n            setattr(self, name, True)\r\n        self.on_trait_change(notify, pattern, target=self)\r\n\r\n    def _init_trait_property_listener(self, name, kind, cached, pattern):\r\n        \"\"\" Sets up the listener for a property with 'depends_on' metadata.\r\n        \"\"\"\r\n        if cached is None:\r\n\r\n            @weak_arg(self)\r\n            def notify(self):\r\n                self.trait_property_changed(name, None)\r\n        else:\r\n            cached_old = cached + ':old'\r\n\r\n            @weak_arg(self)\r\n            def pre_notify(self):\r\n                dict = self.__dict__\r\n                old = dict.get(cached_old, Undefined)\r\n                if old is Undefined:\r\n                    dict[cached_old] = dict.pop(cached, None)\r\n            self.on_trait_change(pre_notify, pattern, priority=True, target=self)\r\n\r\n            @weak_arg(self)\r\n            def notify(self):\r\n                old = self.__dict__.pop(cached_old, Undefined)\r\n                if old is not Undefined:\r\n                    self.trait_property_changed(name, old)\r\n        self.on_trait_change(notify, pattern, target=self)\r\n\r\n    def _init_trait_delegate_listener(self, name, kind, pattern):\r\n        \"\"\" Sets up the listener for a delegate trait.\r\n        \"\"\"\r\n        name_pattern = self._trait_delegate_name(name, pattern)\r\n        target_name_len = len(name_pattern.split(':')[-1])\r\n\r\n        @weak_arg(self)\r\n        def notify(self, object, notify_name, old, new):\r\n            self.trait_property_changed(name + notify_name[target_name_len:], old, new)\r\n        self.on_trait_change(notify, name_pattern, target=self)\r\n        self.__dict__.setdefault(ListenerTraits, {})[name] = notify\r\n\r\n    def _remove_trait_delegate_listener(self, name, remove):\r\n        \"\"\" Removes a delegate listener when the local delegate value is set.\r\n        \"\"\"\r\n        dict = self.__dict__.setdefault(ListenerTraits, {})\r\n        if remove:\r\n            if name in dict:\r\n                self.on_trait_change(dict[name], self._trait_delegate_name(name, self.__class__.__listener_traits__[name][1]), remove=True)\r\n                del dict[name]\r\n                if len(dict) == 0:\r\n                    del self.__dict__[ListenerTraits]\r\n            return\r\n        if name not in dict:\r\n            self._init_trait_delegate_listener(name, 0, self.__class__.__listener_traits__[name][1])\r\n\r\n    def _init_trait_observers(self):\r\n        \"\"\" Initialize observers prior to setting object state.\r\n        \"\"\"\r\n        for (name, states) in self.__class__.__observer_traits__.items():\r\n            for state in states:\r\n                if not state['post_init']:\r\n                    observe_api.apply_observers(object=self, handler=state['handler_getter'](self, name), graphs=state['graphs'], dispatcher=_ObserverDispatchers[state['dispatch']])\r\n\r\n    def _post_init_trait_observers(self):\r\n        \"\"\" Initialize observers after setting object state.\r\n        \"\"\"\r\n        for (name, states) in self.__class__.__observer_traits__.items():\r\n            for state in states:\r\n                if state['post_init']:\r\n                    observe_api.apply_observers(object=self, handler=state['handler_getter'](self, name), graphs=state['graphs'], dispatcher=_ObserverDispatchers[state['dispatch']])\r\n\r\n    def _trait_delegate_name(self, name, pattern):\r\n        \"\"\" Returns the fully-formed 'on_trait_change' name for a specified\r\n            delegate.\r\n        \"\"\"\r\n        if pattern[-1] == '*':\r\n            pattern = '%s%s%s' % (pattern[:-1], self.__class__.__prefix__, name)\r\n        return pattern\r\n_HasTraits = HasTraits\r\n\r\nclass HasStrictTraits(HasTraits):\r\n    \"\"\" This class guarantees that any object attribute that does not have an\r\n    explicit or wildcard trait definition results in an exception.\r\n\r\n    This feature can be useful in cases where a more rigorous software\r\n    engineering approach is being used than is typical for Python programs. It\r\n    also helps prevent typos and spelling mistakes in attribute names from\r\n    going unnoticed; a misspelled attribute name typically causes an exception.\r\n    \"\"\"\r\n    _ = Disallow\r\n\r\nclass HasRequiredTraits(HasStrictTraits):\r\n    \"\"\" This class builds on the functionality of HasStrictTraits and ensures\r\n    that any object attribute with `required=True` in its metadata must be\r\n    passed as an argument on object initialization.\r\n\r\n    This can be useful in cases where an object has traits which are required\r\n    for it to function correctly.\r\n\r\n    Raises\r\n    ------\r\n    TraitError\r\n        If a required trait is not passed as an argument.\r\n\r\n    Examples\r\n    --------\r\n    A class with required traits:\r\n\r\n    >>> class RequiredTest(HasRequiredTraits):\r\n    ...     required_trait = Any(required=True)\r\n    ...     non_required_trait = Any()\r\n\r\n    Creating an instance of a HasRequiredTraits subclass:\r\n\r\n    >>> test_instance = RequiredTest(required_trait=13, non_required_trait=11)\r\n    >>> test_instance2 = RequiredTest(required_trait=13)\r\n\r\n    Forgetting to specify a required trait:\r\n\r\n    >>> test_instance = RequiredTest(non_required_trait=11)\r\n    traits.trait_errors.TraitError: The following required traits were not\r\n    provided: required_trait.\r\n    \"\"\"\r\n\r\n    def __init__(self, **traits):\r\n        missing_required_traits = [name for name in self.trait_names(required=True) if name not in traits]\r\n        if missing_required_traits:\r\n            raise TraitError('The following required traits were not provided: {}.'.format(', '.join(sorted(missing_required_traits))))\r\n        super().__init__(**traits)\r\n\r\nclass HasPrivateTraits(HasTraits):\r\n    \"\"\" This class ensures that any public object attribute that does not have\r\n    an explicit or wildcard trait definition results in an exception, but\r\n    \"private\" attributes (whose names start with '_') have an initial value of\r\n    **None**, and are not type-checked.\r\n\r\n    This feature is useful in cases where a class needs private attributes to\r\n    keep track of its internal object state, which are not part of the class's\r\n    public API. Such attributes do not need to be type-checked, because they\r\n    are manipulated only by the (presumably correct) methods of the class\r\n    itself.\r\n    \"\"\"\r\n    __ = Any(private=True, transient=True)\r\n    _ = Disallow\r\n\r\nclass ABCMetaHasTraits(abc.ABCMeta, MetaHasTraits):\r\n    \"\"\" A MetaHasTraits subclass which also inherits from\r\n    abc.ABCMeta.\r\n\r\n    .. note:: The ABCMeta class is cooperative and behaves nicely\r\n        with MetaHasTraits, provided it is inherited first.\r\n    \"\"\"\r\n    pass\r\n\r\nclass ABCHasTraits(HasTraits, metaclass=ABCMetaHasTraits):\r\n    \"\"\" A HasTraits subclass which enables the features of Abstract\r\n    Base Classes (ABC). See the 'abc' module in the standard library\r\n    for more information.\r\n\r\n    \"\"\"\r\n\r\nclass ABCHasStrictTraits(ABCHasTraits):\r\n    \"\"\" A HasTraits subclass which behaves like HasStrictTraits but\r\n    also enables the features of Abstract Base Classes (ABC). See the\r\n    'abc' module in the standard library for more information.\r\n\r\n    \"\"\"\r\n    _ = Disallow\r\n\r\nclass Vetoable(HasStrictTraits):\r\n    \"\"\" Defines a 'vetoable' request object and an associated event.\r\n    \"\"\"\r\n    veto = Bool(False)\r\n\r\n    def _veto_changed(self, state):\r\n        self._trait_veto_notify(state)\r\nVetoableEvent = Event(Vetoable)\r\n\r\nclass MetaInterface(ABCMetaHasTraits):\r\n    \"\"\" Meta class for interfaces.\r\n\r\n    Historically, there were some differences between interfaces\r\n    and ABCs in Traits, but now Interface is a near synonym for\r\n    ABCHasTraits.\r\n    \"\"\"\r\n\r\nclass Interface(HasTraits, metaclass=MetaInterface):\r\n    \"\"\" The base class for all interfaces.\r\n    \"\"\"\r\n\r\ndef provides(*protocols):\r\n    \"\"\" Class decorator to declare the protocols that a class provides.\r\n\r\n    Parameters\r\n    ----------\r\n    *protocols :\r\n        A list of protocols (Interface classes or Python ABCs) that the\r\n        decorated class provides.\r\n\r\n    \"\"\"\r\n    from abc import ABCMeta\r\n    if len(protocols) == 0:\r\n        return lambda klass: klass\r\n    for protocol in protocols:\r\n        if not issubclass(type(protocol), ABCMeta):\r\n            raise TraitError(\"All arguments to 'provides' must be subclasses of Interface or be a Python ABC.\")\r\n\r\n    def wrapped_class(klass):\r\n        for protocol in protocols:\r\n            type(protocol).register(protocol, klass)\r\n        if CHECK_INTERFACES:\r\n            from .interface_checker import check_implements\r\n            warnings.warn('In the future, the @provides decorator will not perform interface checks. Set has_traits.CHECK_INTERFACES to 0 to suppress this warning.', DeprecationWarning, stacklevel=2)\r\n"]
[144.289677, "o", "            check_implements(klass, protocols, CHECK_INTERFACES)\r\n        return klass\r\n    return wrapped_class\r\n\r\ndef isinterface(klass):\r\n    \"\"\" Return True if the class is an Interface. \"\"\"\r\n    return isinstance(klass, MetaInterface)\r\n\r\nclass ISerializable(Interface):\r\n    \"\"\" A class that implemented ISerializable requires that all HasTraits\r\n        objects saved as part of its state also implement ISerializable.\r\n    \"\"\"\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[165.88932, "i", "grep -E 'def (__deepcopy__|copy_traits|all_trait_names|base_trait)' has_traits.py\n"]
[165.889675, "o", "grep -E 'def (__deepcopy__|copy_traits|all_trait_names|base_trait)' has_traits.py\r\n\u001b[?2004l\r"]
[165.891822, "o", "    def __deepcopy__(self, memo):\r\n    def copy_traits(self, traits=None, memo=None):\r\n    def all_trait_names(self):\r\n"]
[165.89188, "o", "    def base_trait(self, name):\r\n"]
[165.892147, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[184.297711, "i", "sed -i 's/pass/raise NotImplementedError(\"Function not implemented\")/' has_traits.py\n"]
[184.298098, "o", "sed -i 's/pass/raise NotImplementedError(\"Function not implemented\")/' has_traits.py\r\n\u001b[?2004l\r"]
[184.301684, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[185.412188, "i", "pytest traits/tests/test_clone.py::CloneTestCase::test_instance -v\n"]
[185.412536, "o", "pytest traits/tests/test_clone.py::CloneTestCase::test_instance -v\r\n\u001b[?2004l\r"]
[185.588131, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[185.590037, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[185.590107, "o", "\u001b[1mcollecting ... \u001b[0m"]
[185.590172, "o", "\u001b[1m\rcollected 0 items                                                                                                                                              \u001b[0m\r\n"]
[185.590906, "o", "\r\n"]
[185.590972, "o", "\u001b[33m==================================================================== \u001b[33mno tests ran\u001b[0m\u001b[33m in 0.00s\u001b[0m\u001b[33m =====================================================================\u001b[0m\r\n"]
[185.60567, "o", "\u001b[31mERROR: file or directory not found: traits/tests/test_clone.py::CloneTestCase::test_instance\r\n\u001b[0m\r\n"]
[185.621679, "o", "\u001b[?2004h"]
[185.621729, "o", "root@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[199.946907, "i", "ls -la traits/tests\n"]
[199.947098, "o", "ls -la traits/tests\r\n\u001b[?2004l\r"]
[199.948482, "o", "ls: cannot access 'traits/tests': No such file or directory\r\n"]
[199.948697, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[215.318434, "i", "find . -name test_clone.py\n"]
[215.318717, "o", "find . -name test_clone.py\r\n\u001b[?2004l\r"]
[215.32155, "o", "./tests/test_clone.py\r\n"]
[215.321915, "o", "\u001b[?2004h"]
[215.32198, "o", "root@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[228.83151, "i", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\n"]
[228.831795, "o", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\r\n\u001b[?2004l\r"]
[228.967389, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[228.969213, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[228.969265, "o", "\u001b[1mcollecting ... \u001b[0m"]
[229.077313, "o", "\u001b[1m\rcollected 0 items / 1 error                                                                                                                                    \u001b[0m\r\n"]
[229.077762, "o", "\r\n"]
[229.077825, "o", "============================================================================ ERRORS ============================================================================\r\n\u001b[31m\u001b[1m_________________________________________________________ ERROR collecting traits/tests/test_clone.py __________________________________________________________\u001b[0m\r\n"]
[229.077895, "o", "\u001b[31m/usr/local/lib/python3.10/site-packages/_pytest/python.py:507: in importtestmodule\r\n    mod = import_path(\r\n/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path\r\n    importlib.import_module(module_name)\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1050: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1027: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:688: in _load_unlocked\r\n    ???\r\n/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:197: in exec_module\r\n    exec(co, module.__dict__)\r\ntests/test_clone.py:13: in <module>\r\n    from traits.api import HasTraits, Instance, Int, Str, Any, Property\r\napi.py:138: in <module>\r\n    from .has_traits import (\r\nE     File \"/workspace/repo/traits/has_traits.py\", line 1071\r\nE       def __deepcopy__(self, memo):\r\nE       ^^^\r\nE   IndentationError: expected an indented block after function definition on line 1070\u001b[0m\r\n"]
[229.07796, "o", "\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_clone.py\r\n"]
[229.078023, "o", "\u001b[31m======================================================================= \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.11s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[229.093714, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/traits/tests/test_clone.py::CloneTestCase::test_instance\r\n\u001b[0m\r\n"]
[229.111076, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[249.053134, "i", "sed -i 's/def __deepcopy__(self, memo):/    def __deepcopy__(self, memo):/' has_traits.py\n"]
[249.053631, "o", "sed -i 's/def __deepcopy__(self, memo):/    def __deepcopy__(self, memo):/' has_traits.py\r\n\u001b[?2004l\r"]
[249.057124, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[250.031125, "i", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\n"]
[250.031709, "o", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\r\n\u001b[?2004l\r"]
[250.163164, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[250.164894, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[250.164964, "o", "\u001b[1mcollecting ... \u001b[0m"]
[250.244743, "o", "\u001b[1m\rcollected 0 items / 1 error                                                                                                                                    \u001b[0m\r\n"]
[250.245107, "o", "\r\n"]
[250.245133, "o", "============================================================================ ERRORS ============================================================================\r\n"]
[250.245187, "o", "\u001b[31m\u001b[1m_________________________________________________________ ERROR collecting traits/tests/test_clone.py __________________________________________________________\u001b[0m\r\n\u001b[31m/usr/local/lib/python3.10/site-packages/_pytest/python.py:507: in importtestmodule\r\n    mod = import_path(\r\n/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path\r\n    importlib.import_module(module_name)\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1050: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1027: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:688: in _load_unlocked\r\n    ???\r\n/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:197: in exec_module\r\n    exec(co, module.__dict__)\r\ntests/test_clone.py:13: in <module>\r\n    from traits.api import HasTraits, Instance, Int, Str, Any, Property\r\napi.py:138: in <module>\r\n"]
[250.24521, "o", "    from .has_traits import (\r\nE     File \"/workspace/repo/traits/has_traits.py\", line 1072\r\nE       raise NotImplementedError(\"Function not implemented\")\r\nE       ^^^^^\r\nE   IndentationError: expected an indented block after function definition on line 1071\u001b[0m\r\n"]
[250.245312, "o", "\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_clone.py\r\n"]
[250.245365, "o", "\u001b[31m======================================================================= \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.08s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[250.26054, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/traits/tests/test_clone.py::CloneTestCase::test_instance\r\n\u001b[0m\r\n"]
[250.278606, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[281.677405, "i", "sed -i 's/raise NotImplementedError(\"Function not implemented\")/        raise NotImplementedError(\"Function not implemented\")/' has_traits.py\n"]
[281.677964, "o", "sed -i 's/raise NotImplementedError(\"Function not implemented\")/        raise NotImplementedError(\"Function not implemented\")/' has_traits.py\r\n\u001b[?2004l\r"]
[281.681614, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[282.483946, "i", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\n"]
[282.484199, "o", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\r\n\u001b[?2004l\r"]
[282.60121, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[282.603058, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[282.603115, "o", "\u001b[1mcollecting ... \u001b[0m"]
[282.679787, "o", "\u001b[1m\rcollected 0 items / 1 error                                                                                                                                    \u001b[0m\r\n"]
[282.680124, "o", "\r\n"]
[282.680174, "o", "============================================================================ ERRORS ============================================================================\r\n\u001b[31m\u001b[1m_________________________________________________________ ERROR collecting traits/tests/test_clone.py __________________________________________________________\u001b[0m\r\n\u001b[31m/usr/local/lib/python3.10/site-packages/_pytest/python.py:507: in importtestmodule\r\n    mod = import_path(\r\n/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path\r\n    importlib.import_module(module_name)\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1050: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1027: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:688: in _load_unlocked\r\n    ???\r\n/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:197: in exec_module\r\n    exec(co, module.__dict__)\r\ntests/test_clone.py:13: in <module>\r\n    from traits.api import HasTraits, Instance, Int, Str, Any, Property\r\napi.py:138: in <module>\r\n    from .has_traits import (\r\nE     File \"/workspace/repo/traits/has_traits.py\", line 1082\r\nE       \"\"\"\r\nE          ^\r\nE   IndentationError: unindent does not match any outer indentation level\u001b[0m\r\n"]
[282.680343, "o", "\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_clone.py\r\n"]
[282.680418, "o", "\u001b[31m======================================================================= \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.08s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[282.696014, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/traits/tests/test_clone.py::CloneTestCase::test_instance\r\n\u001b[0m\r\n"]
[282.713569, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[337.314999, "i", "sed -i 's/def \\(__deepcopy__|copy_traits|all_trait_names|base_trait\\)/    def \\1/' has_traits.py\n"]
[337.315638, "o", "sed -i 's/def \\(__deepcopy__|copy_traits|all_trait_names|base_trait\\)/    def \\1/' has_traits.py\r\n\u001b[?2004l\r"]
[337.317872, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[338.263344, "i", "sed -i 's/raise NotImplementedError(\"Function not implemented\")/        raise NotImplementedError(\"Function not implemented\")/' has_traits.py\n"]
[338.263821, "o", "sed -i 's/raise NotImplementedError(\"Function not implemented\")/        raise NotImplementedError(\"Function not implemented\")/' has_traits.py\r\n\u001b[?2004l\r"]
[338.266066, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[339.313996, "i", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\n"]
[339.314254, "o", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\r\n\u001b[?2004l\r"]
[339.444871, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[339.446635, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[339.446755, "o", "\u001b[1mcollecting ... \u001b[0m"]
[339.523176, "o", "\u001b[1m\rcollected 0 items / 1 error                                                                                                                                    \u001b[0m\r\n"]
[339.524288, "o", "\r\n============================================================================ ERRORS ============================================================================\r\n\u001b[31m\u001b[1m_________________________________________________________ ERROR collecting traits/tests/test_clone.py __________________________________________________________\u001b[0m\r\n"]
[339.526414, "o", "\u001b[31m/usr/local/lib/python3.10/site-packages/_pytest/python.py:507: in importtestmodule\r\n    mod = import_path(\r\n/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path\r\n    importlib.import_module(module_name)\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1050: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1027: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:688: in _load_unlocked\r\n    ???\r\n/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:197: in exec_module\r\n    exec(co, module.__dict__)\r\ntests/test_clone.py:13: in <module>\r\n    from traits.api import HasTraits, Instance, Int, Str, Any, Property\r\napi.py:138: in <module>\r\n    from .has_traits import (\r\nE     File \"/workspace/repo/traits/has_traits.py\", line 1082\r\nE       \"\"\"\r\nE          ^\r\nE   IndentationError: unindent does not match any outer indentation level\u001b[0m\r\n\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_clone.py\r\n\u001b[31m======================================================================= \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.08s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[339.540954, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/traits/tests/test_clone.py::CloneTestCase::test_instance\r\n\u001b[0m\r\n"]
[339.55836, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[370.059349, "i", "sed -i '/\"\"\"/d' has_traits.py\n"]
[370.059533, "o", "sed -i '/\"\"\"/d' has_traits.py\r\n\u001b[?2004l\r"]
[370.061563, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[371.00586, "i", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\n"]
[371.006224, "o", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\r\n\u001b[?2004l\r"]
[371.155462, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[371.1581, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\n"]
[371.15819, "o", "plugins: mock-3.15.1, timeout-2.4.0\r\n"]
[371.158273, "o", "\u001b[1mcollecting ... \u001b[0m"]
[371.23725, "o", "\u001b[1m\rcollected 0 items / 1 error                                                                                                                                    \u001b[0m\r\n"]
[371.237674, "o", "\r\n============================================================================ ERRORS ============================================================================\r\n"]
[371.237809, "o", "\u001b[31m\u001b[1m_________________________________________________________ ERROR collecting traits/tests/test_clone.py __________________________________________________________\u001b[0m\r\n\u001b[31m/usr/local/lib/python3.10/site-packages/_pytest/python.py:507: in importtestmodule\r\n    mod = import_path(\r\n/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path\r\n    importlib.import_module(module_name)\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1050: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1027: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:688: in _load_unlocked\r\n    ???\r\n/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:197: in exec_module\r\n    exec(co, module.__dict__)\r\ntests/test_clone.py:13: in <module>\r\n    from traits.api import HasTraits, Instance, Int, Str, Any, Property\r\napi.py:138: in <module>\r\n    from .has_traits import (\r\nE     File \"/workspace/repo/traits/has_traits.py\", line 1\r\nE       associated metaclasses.\r\nE   IndentationError: unexpected indent\u001b[0m\r\n"]
[371.237927, "o", "\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_clone.py\r\n\u001b[31m======================================================================= \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.08s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[371.252748, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/traits/tests/test_clone.py::CloneTestCase::test_instance\r\n\u001b[0m\r\n"]
[371.270003, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[390.014513, "i", "sed -i '1s/^[ \t]*//' has_traits.py\n"]
[390.014665, "o", "sed -i '1s/^[ "]
[390.014704, "o", "\u0007"]
[390.014802, "o", "]*//' has_traits.py\r\n\u001b[?2004l\r"]
[390.016743, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[391.190034, "i", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\n"]
[391.190305, "o", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\r\n\u001b[?2004l\r"]
[391.309889, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[391.311647, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[391.311731, "o", "\u001b[1mcollecting ... \u001b[0m"]
[391.387608, "o", "\u001b[1m\rcollected 0 items / 1 error                                                                                                                                    \u001b[0m\r\n"]
[391.387958, "o", "\r\n"]
[391.388013, "o", "============================================================================ ERRORS ============================================================================\r\n\u001b[31m\u001b[1m_________________________________________________________ ERROR collecting traits/tests/test_clone.py __________________________________________________________\u001b[0m\r\n"]
[391.388063, "o", "\u001b[31m/usr/local/lib/python3.10/site-packages/_pytest/python.py:507: in importtestmodule\r\n    mod = import_path(\r\n/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path\r\n    importlib.import_module(module_name)\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1050: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1027: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:688: in _load_unlocked\r\n    ???\r\n/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:197: in exec_module\r\n    exec(co, module.__dict__)\r\ntests/test_clone.py:13: in <module>\r\n    from traits.api import HasTraits, Instance, Int, Str, Any, Property\r\napi.py:138: in <module>\r\n    from .has_traits import (\r\nE     File \"/workspace/repo/traits/has_traits.py\", line 1\r\nE       associated metaclasses.\r\nE                  ^^^^^^^^^^^\r\nE   SyntaxError: invalid syntax\u001b[0m\r\n"]
[391.388147, "o", "\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_clone.py\r\n"]
[391.3882, "o", "\u001b[31m======================================================================= \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.08s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[391.402906, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/traits/tests/test_clone.py::CloneTestCase::test_instance\r\n\u001b[0m\r\n"]
[391.420339, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[414.769536, "i", "head -n 10 has_traits.py\n"]
[414.769708, "o", "head -n 10 has_traits.py\r\n\u001b[?2004l\r"]
[414.771483, "o", "associated metaclasses.\r\nimport abc\r\nimport copy as copy_module\r\nimport inspect\r\nimport os\r\nimport pickle\r\n"]
[414.771509, "o", "import re\r\nimport types\r\nimport warnings\r\nimport weakref\r\n"]
[414.771798, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[437.57232, "i", "sed -i '1d' has_traits.py\n"]
[437.572549, "o", "sed -i '1d' has_traits.py\r\n\u001b[?2004l\r"]
[437.574477, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[438.414421, "i", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\n"]
[438.414798, "o", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\r\n\u001b[?2004l\r"]
[438.549749, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[438.551712, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[438.551823, "o", "\u001b[1mcollecting ... \u001b[0m"]
[438.627367, "o", "\u001b[1m\rcollected 0 items / 1 error                                                                                                                                    \u001b[0m\r\n"]
[438.627715, "o", "\r\n============================================================================ ERRORS ============================================================================\r\n"]
[438.627809, "o", "\u001b[31m\u001b[1m_________________________________________________________ ERROR collecting traits/tests/test_clone.py __________________________________________________________\u001b[0m\r\n\u001b[31m/usr/local/lib/python3.10/site-packages/_pytest/python.py:507: in importtestmodule\r\n    mod = import_path(\r\n/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path\r\n    importlib.import_module(module_name)\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1050: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1027: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:688: in _load_unlocked\r\n    ???\r\n/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:197: in exec_module\r\n    exec(co, module.__dict__)\r\ntests/test_clone.py:13: in <module>\r\n    from traits.api import HasTraits, Instance, Int, Str, Any, Property\r\napi.py:138: in <module>\r\n    from .has_traits import (\r\nE     File \"/workspace/repo/traits/has_traits.py\", line 70\r\nE       This is used in practice to identify magic-named _name_changed\r\nE                                ^^\r\nE   SyntaxError: invalid syntax\u001b[0m\r\n"]
[438.6279, "o", "\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_clone.py\r\n"]
[438.627983, "o", "\u001b[31m======================================================================= \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.08s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[438.642732, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/traits/tests/test_clone.py::CloneTestCase::test_instance\r\n\u001b[0m\r\n"]
[438.661617, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[470.194097, "i", "sed -n '65,75p' has_traits.py\n"]
[470.194278, "o", "sed -n '65,75p' has_traits.py\r\n\u001b[?2004l\r"]
[470.19543, "o", "            return result\r\n    return None\r\n\r\ndef is_unbound_method_type(method):\r\n\r\n    This is used in practice to identify magic-named _name_changed\r\n    and _name_fired methods.\r\n\r\n    return inspect.isfunction(method) or inspect.ismethoddescriptor(method)\r\n\r\ndef _is_serializable(value):\r\n"]
[470.195758, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[505.93749, "i", "sed -i 's/    This is used in practice to identify magic-named _name_changed/        This is used in practice to identify magic-named _name_changed/' has_traits.py\n"]
[505.938111, "o", "sed -i 's/    This is used in practice to identify magic-named _name_changed/        This is used in practice to identify magic-named _name_changed/' has_traits.py\r\n\u001b[?2004l\r"]
[505.940378, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[506.908711, "i", "sed -i 's/    and _name_fired methods./        and _name_fired methods./' has_traits.py\n"]
[506.909407, "o", "sed -i 's/    and _name_fired methods./        and _name_fired methods./' has_traits.py\r\n\u001b[?2004l\r"]
[506.913477, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[508.034416, "i", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\n"]
[508.034885, "o", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\r\n\u001b[?2004l\r"]
[508.169402, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[508.17116, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[508.171229, "o", "\u001b[1mcollecting ... \u001b[0m"]
[508.285132, "o", "\u001b[1m\rcollected 0 items / 1 error                                                                                                                                    \u001b[0m\r\n"]
[508.285539, "o", "\r\n============================================================================ ERRORS ============================================================================\r\n\u001b[31m\u001b[1m_________________________________________________________ ERROR collecting traits/tests/test_clone.py __________________________________________________________\u001b[0m\r\n\u001b[31m/usr/local/lib/python3.10/site-packages/_pytest/python.py:507: in importtestmodule\r\n    mod = import_path(\r\n/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path\r\n    importlib.import_module(module_name)\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1050: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1027: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:688: in _load_unlocked\r\n    ???\r\n/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:197: in exec_module\r\n    exec(co, module.__dict__)\r\ntests/test_clone.py:13: in <module>\r\n    from traits.api import HasTraits, Instance, Int, Str, Any, Property\r\napi.py:138: in <module>\r\n    from .has_traits import (\r\nE     File \"/workspace/repo/traits/has_traits.py\", line 70\r\nE       This is used in practice to identify magic-named _name_changed\r\nE                                ^^\r\nE   SyntaxError: invalid syntax\u001b[0m"]
[508.285678, "o", "\r\n"]
[508.28576, "o", "\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_clone.py\r\n\u001b[31m======================================================================= \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.12s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[508.300166, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/traits/tests/test_clone.py::CloneTestCase::test_instance\r\n\u001b[0m\r\n"]
[508.317256, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[542.98929, "i", "sed -i '/This is used in practice to identify magic-named _name_changed/,+2d' has_traits.py\n"]
[542.990056, "o", "sed -i '/This is used in practice to identify magic-named _name_changed/,+2d' has_traits.py\r\n\u001b[?2004l\r"]
[542.99249, "o", "\u001b[?2004h"]
[542.992549, "o", "root@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[543.901601, "i", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\n"]
[543.90193, "o", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\r\n\u001b[?2004l\r"]
[544.036389, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[544.03816, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[544.038212, "o", "\u001b[1mcollecting ... \u001b[0m"]
[544.113544, "o", "\u001b[1m\rcollected 0 items / 1 error                                                                                                                                    \u001b[0m\r\n"]
[544.11397, "o", "\r\n============================================================================ ERRORS ============================================================================\r\n"]
[544.11404, "o", "\u001b[31m\u001b[1m_________________________________________________________ ERROR collecting traits/tests/test_clone.py __________________________________________________________\u001b[0m\r\n\u001b[31m/usr/local/lib/python3.10/site-packages/_pytest/python.py:507: in importtestmodule\r\n    mod = import_path(\r\n/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path\r\n    importlib.import_module(module_name)\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1050: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1027: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:688: in _load_unlocked\r\n    ???\r\n/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:197: in exec_module\r\n    exec(co, module.__dict__)\r\ntests/test_clone.py:13: in <module>\r\n    from traits.api import HasTraits, Instance, Int, Str, Any, Property\r\napi.py:138: in <module>\r\n    from .has_traits import (\r\nE     File \"/workspace/repo/traits/has_traits.py\", line 86\r\nE       handlers.\r\nE                ^\r\nE   SyntaxError: invalid syntax\u001b[0m\r\n"]
[544.114233, "o", "\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_clone.py\r\n\u001b[31m======================================================================= \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.08s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[544.131791, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/traits/tests/test_clone.py::CloneTestCase::test_instance\r\n\u001b[0m\r\n"]
[544.153793, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[564.692436, "i", "sed -n '81,91p' has_traits.py\n"]
[564.692766, "o", "sed -n '81,91p' has_traits.py\r\n\u001b[?2004l\r"]
[564.694151, "o", "                return False\r\n        return True\r\n    return not isinstance(value, HasTraits) or value.has_traits_interface(ISerializable)\r\n\r\ndef _get_instance_handlers(class_dict, bases):\r\n        handlers.\r\n    instance_traits = {}\r\n    for base in bases:\r\n        for (name, base_arg_lists) in base.__dict__.get(InstanceTraits).items():\r\n            arg_lists = instance_traits.get(name)\r\n            if arg_lists is None:\r\n"]
[564.694569, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[586.474664, "i", "sed -i '/handlers./d' has_traits.py\n"]
[586.475026, "o", "sed -i '/handlers./d' has_traits.py\r\n\u001b[?2004l\r"]
[586.477149, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
[587.446532, "i", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\n"]
[587.44719, "o", "pytest tests/test_clone.py::CloneTestCase::test_instance -v\r\n\u001b[?2004l\r"]
[587.647185, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[587.648952, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[587.649037, "o", "\u001b[1mcollecting ... \u001b[0m"]
[587.728614, "o", "\u001b[1m\rcollected 0 items / 1 error                                                                                                                                    \u001b[0m\r\n"]
[587.729042, "o", "\r\n"]
[587.729101, "o", "============================================================================ ERRORS ============================================================================\r\n\u001b[31m\u001b[1m_________________________________________________________ ERROR collecting traits/tests/test_clone.py __________________________________________________________\u001b[0m\r\n\u001b[31m/usr/local/lib/python3.10/site-packages/_pytest/python.py:507: in importtestmodule\r\n    mod = import_path(\r\n/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path\r\n    importlib.import_module(module_name)\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n<frozen importlib._bootstrap>:1050: in _gcd_import\r\n    ???\r\n<frozen importlib._bootstrap>:1027: in _find_and_load\r\n    ???\r\n<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked\r\n    ???\r\n<frozen importlib._bootstrap>:688: in _load_unlocked\r\n    ???\r\n/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:197: in exec_module\r\n    exec(co, module.__dict__)\r\ntests/test_clone.py:13: in <module>\r\n    from traits.api import HasTraits, Instance, Int, Str, Any, Property\r\napi.py:138: in <module>\r\n    from .has_traits import (\r\nE     File \"/workspace/repo/traits/has_traits.py\", line 112\r\nE       and delegate trait.\r\nE       ^^^\r\nE   SyntaxError: invalid syntax\u001b[0m\r\n"]
[587.72924, "o", "\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_clone.py\r\n"]
[587.729287, "o", "\u001b[31m======================================================================= \u001b[31m\u001b[1m1 error\u001b[0m\u001b[31m in 0.08s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[587.743946, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/traits/tests/test_clone.py::CloneTestCase::test_instance\r\n\u001b[0m\r\n"]
[587.761666, "o", "\u001b[?2004hroot@d1c550e3-5d1a-4687-974b-fc5976cac236:/workspace/repo/traits# "]
