Previous response had warnings:
WARNINGS: - Extra text detected before JSON object
- Extra text detected after JSON object

New Terminal Output:

root@a9be5583-759e-4880-b2e1-2e0f068481aa:/workspace/repo# cat src/common.py
import logging
import os
import re
import subprocess
import math
from collections import defaultdict
from enum import Enum
logger = logging.getLogger('IsoQuant')

class CigarEvent(Enum):
    match = 0
    insertion = 1
    deletion = 2
    skipped = 3
    soft_clipping = 4
    hard_clipping = 5
    padding = 6
    seq_match = 7
    seq_mismatch = 8

    @classmethod
    def get_match_events(cls):
        return {cls.match, cls.seq_match, cls.seq_mismatch}

    @classmethod
    def get_ins_del_match_events(cls):
        return {cls.match, cls.insertion, cls.deletion, cls.seq_match, cls.seq_mismatch}

class TranscriptNaming:
    transcript_prefix = 'transcript'
    novel_gene_prefix = 'novel_gene_'
    nic_transcript_suffix = '.nic'
    nnic_transcript_suffix = '.nnic'

def get_first_best_from_sorted(sorted_list_of_pairs):
    if not sorted_list_of_pairs:
        return []
    best_value = sorted_list_of_pairs[0][1]
    result = []
    for x in sorted_list_of_pairs:
        if x[1] > best_value:
            break
        result.append(x[0])
    return result

def list_to_str(element_list, element_delim=','):
    if len(element_list) == 0:
        return '.'
    return element_delim.join(list(map(str, element_list)))

def rindex(l, el):
    for i in range(len(l) - 1, -1, -1):
        if l[i] == el:
            return i
    raise ValueError(str(el) + ' is not in list')

def get_top_count(dict):
    if not dict:
        return None
    return max(dict.items(), key=lambda x: x[1])[0]

def find_closest(value, value_list):
    if not value_list:
        return (None, math.inf)
    best_diff = math.inf
    best_el = None
    for v in value_list:
        diff = abs(v - value)
        if diff < best_diff:
            best_diff = diff
            best_el = v
    return (best_el, best_diff)

def rreplace(s, old, new):
    return new.join(s.rsplit(old, 1))

def get_best_from_count_dicts(dict):
    res = {}
    for k in dict.keys():
        res[k] = get_top_count(dict[k])
    return res

def get_collective_property(value_collection, property_dict):
    counts = defaultdict(int)
    for v in value_collection:
        if v not in property_dict:
            continue
        counts[property_dict[v]] += 1
    return get_top_count(counts)

def proper_plural_form(name, count):
    return str(count) + ' ' + name + ('' if count == 1 else 's')

def convert_chr_id_to_file_name_str(chr_id: str):
    return chr_id.replace('/', '_')

def genes_overlap(gene_db1, gene_db2):
    if gene_db1.seqid != gene_db2.seqid:
        return False
    return overlaps((gene_db1.start, gene_db1.end), (gene_db2.start, gene_db2.end))

def genes_contain(gene_db1, gene_db2):
    if gene_db1.seqid != gene_db2.seqid:
        return False
    return contains((gene_db1.start, gene_db1.end), (gene_db2.start, gene_db2.end))

def argmin(l):
    if len(l) == 0:
        return -1
    min_v = l[0]
    min_i = 0
    for i in range(len(l)):
        if l[i] < min_v:
            min_v = l[i]
            min_i = i
    return min_i

def cmp(x, y):
    if x < y:
        return -1
    elif x > y:
        return 1
    return 0

def overlaps(range1, range2):
    return not (range1[1] < range2[0] or range1[0] > range2[1])

def overlap_intervals(range1, range2):
    return (max(range1[0], range2[0]), min(range1[1], range2[1]))

def overlaps_at_least(range1, range2, delta=0):
    ovlp1 = range1[1] - range2[0]
    ovlp2 = range2[1] - range1[0]
    if ovlp1 < 0 or ovlp2 < 0:
        return False
    d = delta - 1
    if range1[1] < range2[1]:
        return ovlp1 >= d or range1[0] >= range2[0]
    else:
        return ovlp2 >= d or range1[0] <= range2[0]

def overlaps_at_least_when_overlap(range1, range2, delta=0):
    if range1[1] < range2[1]:
        return range1[0] >= range2[0] or range1[1] - range2[0] + 1 >= delta
    else:
        return range1[0] <= range2[0] or range2[1] - range1[0] + 1 >= delta

def intersection_len(range1, range2):
    return max(0, min(range1[1], range2[1]) - max(range1[0], range2[0]) + 1)

def left_of(range1, range2):
    return range1[1] < range2[0]

def equal_ranges(range1, range2, delta=0):
    return abs(range1[0] - range2[0]) <= delta and abs(range1[1] - range2[1]) <= delta

def covers_end(bigger_range, smaller_range):
    return bigger_range[0] <= smaller_range[0] <= bigger_range[1] <= smaller_range[1]

def covers_start(bigger_range, smaller_range):
    return smaller_range[0] <= bigger_range[0] <= smaller_range[1] <= bigger_range[1]

def contains(bigger_range, smaller_range):
    return bigger_range[1] >= smaller_range[1] and bigger_range[0] <= smaller_range[0]

def contains_well_inside(bigger_range, smaller_range, delta=1):
    return bigger_range[1] >= smaller_range[1] + delta and bigger_range[0] <= smaller_range[0] - delta

def contains_approx(bigger_range, smaller_range, delta=1):
    return bigger_range[1] + delta >= smaller_range[1] and bigge
[... output limited to 10000 bytes; 71 interior bytes omitted ...]
    matches[i] = 1
    return matches

def has_overlapping_features(profile1, profile2, profile_range=None):
    assert len(profile1) == len(profile2)
    if profile_range is None:
        profile_range = (0, len(profile1))
    for i in range(*profile_range):
        if profile1[i] == profile2[i] == 1:
            return True
    return False

def has_inconsistent_features(read_profile, gene_profile):
    assert len(read_profile) == len(gene_profile)
    for i in range(len(read_profile)):
        if read_profile[i] != gene_profile[i] and read_profile[i] != 0:
            return True
    return False

def mask_profile(read_profile, true_profile):
    assert len(read_profile) == len(true_profile)
    masked_profile = []
    for i in range(len(true_profile)):
        if true_profile[i] == 1:
            masked_profile.append(read_profile[i])
        else:
            masked_profile.append(0)
    return masked_profile

def get_blocks_from_profile(features, profile):
    assert len(features) == len(profile)
    profile_features = []
    for i in range(len(profile)):
        if profile[i] == 1:
            profile_features.append(features[i])
    return profile_features

def left_truncated(read_profile, isoform_profile):
    if 1 not in read_profile or 1 not in isoform_profile:
        return True
    return read_profile.index(1) > isoform_profile.index(1)

def right_truncated(read_profile, isoform_profile):
    if 1 not in read_profile or 1 not in isoform_profile:
        return True
    return rindex(read_profile, 1) < rindex(isoform_profile, 1)

def get_path_to_program(program, dirpath=None, min_version=None):
    """
    returns the path to an executable or None if it can't be found
    """

    def is_exe(fpath):
        if os.path.isfile(fpath) and os.access(fpath, os.X_OK):
            if not min_version or check_version(fpath, min_version):
                return True

    def check_version(fpath, min_version):
        p = subprocess.run([fpath, '--version'], capture_output=True)
        version_pattern = re.compile('(?P<major_version>\\d+)\\.(?P<minor_version>\\d+)')
        v = version_pattern.search(str(p.stdout))
        if not v.group('major_version') or not v.group('minor_version'):
            return False
        (version, minor_version) = map(int, min_version.split('.'))
        if int(v.group('major_version')) == version and int(v.group('minor_version')) >= minor_version:
            return True
    if dirpath:
        exe_file = os.path.join(dirpath, program)
        if is_exe(exe_file):
            return exe_file
    for path in os.environ['PATH'].split(os.pathsep):
        exe_file = os.path.join(path, program)
        if is_exe(exe_file):
            return exe_file
    return None

def count_noncanonincal(introns, reference_region, strand, ref_region_start=0):
    count = 0
    for intron in introns:
        intron_left_pos = intron[0] - ref_region_start
        intron_right_pos = intron[1] - ref_region_start
        left_site = reference_region[intron_left_pos:intron_left_pos + 2]
        right_site = reference_region[intron_right_pos - 1:intron_right_pos + 1]
        if strand == '+':
            count += 0 if (left_site, right_site) == ('GT', 'AG') else 1
        else:
            count += 0 if (left_site, right_site) == ('CT', 'AC') else 1
    return count
CANONICAL_FWD_SITES = {('GT', 'AG'), ('GC', 'AG'), ('AT', 'AC')}
CANONICAL_REV_SITES = {('CT', 'AC'), ('CT', 'GC'), ('GT', 'AT')}

def get_intron_strand(intron, reference_region, ref_region_start=1):
    intron_left_pos = intron[0] - ref_region_start
    intron_right_pos = intron[1] - ref_region_start
    left_site = str(reference_region[intron_left_pos:intron_left_pos + 2]).upper()
    right_site = str(reference_region[intron_right_pos - 1:intron_right_pos + 1]).upper()
    is_fwd = (left_site, right_site) in CANONICAL_FWD_SITES
    is_rev = (left_site, right_site) in CANONICAL_REV_SITES
    if is_fwd == is_rev:
        return '.'
    return '+' if is_fwd else '-'

def get_strand(introns, reference_region, ref_region_start=1):
    if len(introns) == 0:
        return '.'
    count_fwd = 0
    count_rev = 0
    for intron in introns:
        intron_left_pos = intron[0] - ref_region_start
        intron_right_pos = intron[1] - ref_region_start
        left_site = str(reference_region[intron_left_pos:intron_left_pos + 2])
        right_site = str(reference_region[intron_right_pos - 1:intron_right_pos + 1])
        count_fwd += 1 if (left_site, right_site) in CANONICAL_FWD_SITES else 0
        count_rev += 1 if (left_site, right_site) in CANONICAL_REV_SITES else 0
    if count_fwd == count_rev:
        return '.'
    return '+' if count_rev < count_fwd else '-'
base_comp = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A', 'N': 'N', 'a': 't', 'c': 'g', 'g': 'c', 't': 'a', 'n': 'n'}

def reverse_complement(seq):
    lms = list(map(lambda x: base_comp[x], seq))[::-1]
    return ''.join(lms)root@a9be5583-759e-4880-b2e1-2e0f068481aa:/workspace/repo#
