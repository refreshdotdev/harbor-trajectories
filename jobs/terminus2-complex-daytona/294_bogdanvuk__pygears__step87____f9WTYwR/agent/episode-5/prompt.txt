Previous response had warnings:
WARNINGS: - Extra text detected before JSON object
- Extra text detected after JSON object

New Terminal Output:

root@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# cat gear_inst.py
import inspect
import fnmatch
import sys
from copy import copy
from pygears.core.graph import get_producer_port
from pygears.conf import MultiAlternativeError, core_log, reg
from pygears.typing import Any, cast, get_match_conds
from pygears.core.util import is_standard_func, get_function_context_dict
from .partial import Partial
from .intf import Intf
from .infer_ftypes import TypeMatchError, infer_ftypes, type_is_specified
from .gear import TooManyArguments, GearTypeNotSpecified, GearArgsNotSpecified
from .gear import Gear, create_hier
from .gear_decorator import GearDecoratorPlugin
from .gear_memoize import get_memoized_gear, memoize_gear
from .port import HDLConsumer, HDLProducer
from .channel import channel_interfaces

def check(pattern, node):
    if isinstance(pattern, str):
        return fnmatch.fnmatch(node.name, pattern)
    else:
        return pattern(node)

def is_traced(node):
    return any((check(p, node) for p in reg['debug/trace']))

def get_obj_var_name(frame, obj):
    for (var_name, var_obj) in frame.f_locals.items():
        if obj is var_obj:
            return var_name
    else:
        None

def find_current_gear_frame():
    import inspect
    code_map = reg['gear/code_map']
    if not code_map:
        return None
    for (frame, *_) in inspect.stack():
        if frame.f_code is code_map[-1].func.__code__:
            return frame
    else:
        return None
oper_name = {'__add__': '+', '__and__': '&', '__floordiv__': '/', '__truediv__': '//', '__eq__': '==', '__ge__': '>=', '__gt__': '>', '__invert__': '~', '__le__
': '<=', '__lt__': '<', '__lshift__': '<<', '__matmul__': '@', '__mod__': '%', '__mul__': '*', '__ne__': '!=', '__neg__': '-', '__rshift__': '>>', '__sub__': '-
', '__xor__': '^'}

def get_operator_name(func):
    for (name, p) in reg['gear/intf_oper'].items():
        if isinstance(p, Partial):
            p = p.func
        if p is func:
            return oper_name[name]
    return None

def expand_varargs(args, annotations, varargsname, varargs):
    vararg_type_list = []
    if varargsname in annotations:
        vararg_type = annotations[varargsname]
    else:
        vararg_type = Any
    for (i, a) in enumerate(varargs):
        if isinstance(vararg_type, str):
            type_tmpl_i = vararg_type.format(i).encode()
        else:
            type_tmpl_i = vararg_type
        argname = f'{varargsname}{i}'
        vararg_type_list.append(argname)
        annotations[argname] = type_tmpl_i
        args[argname] = a
    if vararg_type_list:
        annotations[varargsname] = f"({', '.join(vararg_type_list)}, )".encode()

def infer_params(args, params, context):
    arg_types = {name: arg.dtype for (name, arg) in args.items()}
    return infer_ftypes(params, arg_types, namespace=context)

class intf_name_tracer:

    def __init__(self, gear):
        self.enabled = reg['gear/infer_signal_names']
        if self.enabled == 'debug':
            self.enabled = is_traced(gear)
        if not self.enabled:
            return
        self.code_map = reg['gear/code_map']
        self.gear = gear

    def tracer(self, frame, event, arg):
        if event == 'return':
            for cm in self.code_map:
                if frame.f_code is cm.func.__code__:
                    cm.func_locals = frame.f_locals.copy()

    def __enter__(self):
        if not self.enabled:
            return
        self.code_map.append(self.gear)
        if reg['gear/current_module'].parent == reg['gear/root']:
            sys.setprofile(self.tracer)
        return self

    def __exit__(self, exception_type, exception_value, traceback):
        if not self.enabled:
            return
        cur_gear = reg['gear/current_module']
        if cur_gear.parent == reg['gear/root']:
            sys.setprofile(None)
        cm = self.code_map.pop()
        if exception_type is None and hasattr(cm, 'func_locals'):
            for (name, val) in filter(lambda x: isinstance(x[1], Intf), cm.func_locals.items()):
                if not hasattr(val, 'var_name'):
                    cnt = 0
                    for c in cur_gear.child + cur_gear.in_ports:
                        if c.basename == name:
                            cnt += 1
                    if cnt == 0:
                        val.var_name = name
                    else:
                        val.var_name = f'{name}{cnt}'

def resolve_func(gear_inst):
    out_dtype = gear_inst.params.get('return', None)
    if out_dtype is None:
        out_dtype = ()
    elif out_dtype:
        if isinstance(out_dtype, dict):
            out_dtype = tuple(out_dtype.values())
    if not isinstance(out_dtype, tuple):
        out_dtype = (out_dtype,)
    if not is_standard_func(gear_inst.func):
        return (tuple(), out_dtype)
    with create_hier(gear_inst):
        with intf_name_tracer(gear_inst):
            local_in_intfs = gear_inst.in_p
[... output limited to 10000 bytes; 69 interior bytes omitted ...]
ot isinstance(out_intfs, tuple):
            out_intfs = (out_intfs,)
        for (i, intf) in enumerate(out_intfs):
            if isinstance(intf, Partial):
                raise GearArgsNotSpecified(f'Unresolved gear "{intf.func.__name__}" with arguments {intf.args} and parameters {intf.kwds}, returned as output "{
i}": {str(MultiAlternativeError(intf.errors))}')
        err = None
        try:
            (out_intfs, out_dtype) = resolve_out_types(out_intfs, out_dtype, gear_inst)
        except (TypeError, TypeMatchError) as e:
            err = type(e)(f"{str(e)}\n    when instantiating '{gear_inst.name}'")
        if err:
            raise err
    return (out_intfs, out_dtype)

def resolve_gear(gear_inst, out_intfs, out_dtype, fix_intfs):
    dflt_dout_name = reg['gear/naming/default_out_name']
    for i in range(len(gear_inst.outnames), len(out_dtype)):
        if out_intfs and hasattr(out_intfs[i], 'var_name'):
            gear_inst.outnames.append(out_intfs[i].var_name)
        else:
            gear_inst.outnames.append(dflt_dout_name if len(out_dtype) == 1 else f'{dflt_dout_name}{i}')
    gear_inst.connect_output(out_intfs, out_dtype)
    intfs = []
    out_intfs = []
    if isinstance(fix_intfs, dict):
        for (i, (name, dt)) in enumerate(zip(gear_inst.outnames, out_dtype)):
            if name in fix_intfs or i in fix_intfs:
                if name in fix_intfs:
                    intf = fix_intfs[name]
                elif i in fix_intfs:
                    intf = fix_intfs[i]
                err = None
                try:
                    get_match_conds(dt, intf.dtype)
                except (TypeError, TypeMatchError) as e:
                    err = type(e)(f"{str(e)}\n    when connecting user supplied output interface '{name}' of '{gear_inst.name}'\n    FIX: Consider changing the
type of the supplied output interface '{name}' to '{repr(dt)}'")
                if err:
                    raise err
            else:
                intf = Intf(dt)
                out_intfs.append(intf)
            intfs.append(intf)
    elif fix_intfs:
        intfs = fix_intfs
    else:
        intfs = [Intf(dt) for dt in out_dtype]
        out_intfs = intfs
    if len(intfs) != len(gear_inst.out_port_intfs):
        raise GearArgsNotSpecified(f"Received {len(intfs)} output interfaces, while expecting {len(gear_inst.out_port_intfs)}\n    when instantiating '{gear_ins
t.name}'")
    for (intf, port) in zip(intfs, gear_inst.out_ports):
        intf.source(port)
    if any((not type_is_specified(i.dtype) for i in out_intfs)):
        raise GearTypeNotSpecified(f'Output type of the gear "{gear_inst.name}" could not be resolved, and resulted in "{repr(out_dtype)}"')
    for c in gear_inst.child:
        channel_interfaces(c)
    if len(out_intfs) > 1:
        return tuple(out_intfs)
    elif len(out_intfs) == 1:
        return out_intfs[0]
    else:
        return None

def resolve_out_types(out_intfs, out_dtype, gear_inst):
    if out_intfs and (not out_dtype):
        out_dtype = tuple((intf.dtype for intf in out_intfs))
        return (out_intfs, out_dtype)
    if out_intfs:
        if len(out_intfs) != len(out_dtype):
            relation = 'smaller' if len(out_intfs) < len(out_dtype) else 'larger'
            raise TypeMatchError(f"Number of actual output interfaces ({len(out_intfs)}) is {relation} than the number of specified output types: ({tuple((getat
tr(i, 'dtype', type(i)) for i in out_intfs))}) vs {repr(out_dtype)}")
        casted_out_intfs = list(out_intfs)
        for (i, (intf, t)) in enumerate(zip(out_intfs, out_dtype)):
            err = None
            try:
                if intf.dtype != t:
                    cast(intf.dtype, t)
            except (TypeError, TypeMatchError) as e:
                err = type(e)(f'{str(e)}, when casting type for output port {i}')
            if err:
                raise err
        for (i, (intf, t)) in enumerate(zip(out_intfs, out_dtype)):
            if intf.dtype != t:
                from pygears.lib.cast import cast as cast_gear
                casted_out_intfs[i] = cast_gear(intf, t=t)
        out_intfs = tuple(casted_out_intfs)
        return (out_intfs, out_dtype)
    return (out_intfs, out_dtype)

def terminate_internal_intfs(gear_inst):
    if not is_standard_func(gear_inst.func):
        for p in gear_inst.in_ports:
            if p.consumer is not None:
                p.consumer.connect(HDLConsumer())
        for i in gear_inst.out_port_intfs:
            i.source(HDLProducer())

class GearInstPlugin(GearDecoratorPlugin):

    @classmethod
    def bind(cls):
        reg['gear/code_map'] = []
        reg['gear/gear_dflt_resolver'] = gear_base_resolver
        reg.confdef('gear/memoize', False)
        reg.confdef('gear/infer_signal_names', 'debug')
        reg.confdef('debug/trace', default=[])

    @classmethod
    def reset(cls):
        reg['gear/code_map'] = []root@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core#
