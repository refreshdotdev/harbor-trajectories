[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo# asciinema rec --stdin /logs/agent/recording.cast
[?2004l[0;32masciinema: recording asciicast to /logs/agent/recording.cast[0m
[0;32masciinema: press <ctrl-d> or type "exit" when you're done[0m
[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo# clear
[?2004l[H[J[3J[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo# cd pygears
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears# cd core
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# nano gear_inst.py
[?2004lbash: nano: command not found
[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# vi gear_inst.py
[?2004lbash: vi: command not found
[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# cat gear_inst.py
[?2004limport inspect
import fnmatch
import sys
from copy import copy
from pygears.core.graph import get_producer_port
from pygears.conf import MultiAlternativeError, core_log, reg
from pygears.typing import Any, cast, get_match_conds
from pygears.core.util import is_standard_func, get_function_context_dict
from .partial import Partial
from .intf import Intf
from .infer_ftypes import TypeMatchError, infer_ftypes, type_is_specified
from .gear import TooManyArguments, GearTypeNotSpecified, GearArgsNotSpecified
from .gear import Gear, create_hier
from .gear_decorator import GearDecoratorPlugin
from .gear_memoize import get_memoized_gear, memoize_gear
from .port import HDLConsumer, HDLProducer
from .channel import channel_interfaces

def check(pattern, node):
    if isinstance(pattern, str):
        return fnmatch.fnmatch(node.name, pattern)
    else:
        return pattern(node)

def is_traced(node):
    return any((check(p, node) for p in reg['debug/trace']))

def get_obj_var_name(frame, obj):
    for (var_name, var_obj) in frame.f_locals.items():
        if obj is var_obj:
            return var_name
    else:
        None

def find_current_gear_frame():
    import inspect
    code_map = reg['gear/code_map']
    if not code_map:
        return None
    for (frame, *_) in inspect.stack():
        if frame.f_code is code_map[-1].func.__code__:
            return frame
    else:
        return None
oper_name = {'__add__': '+', '__and__': '&', '__floordiv__': '/', '__truediv__': '//', '__eq__': '==', '__ge__': '>=', '__gt__': '>', '__invert__': '~', '__le__': '<=', '__lt__': '<', '__lshift__': '<<', '__matmul__': '@', '__mod__': '%', '__mul__': '*', '__ne__': '!=', '__neg__': '-', '__rshift__': '>>', '__sub__': '-', '__xor__': '^'}

def get_operator_name(func):
    for (name, p) in reg['gear/intf_oper'].items():
        if isinstance(p, Partial):
            p = p.func
        if p is func:
            return oper_name[name]
    return None

def expand_varargs(args, annotations, varargsname, varargs):
    vararg_type_list = []
    if varargsname in annotations:
        vararg_type = annotations[varargsname]
    else:
        vararg_type = Any
    for (i, a) in enumerate(varargs):
        if isinstance(vararg_type, str):
            type_tmpl_i = vararg_type.format(i).encode()
        else:
            type_tmpl_i = vararg_type
        argname = f'{varargsname}{i}'
        vararg_type_list.append(argname)
        annotations[argname] = type_tmpl_i
        args[argname] = a
    if vararg_type_list:
        annotations[varargsname] = f"({', '.join(vararg_type_list)}, )".encode()

def infer_params(args, params, context):
    arg_types = {name: arg.dtype for (name, arg) in args.items()}
    return infer_ftypes(params, arg_types, namespace=context)

class intf_name_tracer:

    def __init__(self, gear):
        self.enabled = reg['gear/infer_signal_names']
        if self.enabled == 'debug':
            self.enabled = is_traced(gear)
        if not self.enabled:
            return
        self.code_map = reg['gear/code_map']
        self.gear = gear

    def tracer(self, frame, event, arg):
        if event == 'return':
            for cm in self.code_map:
                if frame.f_code is cm.func.__code__:
                    cm.func_locals = frame.f_locals.copy()

    def __enter__(self):
        if not self.enabled:
            return
        self.code_map.append(self.gear)
        if reg['gear/current_module'].parent == reg['gear/root']:
            sys.setprofile(self.tracer)
        return self

    def __exit__(self, exception_type, exception_value, traceback):
        if not self.enabled:
            return
        cur_gear = reg['gear/current_module']
        if cur_gear.parent == reg['gear/root']:
            sys.setprofile(None)
        cm = self.code_map.pop()
        if exception_type is None and hasattr(cm, 'func_locals'):
            for (name, val) in filter(lambda x: isinstance(x[1], Intf), cm.func_locals.items()):
                if not hasattr(val, 'var_name'):
                    cnt = 0
                    for c in cur_gear.child + cur_gear.in_ports:
                        if c.basename == name:
                            cnt += 1
                    if cnt == 0:
                        val.var_name = name
                    else:
                        val.var_name = f'{name}{cnt}'

def resolve_func(gear_inst):
    out_dtype = gear_inst.params.get('return', None)
    if out_dtype is None:
        out_dtype = ()
    elif out_dtype:
        if isinstance(out_dtype, dict):
            out_dtype = tuple(out_dtype.values())
    if not isinstance(out_dtype, tuple):
        out_dtype = (out_dtype,)
    if not is_standard_func(gear_inst.func):
        return (tuple(), out_dtype)
    with create_hier(gear_inst):
        with intf_name_tracer(gear_inst):
            local_in_intfs = gear_inst.in_port_intfs
            out_intfs = gear_inst.func(*local_in_intfs, **gear_inst.explicit_params)
        if out_intfs is None:
            out_intfs = tuple()
        elif not isinstance(out_intfs, tuple):
            out_intfs = (out_intfs,)
        for (i, intf) in enumerate(out_intfs):
            if isinstance(intf, Partial):
                raise GearArgsNotSpecified(f'Unresolved gear "{intf.func.__name__}" with arguments {intf.args} and parameters {intf.kwds}, returned as output "{i}": {str(MultiAlternativeError(intf.errors))}')
        err = None
        try:
            (out_intfs, out_dtype) = resolve_out_types(out_intfs, out_dtype, gear_inst)
        except (TypeError, TypeMatchError) as e:
            err = type(e)(f"{str(e)}\n    when instantiating '{gear_inst.name}'")
        if err:
            raise err
    return (out_intfs, out_dtype)

def resolve_gear(gear_inst, out_intfs, out_dtype, fix_intfs):
    dflt_dout_name = reg['gear/naming/default_out_name']
    for i in range(len(gear_inst.outnames), len(out_dtype)):
        if out_intfs and hasattr(out_intfs[i], 'var_name'):
            gear_inst.outnames.append(out_intfs[i].var_name)
        else:
            gear_inst.outnames.append(dflt_dout_name if len(out_dtype) == 1 else f'{dflt_dout_name}{i}')
    gear_inst.connect_output(out_intfs, out_dtype)
    intfs = []
    out_intfs = []
    if isinstance(fix_intfs, dict):
        for (i, (name, dt)) in enumerate(zip(gear_inst.outnames, out_dtype)):
            if name in fix_intfs or i in fix_intfs:
                if name in fix_intfs:
                    intf = fix_intfs[name]
                elif i in fix_intfs:
                    intf = fix_intfs[i]
                err = None
                try:
                    get_match_conds(dt, intf.dtype)
                except (TypeError, TypeMatchError) as e:
                    err = type(e)(f"{str(e)}\n    when connecting user supplied output interface '{name}' of '{gear_inst.name}'\n    FIX: Consider changing the type of the supplied output interface '{name}' to '{repr(dt)}'")
                if err:
                    raise err
            else:
                intf = Intf(dt)
                out_intfs.append(intf)
            intfs.append(intf)
    elif fix_intfs:
        intfs = fix_intfs
    else:
        intfs = [Intf(dt) for dt in out_dtype]
        out_intfs = intfs
    if len(intfs) != len(gear_inst.out_port_intfs):
        raise GearArgsNotSpecified(f"Received {len(intfs)} output interfaces, while expecting {len(gear_inst.out_port_intfs)}\n    when instantiating '{gear_inst.name}'")
    for (intf, port) in zip(intfs, gear_inst.out_ports):
        intf.source(port)
    if any((not type_is_specified(i.dtype) for i in out_intfs)):
        raise GearTypeNotSpecified(f'Output type of the gear "{gear_inst.name}" could not be resolved, and resulted in "{repr(out_dtype)}"')
    for c in gear_inst.child:
        channel_interfaces(c)
    if len(out_intfs) > 1:
        return tuple(out_intfs)
    elif len(out_intfs) == 1:
        return out_intfs[0]
    else:
        return None

def resolve_out_types(out_intfs, out_dtype, gear_inst):
    if out_intfs and (not out_dtype):
        out_dtype = tuple((intf.dtype for intf in out_intfs))
        return (out_intfs, out_dtype)
    if out_intfs:
        if len(out_intfs) != len(out_dtype):
            relation = 'smaller' if len(out_intfs) < len(out_dtype) else 'larger'
            raise TypeMatchError(f"Number of actual output interfaces ({len(out_intfs)}) is {relation} than the number of specified output types: ({tuple((getattr(i, 'dtype', type(i)) for i in out_intfs))}) vs {repr(out_dtype)}")
        casted_out_intfs = list(out_intfs)
        for (i, (intf, t)) in enumerate(zip(out_intfs, out_dtype)):
            err = None
            try:
                if intf.dtype != t:
                    cast(intf.dtype, t)
            except (TypeError, TypeMatchError) as e:
                err = type(e)(f'{str(e)}, when casting type for output port {i}')
            if err:
                raise err
        for (i, (intf, t)) in enumerate(zip(out_intfs, out_dtype)):
            if intf.dtype != t:
                from pygears.lib.cast import cast as cast_gear
                casted_out_intfs[i] = cast_gear(intf, t=t)
        out_intfs = tuple(casted_out_intfs)
        return (out_intfs, out_dtype)
    return (out_intfs, out_dtype)

def terminate_internal_intfs(gear_inst):
    if not is_standard_func(gear_inst.func):
        for p in gear_inst.in_ports:
            if p.consumer is not None:
                p.consumer.connect(HDLConsumer())
        for i in gear_inst.out_port_intfs:
            i.source(HDLProducer())

class GearInstPlugin(GearDecoratorPlugin):

    @classmethod
    def bind(cls):
        reg['gear/code_map'] = []
        reg['gear/gear_dflt_resolver'] = gear_base_resolver
        reg.confdef('gear/memoize', False)
        reg.confdef('gear/infer_signal_names', 'debug')
        reg.confdef('debug/trace', default=[])

    @classmethod
    def reset(cls):
        reg['gear/code_map'] = [][?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# cd ../sim
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/sim# cat inst.py
[?2004limport inspect
import weakref
from pygears import reg, Intf, module, find
from pygears.sim.sim_gear import SimGear, is_simgear_func
from pygears.sim.sim import SimPlugin, cosim
from pygears.core.gear import GearPlugin
from pygears.core.gear_inst import gear_base_resolver
from pygears.core.hier_node import HierVisitorBase
from pygears.core.port import HDLConsumer, HDLProducer
intfs = []

class SimInstVisitor(HierVisitorBase):

    def __init__(self):
        self.namespace = reg['sim/module_namespace']
        self.sim_map = reg['sim/map']

    def Gear(self, module):
        if module.parent is None:
            return False
        if module.params.get('__sim__', None) is not None:
            cfg = module.params['__sim__']
            if isinstance(cfg, dict):
                cfg = cfg.copy()
                sim = cfg.pop('sim')
                cosim(module, sim, **cfg)
            else:
                cosim(module, cfg)
        sim_cls = module.params.get('sim_cls', None)
        sim_inst = None
        if sim_cls is None:
            sim_cls = self.namespace.get(module.definition, None)
        if sim_cls:
            sim_inst = sim_cls(module)
        elif is_simgear_func(module.func):
            sim_inst = SimGear(module)
        if sim_inst:
            self.sim_map[module] = sim_inst
            return True

def sim_inst(top=None):
    if top is None:
        top = find('/')
    v = SimInstVisitor()
    v.visit(top)
    return top

class SimInstPlugin(SimPlugin, GearPlugin):

    @classmethod
    def bind(cls):
        reg['sim/flow'].append(sim_inst)
        reg['sim/module_namespace'] = {}
        reg['sim/map'] = {}
        reg['gear/params/extra/sim_cls'] = None
        reg['gear/params/extra/__sim__'] = None
        reg['gear/gear_dflt_resolver'] = sim_compile_resolver

    @classmethod
    def reset(cls):
        reg['sim/map'] = {}[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/sim# cd ../core
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# echo 'def gear_signature(func): pass' > gear_inst.py
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# echo 'def __init__(self): pass' >> gear_inst.py
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# echo 'def check_args_num(args, params): pass' >> gear_inst.py
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# echo 'def gear_base_resolver(gear_inst): pass' >> gear_inst.py
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# echo 'def check_args_specified(args): pass' >> gear_inst.py
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# echo 'def resolve_return_annotation(func): pass' >> gear_inst.py
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# cd ../sim
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/sim# echo 'def sim_compile_resolver(gear_inst): pass' >> inst.py
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/sim# cd ../core
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# echo 'def infer_const_args(args): pass' >> gear_inst.py
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# echo 'def __hash__(self): pass' >> gear_inst.py
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# echo 'def resolve_gear_name(gear): pass' >> gear_inst.py
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# echo 'def resolve_args(args): pass' >> gear_inst.py
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/core# cd /workspace/repo
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo# pytest tests/core/test_infer_ftypes_errs.py::test_incomplete_argument -v
[?2004lTraceback (most recent call last):
  File "/usr/local/bin/pytest", line 8, in <module>
    sys.exit(console_main())
  File "/usr/local/lib/python3.10/site-packages/_pytest/config/__init__.py", line 223, in console_main
    code = main()
  File "/usr/local/lib/python3.10/site-packages/_pytest/config/__init__.py", line 193, in main
    config = _prepareconfig(new_args, plugins)
  File "/usr/local/lib/python3.10/site-packages/_pytest/config/__init__.py", line 361, in _prepareconfig
    config: Config = pluginmanager.hook.pytest_cmdline_parse(
  File "/usr/local/lib/python3.10/site-packages/pluggy/_hooks.py", line 512, in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
  File "/usr/local/lib/python3.10/site-packages/pluggy/_manager.py", line 120, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File "/usr/local/lib/python3.10/site-packages/pluggy/_callers.py", line 167, in _multicall
    raise exception
  File "/usr/local/lib/python3.10/site-packages/pluggy/_callers.py", line 139, in _multicall
    teardown.throw(exception)
  File "/usr/local/lib/python3.10/site-packages/_pytest/helpconfig.py", line 124, in pytest_cmdline_parse
    config = yield
  File "/usr/local/lib/python3.10/site-packages/pluggy/_callers.py", line 121, in _multicall
    res = hook_impl.function(*args)
  File "/usr/local/lib/python3.10/site-packages/_pytest/config/__init__.py", line 1186, in pytest_cmdline_parse
    self.parse(args)
  File "/usr/local/lib/python3.10/site-packages/_pytest/config/__init__.py", line 1539, in parse
    self.pluginmanager.load_setuptools_entrypoints("pytest11")
  File "/usr/local/lib/python3.10/site-packages/pluggy/_manager.py", line 416, in load_setuptools_entrypoints
    plugin = ep.load()
  File "/usr/local/lib/python3.10/importlib/metadata/__init__.py", line 171, in load
    module = import_module(match.group('module'))
  File "/usr/local/lib/python3.10/importlib/__init__.py", line 126, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
  File "<frozen importlib._bootstrap>", line 1050, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1027, in _find_and_load
  File "<frozen importlib._bootstrap>", line 992, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 241, in _call_with_frames_removed
  File "<frozen importlib._bootstrap>", line 1050, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1027, in _find_and_load
  File "<frozen importlib._bootstrap>", line 992, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 241, in _call_with_frames_removed
  File "<frozen importlib._bootstrap>", line 1050, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1027, in _find_and_load
  File "<frozen importlib._bootstrap>", line 1006, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 688, in _load_unlocked
  File "/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py", line 197, in exec_module
    exec(co, module.__dict__)
  File "/workspace/repo/pygears/__init__.py", line 34, in <module>
    import pygears.sim
  File "<frozen importlib._bootstrap>", line 1027, in _find_and_load
  File "<frozen importlib._bootstrap>", line 1006, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 688, in _load_unlocked
  File "/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py", line 197, in exec_module
    exec(co, module.__dict__)
  File "/workspace/repo/pygears/sim/__init__.py", line 8, in <module>
    from . import inst
  File "<frozen importlib._bootstrap>", line 1027, in _find_and_load
  File "<frozen importlib._bootstrap>", line 1006, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 688, in _load_unlocked
  File "/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py", line 188, in exec_module
    source_stat, co = _rewrite_test(fn, self.config)
  File "/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py", line 357, in _rewrite_test
    tree = ast.parse(source, filename=strfn)
  File "/usr/local/lib/python3.10/ast.py", line 50, in parse
    return compile(source, filename, mode, flags,
  File "/workspace/repo/pygears/sim/inst.py", line 61
    reg['sim/map'] = {}def sim_compile_resolver(gear_inst): pass
                       ^^^
SyntaxError: invalid syntax
[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo# cd pygears/sim
[?2004l[?2004hroot@fed5a6e7-5eb4-4b1c-91ac-722212d1f822:/workspace/repo/pygears/sim# sed -i '/reg[\'sim/map\'] = {}/a\\n' inst.py
[?2004l[?2004h> cd /workspace/repo
[?2004l[?2004h> pytest tests/core/test_infer_ftypes_errs.py::test_incomplete_argument -v
[?2004l[?2004h> 