{"version": 2, "width": 160, "height": 40, "timestamp": 1770669313, "env": {"SHELL": "/bin/bash", "TERM": "tmux-256color"}}
[0.00695, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[1.026187, "i", "clear\r"]
[1.026526, "o", "clear\r\n\u001b[?2004l\r"]
[1.027628, "o", "\u001b[H\u001b[J\u001b[3J"]
[1.027789, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[5.546428, "i", "pytest tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi -v\n"]
[5.547179, "o", "pytest tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi -v\r\n\u001b[?2004l\r"]
[5.741273, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[5.743657, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[5.743719, "o", "\u001b[1mcollecting ... \u001b[0m"]
[6.576897, "o", "\u001b[1m\rcollecting 1 item                                                                                                                                              \u001b[0m"]
[6.576984, "o", "\u001b[1m\rcollected 1 item                                                                                                                                               \u001b[0m\r\n"]
[6.577184, "o", "\r\ntests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi "]
[6.824031, "o", "\u001b[31mFAILED\u001b[0m\u001b[31m                                                                                   [100%]\u001b[0m"]
[6.825176, "o", "\r\n\r\n"]
[6.825239, "o", "=========================================================================== FAILURES ===========================================================================\r\n\u001b[31m\u001b[1m__________________________________________________________ test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi ___________________________________________________________\u001b[0m\r\n\r\n"]
[6.849388, "o", "    \u001b[0m\u001b[94mdef\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[92mtest_GibbbsExcessLiquid_NoPoyNoGammaNoPhi\u001b[39;49;00m():\u001b[90m\u001b[39;49;00m\r\n        \u001b[90m# Binary ethanol-water\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\r\n        T = \u001b[94m230.0\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\r\n        P = \u001b[94m1e5\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\r\n        zs = [\u001b[94m.4\u001b[39;49;00m, \u001b[94m.6\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\r\n    \u001b[90m\u001b[39;49;00m\r\n        MWs = [\u001b[94m18.01528\u001b[39;49;00m, \u001b[94m46.06844\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\r\n        Tcs = [\u001b[94m647.14\u001b[39;49;00m, \u001b[94m514.0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\r\n        Pcs = [\u001b[94m22048320.0\u001b[39;49;00m, \u001b[94m6137000.0\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\r\n        Vcs = [\u001b[94m5.6e-05\u001b[39;49;00m, \u001b[94m0.000168\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\r\n        omegas = [\u001b[94m0.344\u001b[39;49;00m, \u001b[94m0.635\u001b[39;49;00m]\u001b[90m\u001b[39;49;00m\r\n    \u001b[90m\u001b[39;49;00m\r\n        VaporPressures = [VaporPressure(exp_poly_fit=(\u001b[94m273.17\u001b[39;49;00m, \u001b[94m647.086\u001b[39;49;00m, [-\u001b[94m2.8478502840358144e-21\u001b[39;49;00m, \u001b[94m1.7295186670575222e-17\u001b[39;49;00m, -\u001b[94m4.034229148562168e-14\u001b[39;49;00m, \u001b[94m5.0588958391215855e-11\u001b[39;49;00m, -\u001b[94m3.861625996277003e-08\u001b[39;49;00m, \u001b[94m1.886271475957639e-05\u001b[39;49;00m, -\u001b[94m0.005928371869421494\u001b[39;49;00m, \u001b[94m1.1494956887882308\u001b[39;49;00m, -\u001b[94m96.74302379151317\u001b[39;49;00m])),\u001b[90m\u001b[39;49;00m\r\n"]
[6.849512, "o", "                          VaporPressure(exp_poly_fit=(\u001b[94m159.11\u001b[39;49;00m, \u001b[94m514.7\u001b[39;49;00m, [-\u001b[94m2.3617526481119e-19\u001b[39;49;00m, \u001b[94m7.318686894378096e-16\u001b[39;49;00m, -\u001b[94m9.835941684445551e-13\u001b[39;49;00m, \u001b[94m7.518263303343784e-10\u001b[39;49;00m, -\u001b[94m3.598426432676194e-07\u001b[39;49;00m, \u001b[94m0.00011171481063640762\u001b[39;49;00m, -\u001b[94m0.022458952185007635\u001b[39;49;00m, \u001b[94m2.802615041941912\u001b[39;49;00m, -\u001b[94m166.43524219017118\u001b[39;49;00m])),]\u001b[90m\u001b[39;49;00m\r\n        HeatCapacityGases = [HeatCapacityGas(poly_fit=(\u001b[94m50.0\u001b[39;49;00m, \u001b[94m1000.0\u001b[39;49;00m, [\u001b[94m5.543665000518528e-22\u001b[39;49;00m, -\u001b[94m2.403756749600872e-18\u001b[39;49;00m, \u001b[94m4.2166477594350336e-15\u001b[39;49;00m, -\u001b[94m3.7965208514613565e-12\u001b[39;49;00m, \u001b[94m1.823547122838406e-09\u001b[39;49;00m, -\u001b[94m4.3747690853614695e-07\u001b[39;49;00m, \u001b[94m5.437938301211039e-05\u001b[39;49;00m, -\u001b[94m0.003220061088723078\u001b[39;49;00m, \u001b[94m33.32731489750759\u001b[39;49;00m])),\u001b[90m\u001b[39;49;00m\r\n                           HeatCapacityGas(poly_fit=(\u001b[94m50.0\u001b[39;49;00m, \u001b[94m1000.0\u001b[39;49;00m, [-\u001b[94m1.162767978165682e-20\u001b[39;49;00m, \u001b[94m5.4975285700787494e-17\u001b[39;49;00m, -\u001b[94m1.0861242757337942e-13\u001b[39;49;00m, \u001b[94m1.1582703354362728e-10\u001b[39;49;00m, -\u001b[94m7.160627710867427e-08\u001b[39;49;00m, \u001b[94m2.5392014654765875e-05\u001b[39;49;00m, -\u001b[94m0.004732593693568646\u001b[39;49;00m, \u001b[94m0.5072291035198603\u001b[39;49;00m, \u001b[94m20.037826650765965\u001b[39;49;00m]))]\u001b[90m\u001b[39;49;00m\r\n        \u001b[90m# HBT Pressure dependence needs Psats, Tc, Pc, omegas\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\r\n        VolumeLiquids = [VolumeLiquid(poly_fit=(\u001b[94m273.17\u001b[39;49;00m, \u001b[94m637.096\u001b[39;49;00m, [\u001b[94m9.00307261049824e-24\u001b[39;49;00m, -\u001b[94m3.097008950027417e-20\u001b[39;49;00m, \u001b[94m4.608271228765265e-17\u001b[39;49;00m, -\u001b[94m3.8726692841874345e-14\u001b[39;49;00m, \u001b[94m2.0099220218891486e-11\u001b[39;49;00m, -\u001b[94m6.596204729785676e-09\u001b[39;49;00m, \u001b[94m1.3368112879131157e-06\u001b[39;49;00m, -\u001b[94m0.00015298762503607717\u001b[39;49;00m, \u001b[94m0.007589247005014652\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\r\n                                      Psat=VaporPressures[\u001b[94m0\u001b[39;49;00m], Tc=Tcs[\u001b[94m0\u001b[39;49;00m], Pc=Pcs[\u001b[94m0\u001b[39;49;00m], omega=omegas[\u001b[94m0\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\r\n                         VolumeLiquid(poly_fit=(\u001b[94m159.11\u001b[39;49;00m, \u001b[94m504.71000000000004\u001b[39;49;00m, [\u001b[94m5.388587987308587e-23\u001b[39;49;00m, -\u001b[94m1.331077476340645e-19\u001b[39;49;00m, \u001b[94m1.4083880805283782e-16\u001b[39;49;00m, -\u001b[94m8.327187308842775e-14\u001b[39;49;00m, \u001b[94m3.006387047487587e-11\u001b[39;49;00m, -\u001b[94m6.781931902982022e-09\u001b[39;49;00m, \u001b[94m9.331209920256822e-07\u001b[39;49;00m, -\u001b[94m7.153268618320437e-05\u001b[39;49;00m, \u001b[94m0.0023871634205665524\u001b[39;49;00m]),\u001b[90m\u001b[39;49;00m\r\n                                      Psat=VaporPressures[\u001b[94m1\u001b[39;49;00m], Tc=Tcs[\u001b[94m1\u001b[39;49;00m], Pc=Pcs[\u001b[94m1\u001b[39;49;00m], omega=omegas[\u001b[94m1\u001b[39;49;00m])]\u001b[90m\u001b[39;49;00m\r\n    \u001b[90m\u001b[39;49;00m\r\n        liquid = GibbsExcessLiquid(VaporPressures=VaporPressures,HeatCapacityGases=HeatCapacityGases,\u001b[90m\u001b[39;49;00m\r\n                                   VolumeLiquids=VolumeLiquids,\u001b[90m\u001b[39;49;00m\r\n                                   use_Poynting=\u001b[94mFalse\u001b[39;49;00m,\u001b[90m\u001b[39;49;00m\r\n                                   use_phis_sat=\u001b[94mFalse\u001b[39;49;00m).to_TP_zs(T, P, zs)\u001b[90m\u001b[39;49;00m\r\n>       dH_dP_num = derivative(\u001b[94mlambda\u001b[39;49;00m P: liquid.to(T=T, P=P, zs=zs).H(), P, dx=P*\u001b[94m1e-5\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\r\n\r\n"]
[6.849564, "o", "\u001b[1m\u001b[31mtests/test_phases.py\u001b[0m:467: \r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\u001b[1m\u001b[31m/usr/local/lib/python3.10/site-packages/fluids/numerics/__init__.py\u001b[0m:880: in derivative\r\n"]
[6.849769, "o", "    \u001b[0mtot += weights[k]*func(x0 + (k - ho)*dx, *args, **kwargs)\u001b[90m\u001b[39;49;00m\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \r\n\r\nP = 99999.0\r\n\r\n"]
[6.850081, "o", ">   \u001b[0mdH_dP_num = derivative(\u001b[94mlambda\u001b[39;49;00m P: liquid.to(T=T, P=P, zs=zs).H(), P, dx=P*\u001b[94m1e-5\u001b[39;49;00m)\u001b[90m\u001b[39;49;00m\r\n\u001b[1m\u001b[31mE   AttributeError: 'NoneType' object has no attribute 'to'\u001b[0m\r\n\r\n"]
[6.850133, "o", "\u001b[1m\u001b[31mtests/test_phases.py\u001b[0m:467: AttributeError\r\n"]
[6.856261, "o", "\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mFAILED\u001b[0m tests/test_phases.py::\u001b[1mtest_GibbbsExcessLiquid_NoPoyNoGammaNoPhi\u001b[0m - AttributeError: 'NoneType' object has no attribute 'to'\r\n\u001b[31m====================================================================== \u001b[31m\u001b[1m1 failed\u001b[0m\u001b[31m in 1.11s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[6.931048, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[23.850534, "i", "cat thermo/phases/gibbs_excess.py\n"]
[23.850883, "o", "cat thermo/phases/gibbs_excess.py\r\n\u001b[?2004l\r"]
[23.854006, "o", "\"\"\"Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\r\nCopyright (C) 2019, 2020 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n\r\n\"\"\"\r\n__all__ = ['GibbsExcessLiquid', 'GibbsExcessSolid']\r\nfrom math import isinf, isnan\r\nfrom chemicals.solubility import Henry_constants, d2Henry_constants_dT2, dHenry_constants_dT\r\nfrom chemicals.utils import phase_identification_parameter\r\nfrom fluids.constants import R, R_inv\r\nfrom fluids.numerics import derivative, evaluate_linear_fits, evaluate_linear_fits_d, evaluate_linear_fits_d2, exp, horner_and_der2, log, secant, trunc_exp\r\nfrom fluids.numerics import numpy as np\r\nfrom thermo.activity import IdealSolution\r\nfrom thermo.heat_capacity import HeatCapacityGas, HeatCapacityLiquid\r\nfrom thermo.nrtl import nrtl_d2taus_dT2 as d2ln_henries_dT2\r\nfrom thermo.nrtl import nrtl_dtaus_dT as dln_henries_dT\r\nfrom thermo.nrtl import nrtl_taus as ln_henries\r\nfrom thermo.phase_change import EnthalpySublimation, EnthalpyVaporization\r\nfrom thermo.phases.phase import Phase\r\nfrom thermo.utils import POLY_FIT, TRANSFORM_DERIVATIVE_RATIO, TRANSFORM_LOG, TRANSFORM_LOG_DERIVATIVE, TRANSFORM_SECOND_DERIVATIVE_RATIO, TRANSFORM_SECOND_LOG_DERIVATIVE\r\nfrom thermo.vapor_pressure import SublimationPressure, VaporPressure\r\nfrom thermo.volume import VolumeLiquid, VolumeSolid\r\ntry:\r\n    (zeros, array) = (np.zeros, np.array)\r\nexcept:\r\n    pass\r\n\r\nclass GibbsExcessLiquid(Phase):\r\n    \"\"\"Phase based on combining Raoult's law with a\r\n    :obj:`GibbsExcess <thermo.activity.GibbsExcess>` model, optionally\r\n    including saturation fugacity coefficient corrections (if the vapor phase\r\n    is a cubic equation of state) and Poynting correction factors (if more\r\n    accuracy is desired).\r\n\r\n    The equilibrium equation options (controlled by `equilibrium_basis`)\r\n    are as follows:\r\n\r\n    * 'Psat': :math:`\\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat}}{P}`\r\n    * 'Poynting&PhiSat': :math:`\\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat} \\\\phi_i^{sat} \\\\text{Poynting}_i}{P}`\r\n    * 'Poynting': :math:`\\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat}\\\\text{Poynting}_i}{P}`\r\n    * 'PhiSat': :math:`\\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat} \\\\phi_i^{sat}}{P}`\r\n\r\n    In all cases, the activity coefficient is derived from the\r\n    :obj:`GibbsExcess <thermo.activity.GibbsExcess>` model specified as\r\n    input; use the :obj:`IdealSolution <thermo.activity.IdealSolution>`\r\n    class as an input to set the activity coefficients to one.\r\n\r\n    The enthalpy `H` and entropy `S` (and other caloric properties `U`, `G`, `A`)\r\n    equation options are similar to the equilibrium ones. If the same option\r\n    is selected for `equilibrium_basis` and `caloric_basis`, the phase will be\r\n    `thermodynamically consistent`. This is recommended for many reasons.\r\n    The full 'Poynting&PhiSat' equations for `H` and `S` are as follows; see\r\n    :obj:`GibbsExcessLiquid.H` and :obj:`GibbsExcessLiquid.S` for all of the\r\n    other equations:\r\n\r\n    .. math::\r\n        H = H_{\\\\text{excess}} + \\\\sum_i z_i \\\\left[-RT^2\\\\left(\r\n        \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\r\n        + \\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\r\n        + \\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}} \\\\right)\r\n        + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\r\n\r\n    .. math::\r\n        S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\r\n        - \\\\sum_i z_i\\\\left[R\\\\left(\r\n        T \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\r\n        + T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\r\n        + T\\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}}\r\n        + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{\\\\text{Poynting}\\\\cdot\\\\phi_{\\\\text{sat},i}}{P}\\\\right)\r\n        \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\r\n\r\n    An additional caloric mode is `Hvap`, which uses enthalpy of vaporization;\r\n    this mode can never be thermodynamically consistent, but is still widely\r\n    used.\r\n\r\n    .. math::\r\n        H = H_{\\\\text{excess}} + \\\\sum_i z_i\\\\left[-H_{vap,i}\r\n        + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\r\n\r\n    .. math::\r\n        S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\r\n        - \\\\sum_i z_i\\\\left[R\\\\left(\\\\ln P_{\\\\text{sat},i} + \\\\ln\\\\left(\\\\frac{1}{P}\\\\right)\\\\right)\r\n        + \\\\frac{H_{vap,i}}{T}\r\n        - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\r\n\r\n\r\n    .. warning::\r\n        Note that above the critical point, there is no definition for what vapor\r\n        pressure is. The vapor pressure also tends to reach zero at temperatures\r\n        in the 4-20 K range. These aspects mean extrapolation in the supercritical and\r\n        very low temperature region is critical to ensure the equations will still\r\n        converge. Extrapolation can be performed using either the equation\r\n        :math:`P^{\\\\text{sat}} = \\\\exp\\\\left(A - \\\\frac{B}{T}\\\\right)` or\r\n        :math:`P^{\\\\text{sat}} = \\\\exp\\\\left(A + \\\\frac{B}{T} + C\\\\cdot \\\\ln T\\\\right)` by\r\n        setting `Psat_extrpolation` to either 'AB' or 'ABC' respectively.\r\n        The extremely low temperature region's issue is solved by calculating the\r\n        logarithm of vapor pressures instead of the actual value. While floating\r\n        point values in Python (doubles) can reach a minimum value of around\r\n        1e-308, if only the logarithm of that number is computed no issues arise.\r\n        Both of these features only work when the vapor pressure correlations are\r\n        polynomials.\r\n\r\n    .. warning::\r\n        When using 'PhiSat' as an option, note that the factor cannot be\r\n        calculated when a compound is supercritical,\r\n        as there is no longer any vapor-liquid pure-component equilibrium\r\n        (by definition).\r\n\r\n    Parameters\r\n    ----------\r\n    VaporPressures : list[:obj:`thermo.vapor_pressure.VaporPressure`]\r\n        Objects holding vapor pressure data and methods, [-]\r\n    VolumeLiquids : list[:obj:`thermo.volume.VolumeLiquid`], optional\r\n        Objects holding liquid volume data and methods; required for Poynting\r\n        factors and volumetric properties, [-]\r\n    HeatCapacityGases : list[:obj:`thermo.heat_capacity.HeatCapacityGas`], optional\r\n        Objects proiding pure-component heat capacity correlations; required\r\n        for caloric properties, [-]\r\n    GibbsExcessModel : :obj:`GibbsExcess <thermo.activity.GibbsExcess>`, optional\r\n        Configured instance for calculating activity coefficients and excess properties;\r\n        set to :obj:`IdealSolution <thermo.activity.IdealSolution>` if not provided, [-]\r\n    eos_pure_instances : list[:obj:`thermo.eos.GCEOS`], optional\r\n        Cubic equation of state object instances for each pure component, [-]\r\n    EnthalpyVaporizations : list[:obj:`thermo.phase_change.EnthalpyVaporization`], optional\r\n        Objects holding enthalpy of vaporization data and methods; used only\r\n        with the 'Hvap' optional, [-]\r\n    HeatCapacityLiquids : list[:obj:`thermo.heat_capacity.HeatCapacityLiquid`], optional\r\n        Objects holding liquid heat capacity data and methods; not used at\r\n        present, [-]\r\n    VolumeSupercriticalLiquids : list[:obj:`thermo.volume.VolumeLiquid`], optional\r\n        Objects holding liquid volume data and methods but that are used for\r\n        supercritical temperatures on a per-component basis only; required for\r\n        Poynting factors and volumetric properties at supercritical conditions;\r\n        `VolumeLiquids` is used if not provided, [-]\r\n    Hfs : list[float], optional\r\n        Molar ideal-gas standard heats of formation at 298.15 K and 1 atm,\r\n        [J/mol]\r\n    Gfs : list[float], optional\r\n        Molar ideal-gas standard Gibbs energies of formation at 298.15 K and\r\n        1 atm, [J/mol]\r\n    T : float, optional\r\n        Temperature, [K]\r\n    P : float, optional\r\n        Pressure, [Pa]\r\n    zs : list[float], optional\r\n        Mole fractions of each component, [-]\r\n    equilibrium_basis : str, optional\r\n        Which set of equilibrium equations to use when calculating fugacities\r\n        and related properties; valid options are 'Psat', 'Poynting&PhiSat',\r\n        'Poynting', 'PhiSat', [-]\r\n    caloric_basis : str, optional\r\n        Which set of caloric equations to use when calculating fugacities\r\n        and related properties; valid options are 'Psat', 'Poynting&PhiSat',\r\n        'Poynting', 'PhiSat', 'Hvap' [-]\r\n    Psat_extrpolation : str, optional\r\n        One of 'AB' or 'ABC'; configures extrapolation for vapor pressure, [-]\r\n    henry_abcdef : tuple[list[list[float]], 6], optional\r\n        Contains the parameters used for henry's law constant, [-]\r\n    henry_as : list[list[float]], optional\r\n        `a` parameters used in calculating henry's law constant, [-]\r\n    henry_bs : list[list[float]], optional\r\n        `b` parameters used in calculating henry's law constant, [K]\r\n    henry_cs : list[list[float]], optional\r\n        `c` parameters used in calculating henry's law constant, [-]\r\n    henry_ds : list[list[float]], optional\r\n        `d` paraemeters used in calculating henry's law constant, [1/K]\r\n    henry_es : list[list[float]], optional\r\n        `e` parameters used in calculating henry's law constant, [K^2]\r\n    henry_fs : list[list[float]], optional\r\n        `f` parameters used in calculating henry's law constant, [1/K^2]\r\n    henry_mode : str\r\n        The setting for henry's law. 'solvents' to consider all\r\n        components set not to be henry's law components a solvent (if\r\n        any parameters are missing this will not make sense at all);\r\n        'solvents_with_parameters' to consider only the solvents with\r\n        parameters (vapor pressures will be used if a component has\r\n        no solvents whatsoever)\r\n\r\n    use_Hvap_caloric : bool, optional\r\n        If True, enthalpy and entropy will be calculated using ideal-gas\r\n        heat capacity and the heat of vaporization of the fluid only. This\r\n        forces enthalpy to be pressure-independent. This supersedes other\r\n        options which would otherwise impact these properties. The molar volume\r\n        of the fluid has no impact on enthalpy or entropy if this option is\r\n        True. This option is not thermodynamically consistent, but is still\r\n        often an assumption that is made.\r\n\r\n    \"\"\"\r\n    PIP_INCALCULABLE_VALUE = 2\r\n    force_phase = 'l'\r\n    phase = 'l'\r\n    is_gas = False\r\n    is_liquid = True\r\n    P_DEPENDENT_H_LIQ = True\r\n    PHI_SAT_IDEAL_TR = 0.1\r\n    _Psats_data = None\r\n    _Vms_sat_data = None\r\n    _Hvap_data = None\r\n    use_IG_Cp = True\r\n    ideal_gas_basis = True\r\n    supercritical_volumes = False\r\n    Cpls_poly_fit = False\r\n    _Cpls_data = None\r\n    _Tait_B_data = None\r\n    _Tait_C_data = None\r\n    pure_references = ('HeatCapacityGases', 'VolumeLiquids', 'VaporPressures', 'HeatCapacityLiquids', 'EnthalpyVaporizations')\r\n    pure_reference_types = (HeatCapacityGas, VolumeLiquid, VaporPressure, HeatCapacityLiquid, EnthalpyVaporization)\r\n    model_attributes = ('Hfs', 'Gfs', 'Sfs', 'GibbsExcessModel', 'eos_pure_instances', 'use_Poynting', 'use_phis_sat', 'use_Tait', 'use_eos_volume', 'henry_components', 'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'henry_mode', 'Psat_extrpolation') + pure_references\r\n    obj_references = ('GibbsExcessModel', 'eos_pure_instances', 'result', 'constants', 'correlations', 'HeatCapacityGases', 'VolumeLiquids', 'VaporPressures', 'HeatCapacityLiquids', 'EnthalpyVaporizations')\r\n    __slots__ = ('Cpgs_poly_fit', 'EnthalpyVaporizations', 'Gfs', 'GibbsExcessModel', 'HeatCapacityGases', 'HeatCapacityLiquids', 'Hfs', 'Hvap_poly_fit', 'N', 'P', 'Psat_extrpolation', 'Psats_poly_fit', 'Sfs', 'T', 'VaporPressures', 'Vms_sat_poly_fit', 'Vms_supercritical_poly_fit', 'VolumeLiquids', 'VolumeSupercriticalLiquids', '_Cpgs_data', '_model_hash', '_model_hash_ignore_phase', 'caloric_basis', 'composition_independent', 'eos_pure_instances', 'equilibrium_basis', 'has_henry_components', 'henry_as', 'henry_bs', 'henry_components', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'henry_mode', 'incompressible', 'model_id', 'use_Hvap_caloric', 'use_Poynting', 'use_Poynting_caloric', 'use_Tait', 'use_eos_volume', 'use_phis_sat', 'use_phis_sat_caloric', 'zs')\r\n\r\n    def __repr__(self):\r\n        \"\"\"Method to create a string representation of the phase object, with\r\n        the goal of making it easy to obtain standalone code which reproduces\r\n        the current state of the phase. This is extremely helpful in creating\r\n        new test cases.\r\n\r\n        Returns\r\n        -------\r\n        recreation : str\r\n            String which is valid Python and recreates the current state of\r\n            the object if ran, [-]\r\n\r\n        \"\"\"\r\n        pure_strs = ''\r\n        for k in self.pure_references:\r\n            v = getattr(self, k)\r\n            if v is not None:\r\n                try:\r\n                    s = '[' + ', '.join((str(o) for o in v)) + ']'\r\n                except:\r\n                    continue\r\n                pure_strs += f'{k}={s}, '\r\n        base = f'{self.__class__.__name__}(GibbsExcessModel={self.GibbsExcessModel},\\n               equilibrium_basis={self.equilibrium_basis}, caloric_basis={self.caloric_basis},\\n               eos_pure_instances={self.eos_pure_instances}, {pure_strs}'\r\n        for s in ('Hfs', 'Gfs', 'Sfs', 'T', 'P', 'zs'):\r\n            if hasattr(self, s) and getattr(self, s) is not None:\r\n                base += f'{s}={getattr(self, s)}, '\r\n        if base[-2:] == ', ':\r\n            base = base[:-2]\r\n        base += ')'\r\n        return base\r\n\r\n    def __init__(self, VaporPressures, VolumeLiquids=None, HeatCapacityGases=None, GibbsExcessModel=None, eos_pure_instances=None, EnthalpyVaporizations=None, HeatCapacityLiquids=None, VolumeSupercriticalLiquids=None, use_Hvap_caloric=False, use_Poynting=False, use_phis_sat=False, use_Tait=False, use_eos_volume=False, Hfs=None, Gfs=None, Sfs=None, henry_components=None, henry_abcdef=None, henry_as=None, henry_bs=None, henry_cs=None, henry_ds=None, henry_es=None, henry_fs=None, henry_mode='solvents_with_parameters', T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None, Psat_extrpolation='AB', equilibrium_basis=None, caloric_basis=None):\r\n        \"\"\"It is quite possible to introduce a PVT relation ship for liquid\r\n        density and remain thermodynamically consistent. However, must be\r\n        applied on a per-component basis! This class cannot have an\r\n        equation-of-state or VolumeLiquidMixture for a liquid MIXTURE!\r\n\r\n        (it might still be nice to generalize the handling; maybe even allow)\r\n        pure EOSs to be used too, and as a form/template for which functions to\r\n        use).\r\n\r\n        In conclusion, you have\r\n        1) The standard H/S model\r\n        2) The H/S model with all pressure correction happening at P\r\n        3) The inconsistent model which has no pressure dependence whatsover in H/S\r\n           This model is required due to its popularity, not its consistency (but still volume dependency)\r\n\r\n        All mixture volumetric properties have to be averages of the pure\r\n        components properties and derivatives. A Multiphase will be needed to\r\n        allow flashes with different properties from different phases.\r\n        \"\"\"\r\n        self.N = N = len(VaporPressures)\r\n        if zs is None:\r\n            zs = [1.0 / N] * N\r\n        if henry_components is None:\r\n            henry_components = [False] * self.N\r\n        self.has_henry_components = any(henry_components)\r\n        self.henry_components = henry_components\r\n        self.VaporPressures = VaporPressures\r\n        self.Psats_poly_fit = all((i.method == POLY_FIT for i in VaporPressures)) and (not self.has_henry_components) if VaporPressures is not None else False\r\n        self.Psat_extrpolation = Psat_extrpolation\r\n        if self.Psats_poly_fit:\r\n            Psats_data = [[i.poly_fit_Tmin for i in VaporPressures], [i.poly_fit_Tmin_slope for i in VaporPressures], [i.poly_fit_Tmin_value for i in VaporPressures], [i.poly_fit_Tmax for i in VaporPressures], [i.poly_fit_Tmax_slope for i in VaporPressures], [i.poly_fit_Tmax_value for i in VaporPressures], [i.poly_fit_coeffs for i in VaporPressures], [i.poly_fit_d_coeffs for i in VaporPressures], [i.poly_fit_d2_coeffs for i in VaporPressures], [i.DIPPR101_ABC for i in VaporPressures]]\r\n            if Psat_extrpolation == 'AB':\r\n                Psats_data.append([i.poly_fit_AB_high_ABC_compat + [0.0] for i in VaporPressures])\r\n            elif Psat_extrpolation == 'ABC':\r\n                Psats_data.append([i.DIPPR101_ABC_high for i in VaporPressures])\r\n            self._Psats_data = Psats_data\r\n        if self.vectorized:\r\n            zero_coeffs = zeros((N, N))\r\n        else:\r\n            zero_coeffs = [[0.0] * N for _ in range(N)]\r\n        self.HeatCapacityGases = HeatCapacityGases\r\n        self.HeatCapacityLiquids = HeatCapacityLiquids\r\n        if HeatCapacityLiquids is not None:\r\n            T_REF_IG = self.T_REF_IG\r\n            T_REF_IG_INV = 1.0 / T_REF_IG\r\n            self.Hvaps_T_ref = [obj(T_REF_IG) for obj in EnthalpyVaporizations]\r\n            self.dSvaps_T_ref = [T_REF_IG_INV * dH for dH in self.Hvaps_T_ref]\r\n        self.use_eos_volume = use_eos_volume\r\n        self.VolumeLiquids = VolumeLiquids\r\n        self.Vms_sat_poly_fit = not use_eos_volume and all((i.method == POLY_FIT for i in VolumeLiquids)) if VolumeLiquids is not None else False\r\n        if self.Vms_sat_poly_fit:\r\n            self._Vms_sat_data = [[i.poly_fit_Tmin for i in VolumeLiquids], [i.poly_fit_Tmin_slope for i in VolumeLiquids], [i.poly_fit_Tmin_value for i in VolumeLiquids], [i.poly_fit_Tmax for i in VolumeLiquids], [i.poly_fit_Tmax_slope for i in VolumeLiquids], [i.poly_fit_Tmax_value for i in VolumeLiquids], [i.poly_fit_coeffs for i in VolumeLiquids], [i.poly_fit_d_coeffs for i in VolumeLiquids], [i.poly_fit_d2_coeffs for i in VolumeLiquids], [i.poly_fit_Tmin_quadratic for i in VolumeLiquids]]\r\n        self.VolumeSupercriticalLiquids = VolumeSupercriticalLiquids\r\n        self.Vms_supercritical_poly_fit = all((i.method == POLY_FIT for i in VolumeSupercriticalLiquids)) if VolumeSupercriticalLiquids is not None else False\r\n        if self.Vms_supercritical_poly_fit:\r\n            self.Vms_supercritical_data = [[i.poly_fit_Tmin for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmin_slope for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmin_value for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmax for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmax_slope for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmax_value for i in VolumeSupercriticalLiquids], [i.poly_fit_coeffs for i in VolumeSupercriticalLiquids], [i.poly_fit_d_coeffs for i in VolumeSupercriticalLiquids], [i.poly_fit_d2_coeffs for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmin_quadratic for i in VolumeSupercriticalLiquids]]\r\n        self.incompressible = not use_Tait\r\n        self.use_Tait = use_Tait\r\n        if self.use_Tait:\r\n            (Tait_B_data, Tait_C_data) = ([[] for i in range(9)], [[] for i in range(9)])\r\n            for v in VolumeLiquids:\r\n                for (d, store) in zip(v.Tait_data(), [Tait_B_data, Tait_C_data]):\r\n                    for i in range(len(d)):\r\n                        store[i].append(d[i])\r\n            self._Tait_B_data = Tait_B_data\r\n            self._Tait_C_data = Tait_C_data\r\n        self.EnthalpyVaporizations = EnthalpyVaporizations\r\n        self.Hvap_poly_fit = all((i.method == POLY_FIT for i in EnthalpyVaporizations)) if EnthalpyVaporizations is not None else False\r\n        if self.Hvap_poly_fit:\r\n            self._Hvap_data = [[i.poly_fit_Tmin for i in EnthalpyVaporizations], [i.poly_fit_Tmax for i in EnthalpyVaporizations], [i.poly_fit_Tc for i in EnthalpyVaporizations], [1.0 / i.poly_fit_Tc for i in EnthalpyVaporizations], [i.poly_fit_coeffs for i in EnthalpyVaporizations]]\r\n        if GibbsExcessModel is None:\r\n            GibbsExcessModel = IdealSolution(T=T, xs=zs)\r\n        self.GibbsExcessModel = GibbsExcessModel\r\n        self.eos_pure_instances = eos_pure_instances\r\n        self.equilibrium_basis = equilibrium_basis\r\n        self.caloric_basis = caloric_basis\r\n        if equilibrium_basis is not None:\r\n            if equilibrium_basis == 'Poynting':\r\n                self.use_Poynting = True\r\n                self.use_phis_sat = False\r\n            elif equilibrium_basis == 'Poynting&PhiSat':\r\n                self.use_Poynting = True\r\n                self.use_phis_sat = True\r\n            elif equilibrium_basis == 'PhiSat':\r\n                self.use_phis_sat = True\r\n                self.use_Poynting = False\r\n            elif equilibrium_basis == 'Psat':\r\n                self.use_phis_sat = False\r\n                self.use_Poynting = False\r\n        else:\r\n            self.use_Poynting = use_Poynting\r\n            self.use_phis_sat = use_phis_sat\r\n        if caloric_basis is not None:\r\n            if caloric_basis == 'Poynting':\r\n                self.use_Poynting_caloric = True\r\n                self.use_phis_sat_caloric = False\r\n                self.use_Hvap_caloric = False\r\n            elif caloric_basis == 'Poynting&PhiSat':\r\n                self.use_Poynting_caloric = True\r\n                self.use_phis_sat_caloric = True\r\n                self.use_Hvap_caloric = False\r\n            elif caloric_basis == 'PhiSat':\r\n                self.use_phis_sat_caloric = True\r\n                self.use_Poynting_caloric = False\r\n                self.use_Hvap_caloric = False\r\n            elif caloric_basis == 'Psat':\r\n                self.use_phis_sat_caloric = False\r\n                self.use_Poynting_caloric = False\r\n                self.use_Hvap_caloric = False\r\n            elif caloric_basis == 'Hvap':\r\n                self.use_phis_sat_caloric = False\r\n                self.use_Poynting_caloric = False\r\n                self.use_Hvap_caloric = True\r\n        else:\r\n            self.use_Poynting_caloric = use_Poynting\r\n            self.use_phis_sat_caloric = use_phis_sat\r\n            self.use_Hvap_caloric = use_Hvap_caloric\r\n        if henry_mode not in ('solvents', 'solvents_with_parameters'):\r\n            raise ValueError(\"Henry's law model setting not recognized\")\r\n        self.henry_mode = henry_mode\r\n        multiple_henry_inputs = (henry_as, henry_bs, henry_cs, henry_ds, henry_es, henry_fs)\r\n        input_count_henry = (henry_abcdef is not None) + any((i is not None for i in multiple_henry_inputs))\r\n        if input_count_henry > 1:\r\n            raise ValueError('Input only one of henry_abcdef, or (henry_as...henry_fs)')\r\n        if henry_abcdef is not None:\r\n            if self.vectorized:\r\n                self.henry_as = array(henry_abcdef[:, :, 0], order='C', copy=True)\r\n                self.henry_bs = array(henry_abcdef[:, :, 1], order='C', copy=True)\r\n                self.henry_cs = array(henry_abcdef[:, :, 2], order='C', copy=True)\r\n                self.henry_ds = array(henry_abcdef[:, :, 3], order='C', copy=True)\r\n                self.henry_es = array(henry_abcdef[:, :, 4], order='C', copy=True)\r\n                self.henry_fs = array(henry_abcdef[:, :, 5], order='C', copy=True)\r\n            else:\r\n                self.henry_as = [[i[0] for i in l] for l in henry_abcdef]\r\n                self.henry_bs = [[i[1] for i in l] for l in henry_abcdef]\r\n                self.henry_cs = [[i[2] for i in l] for l in henry_abcdef]\r\n                self.henry_ds = [[i[3] for i in l] for l in henry_abcdef]\r\n                self.henry_es = [[i[4] for i in l] for l in henry_abcdef]\r\n                self.henry_fs = [[i[5] for i in l] for l in henry_abcdef]\r\n        else:\r\n            if henry_abcdef is None:\r\n                henry_abcdef = multiple_henry_inputs\r\n            henry_abcdef_len = 0 if henry_abcdef is None else len(henry_abcdef)\r\n            if not henry_abcdef_len or henry_abcdef[0] is None:\r\n                self.henry_as = zero_coeffs\r\n            else:\r\n                self.henry_as = henry_abcdef[0]\r\n            if not henry_abcdef_len or henry_abcdef[1] is None:\r\n                self.henry_bs = zero_coeffs\r\n            else:\r\n                self.henry_bs = henry_abcdef[1]\r\n            if not henry_abcdef_len or henry_abcdef[2] is None:\r\n                self.henry_cs = zero_coeffs\r\n            else:\r\n                self.henry_cs = henry_abcdef[2]\r\n            if not henry_abcdef_len or henry_abcdef[3] is None:\r\n                self.henry_ds = zero_coeffs\r\n            else:\r\n                self.henry_ds = henry_abcdef[3]\r\n            if not henry_abcdef_len or henry_abcdef[4] is None:\r\n                self.henry_es = zero_coeffs\r\n            else:\r\n                self.henry_es = henry_abcdef[4]\r\n            if not henry_abcdef_len or henry_abcdef[5] is None:\r\n                self.henry_fs = zero_coeffs\r\n            else:\r\n                self.henry_fs = henry_abcdef[5]\r\n        self.composition_independent = isinstance(GibbsExcessModel, IdealSolution) and (not self.has_henry_components)\r\n        self.Hfs = Hfs\r\n        self.Gfs = Gfs\r\n        self.Sfs = Sfs\r\n        self.model_id = 20000 + GibbsExcessModel.model_id\r\n        if T is not None and P is not None and (zs is not None):\r\n            self.T = T\r\n            self.P = P\r\n            self.zs = zs\r\n\r\n    def to_TP_zs(self, T, P, zs):\r\n        \"\"\"\r\n        TODO: Implement this function\r\n        \"\"\"\r\n        ...\r\n\r\n    def to(self, zs, T=None, P=None, V=None):\r\n        \"\"\"\r\n        TODO: Implement this function\r\n        \"\"\"\r\n        ...\r\n    supports_lnphis_args = False\r\n\r\n    def lnphis_args(self):\r\n        try:\r\n            return self._lnphis_args\r\n        except:\r\n            pass\r\n        lnPsats = self.lnPsats()\r\n        Poyntings = self.Poyntings()\r\n        phis_sat = self.phis_sat()\r\n        activity_args = self.GibbsExcessModel.gammas_args()\r\n        lnphis = zeros(self.N) if self.vectorized else [0.0] * self.N\r\n        self._lnphis_args = (self.model_id, self.T, self.P, self.N, lnPsats, Poyntings, phis_sat) + activity_args + (lnphis,)\r\n        return self._lnphis_args\r\n\r\n    def lnHenry_matrix(self):\r\n        \"\"\"Method to calculate and return the matrix of log Henry's law constants\r\n        as required by the traditional mixing rule, [-].\r\n\r\n        .. math::\r\n            \\\\ln \\\\text{H}_{i,j} = A_{ij}+\\\\frac{B_{ij}}{T}+C_{ij}\\\\ln T + D_{ij}T\r\n            + \\\\frac{E_{ij}}{T^2} + F_{ij}{T^2}\r\n\r\n        Returns\r\n        -------\r\n        lnHenry_matrix : list[list[float]]\r\n            Henry's law interaction parameters, [log(Pa)]\r\n\r\n        Notes\r\n        -----\r\n        Solvent/solvent and gas/gas values are all 0.\r\n        \"\"\"\r\n        try:\r\n            return self._lnHenry_matrix\r\n        except:\r\n            pass\r\n        N = self.N\r\n        if self.vectorized:\r\n            lnHenry_matrix = zeros((N, N))\r\n        else:\r\n            lnHenry_matrix = [[0.0] * N for _ in range(N)]\r\n        lnHenry_matrix = ln_henries(self.T, N, self.henry_as, self.henry_bs, self.henry_cs, self.henry_ds, self.henry_es, self.henry_fs, lnHenry_matrix)\r\n        self._lnHenry_matrix = lnHenry_matrix\r\n        return lnHenry_matrix\r\n\r\n    def dlnHenry_matrix_dT(self):\r\n        \"\"\"Method to calculate and return the first temperature derivative\r\n        of the matrix of log Henry's law constants\r\n        as required by the traditional mixing rule, [-].\r\n\r\n        Returns\r\n        -------\r\n        dlnHenry_matrix_dT : list[list[float]]\r\n            First temperature derivative of Henry's law interaction\r\n            parameters, [log(Pa)/K]\r\n\r\n        Notes\r\n        -----\r\n        \"\"\"\r\n        try:\r\n            return self._dlnHenry_matrix_dT\r\n        except:\r\n            pass\r\n        N = self.N\r\n        if self.vectorized:\r\n            dlnHenry_matrix_dT = zeros((N, N))\r\n        else:\r\n            dlnHenry_matrix_dT = [[0.0] * N for _ in range(N)]\r\n        dlnHenry_matrix_dT = dln_henries_dT(self.T, N, self.henry_bs, self.henry_cs, self.henry_ds, self.henry_es, self.henry_fs, dlnHenry_matrix_dT)\r\n        self._dlnHenry_matrix_dT = dlnHenry_matrix_dT\r\n        return dlnHenry_matrix_dT\r\n\r\n    def d2lnHenry_matrix_dT2(self):\r\n        \"\"\"Method to calculate and return the second temperature derivative\r\n        of the matrix of log Henry's law constants\r\n        as required by the traditional mixing rule, [-].\r\n\r\n        Returns\r\n        -------\r\n        d2lnHenry_matrix_dT2 : list[list[float]]\r\n            Second temperature derivative of Henry's law interaction\r\n            parameters, [log(Pa)/K]\r\n\r\n        Notes\r\n        -----\r\n        \"\"\"\r\n        try:\r\n            return self._d2lnHenry_matrix_dT2\r\n        except:\r\n            pass\r\n        N = self.N\r\n        if self.vectorized:\r\n            d2lnHenry_matrix_dT2 = zeros((N, N))\r\n        else:\r\n            d2lnHenry_matrix_dT2 = [[0.0] * N for _ in range(N)]\r\n        d2lnHenry_matrix_dT2 = d2ln_henries_dT2(self.T, N, self.henry_bs, self.henry_cs, self.henry_es, self.henry_fs, d2lnHenry_matrix_dT2)\r\n        self._d2lnHenry_matrix_dT2 = d2lnHenry_matrix_dT2\r\n        return d2lnHenry_matrix_dT2\r\n\r\n    def Henry_constants(self):\r\n        (zs, vectorized, N, henry_components, henry_mode) = (self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode)\r\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\r\n        lnHenry_matrix = self.lnHenry_matrix()\r\n        Hs = zeros(N) if vectorized else [0.0] * N\r\n        Henry_constants(lnHenry_matrix, zs, henry_components, solvents_with_parameters, Hs)\r\n        return Hs\r\n\r\n    def dHenry_constants_dT(self):\r\n        (zs, vectorized, N, henry_components, henry_mode) = (self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode)\r\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\r\n        lnHenry_matrix = self.lnHenry_matrix()\r\n        dlnHenry_matrix_dT = self.dlnHenry_matrix_dT()\r\n        dHs = zeros(N) if vectorized else [0.0] * N\r\n        dHenry_constants_dT(lnHenry_matrix, dlnHenry_matrix_dT, zs, henry_components, solvents_with_parameters, dHs)\r\n        return dHs\r\n\r\n    def d2Henry_constants_dT2(self):\r\n        (zs, vectorized, N, henry_components, henry_mode) = (self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode)\r\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\r\n        lnHenry_matrix = self.lnHenry_matrix()\r\n        dlnHenry_matrix_dT = self.dlnHenry_matrix_dT()\r\n        d2lnHenry_matrix_dT2 = self.d2lnHenry_matrix_dT2()\r\n        d2Hs = zeros(N) if vectorized else [0.0] * N\r\n        d2Henry_constants_dT2(lnHenry_matrix, dlnHenry_matrix_dT, d2lnHenry_matrix_dT2, zs, henry_components, solvents_with_parameters, d2Hs)\r\n        return d2Hs\r\n\r\n    def Psats_T_ref(self):\r\n        try:\r\n            return self._Psats_T_ref\r\n        except AttributeError:\r\n            pass\r\n        (VaporPressures, N) = (self.VaporPressures, self.N)\r\n        T_REF_IG = self.T_REF_IG\r\n        if self.has_henry_components:\r\n            self._Psats_T_ref = self.to(T=T_REF_IG, P=self.P, zs=self.zs).Psats()\r\n        else:\r\n            self._Psats_T_ref = [VaporPressures[i](T_REF_IG) for i in range(N)]\r\n        return self._Psats_T_ref\r\n\r\n    def Psats_at(self, T):\r\n        if self.Psats_poly_fit:\r\n            return self._Psats_at_poly_fit(T, self._Psats_data, range(self.N))\r\n        if self.has_henry_components:\r\n            return self.to(T=T, P=self.P, zs=self.zs).Psats()\r\n        VaporPressures = self.VaporPressures\r\n        return [VaporPressures[i](T) for i in range(self.N)]\r\n\r\n    @staticmethod\r\n    def _Psats_at_poly_fit(T, Psats_data, cmps):\r\n        Psats = []\r\n        T_inv = 1.0 / T\r\n        logT = log(T)\r\n        (Tmins, Tmaxes, coeffs) = (Psats_data[0], Psats_data[3], Psats_data[6])\r\n        for i in cmps:\r\n            if T < Tmins[i]:\r\n                (A, B, C) = Psats_data[9][i]\r\n                Psat = A + B * T_inv + C * logT\r\n            elif T > Tmaxes[i]:\r\n                (A, B, C) = Psats_data[10][i]\r\n                Psat = A + B * T_inv + C * logT\r\n            else:\r\n                Psat = 0.0\r\n                for c in coeffs[i]:\r\n                    Psat = Psat * T + c\r\n            try:\r\n                Psats.append(exp(Psat))\r\n            except:\r\n                Psats.append(1.6549840276802644e+300)\r\n        return Psats\r\n\r\n    def Psats(self):\r\n        try:\r\n            return self._Psats\r\n        except AttributeError:\r\n            pass\r\n        N = self.N\r\n        (T, cmps) = (self.T, range(N))\r\n        if self.Psats_poly_fit:\r\n            self._Psats = Psats = self._Psats_at_poly_fit(T, self._Psats_data, cmps)\r\n        else:\r\n            self._Psats = Psats = []\r\n            for i in self.VaporPressures:\r\n                Psats.append(i.T_dependent_property(T))\r\n        if self.has_henry_components:\r\n            (Hs, henry_components) = (self.Henry_constants(), self.henry_components)\r\n            for i in range(N):\r\n                if henry_components[i]:\r\n                    Psats[i] = Hs[i]\r\n        return Psats\r\n\r\n    def PIP(self):\r\n        dP_dT = self.dP_dT()\r\n        if dP_dT == 0:\r\n            return self.PIP_INCALCULABLE_VALUE\r\n        return phase_identification_parameter(self.V(), self.dP_dT(), self.dP_dV(), self.d2P_dV2(), self.d2P_dTdV())\r\n\r\n    @staticmethod\r\n    def _dPsats_dT_at_poly_fit(T, Psats_data, cmps, Psats):\r\n        T_inv = 1.0 / T\r\n        Tinv2 = T_inv * T_inv\r\n        dPsats_dT = []\r\n        (Tmins, Tmaxes, dcoeffs, coeffs_low, coeffs_high) = (Psats_data[0], Psats_data[3], Psats_data[7], Psats_data[9], Psats_data[10])\r\n        for i in cmps:\r\n            if T < Tmins[i]:\r\n                dPsat_dT = Psats[i] * (-coeffs_low[i][1] * Tinv2 + coeffs_low[i][2] * T_inv)\r\n            elif T > Tmaxes[i]:\r\n                dPsat_dT = Psats[i] * (-coeffs_high[i][1] * Tinv2 + coeffs_high[i][2] * T_inv)\r\n            else:\r\n                dPsat_dT = 0.0\r\n                for c in dcoeffs[i]:\r\n                    dPsat_dT = dPsat_dT * T + c\r\n                dPsat_dT *= Psats[i]\r\n            dPsats_dT.append(dPsat_dT)\r\n        return dPsats_dT\r\n\r\n    def dPsats_dT_at(self, T, Psats=None):\r\n        if Psats is None:\r\n            Psats = self.Psats_at(T)\r\n        if self.Psats_poly_fit:\r\n            return self._dPsats_dT_at_poly_fit(T, self._Psats_data, range(self.N), Psats)\r\n        if self.has_henry_components:\r\n            return self.to(T=T, P=self.P, zs=self.zs).dPsats_dT()\r\n        return [VaporPressure.T_dependent_property_derivative(T=T) for VaporPressure in self.VaporPressures]\r\n\r\n    def dPsats_dT(self):\r\n        try:\r\n            return self._dPsats_dTT_dependent_property_derivative\r\n        except:\r\n            pass\r\n        (T, N) = (self.T, self.N)\r\n        if self.Psats_poly_fit:\r\n            try:\r\n                Psats = self._Psats\r\n            except AttributeError:\r\n                Psats = self.Psats()\r\n            self._dPsats_dT = dPsats_dT = self._dPsats_dT_at_poly_fit(T, self._Psats_data, range(N), Psats)\r\n            return dPsats_dT\r\n        self._dPsats_dT = dPsats_dT = [VaporPressure.T_dependent_property_derivative(T=T) for VaporPressure in self.VaporPressures]\r\n        if self.has_henry_components:\r\n            (dHs, henry_components) = (self.dHenry_constants_dT(), self.henry_components)\r\n            for i in range(N):\r\n                if henry_components[i]:\r\n                    dPsats_dT[i] = dHs[i]\r\n        return dPsats_dT\r\n\r\n    def d2Psats_dT2(self):\r\n        try:\r\n            return self._d2Psats_dT2\r\n        except:\r\n            pass\r\n        try:\r\n            Psats = self._Psats\r\n        except AttributeError:\r\n            Psats = self.Psats()\r\n        try:\r\n            dPsats_dT = self._dPsats_dT\r\n        except AttributeError:\r\n            dPsats_dT = self.dPsats_dT()\r\n        (T, N) = (self.T, self.N)\r\n        T_inv = 1.0 / T\r\n        T_inv2 = T_inv * T_inv\r\n        self._d2Psats_dT2 = d2Psats_dT2 = []\r\n        if self.Psats_poly_fit:\r\n            Psats_data = self._Psats_data\r\n            (Tmins, Tmaxes, d2coeffs) = (Psats_data[0], Psats_data[3], Psats_data[8])\r\n            for i in range(N):\r\n                if T < Tmins[i]:\r\n                    (A, B, C) = Psats_data[9][i]\r\n                    x0 = B * T_inv - C\r\n                    d2Psat_dT2 = Psats[i] * (2.0 * B * T_inv - C + x0 * x0) * T_inv2\r\n                elif T > Tmaxes[i]:\r\n                    (A, B, C) = Psats_data[10][i]\r\n                    x0 = B * T_inv - C\r\n                    d2Psat_dT2 = Psats[i] * (2.0 * B * T_inv - C + x0 * x0) * T_inv2\r\n                else:\r\n                    d2Psat_dT2 = 0.0\r\n                    for c in d2coeffs[i]:\r\n                        d2Psat_dT2 = d2Psat_dT2 * T + c\r\n                    d2Psat_dT2 = dPsats_dT[i] * dPsats_dT[i] / Psats[i] + Psats[i] * d2Psat_dT2\r\n                d2Psats_dT2.append(d2Psat_dT2)\r\n            return d2Psats_dT2\r\n        self._d2Psats_dT2 = d2Psats_dT2 = [VaporPressure.T_dependent_property_derivative(T=T, order=2) for VaporPressure in self.VaporPressures]\r\n        if self.has_henry_components:\r\n            (d2Hs, henry_components) = (self.d2Henry_constants_dT2(), self.henry_components)\r\n            for i in range(N):\r\n                if henry_components[i]:\r\n                    d2Psats_dT2[i] = d2Hs[i]\r\n        return d2Psats_dT2\r\n\r\n    def lnPsats(self):\r\n        try:\r\n            return self._lnPsats\r\n        except AttributeError:\r\n            pass\r\n        (T, N) = (self.T, self.N)\r\n        T_inv = 1.0 / T\r\n        logT = log(T)\r\n        lnPsats = []\r\n        if self.Psats_poly_fit:\r\n            Psats_data = self._Psats_data\r\n            (Tmins, Tmaxes, coeffs) = (Psats_data[0], Psats_data[3], Psats_data[6])\r\n            for i in range(N):\r\n                if T < Tmins[i]:\r\n                    (A, B, C) = Psats_data[9][i]\r\n                    Psat = A + B * T_inv + C * logT\r\n                elif T > Tmaxes[i]:\r\n                    (A, B, C) = Psats_data[10][i]\r\n                    Psat = A + B * T_inv + C * logT\r\n                else:\r\n                    Psat = 0.0\r\n                    for c in coeffs[i]:\r\n                        Psat = Psat * T + c\r\n                lnPsats.append(Psat)\r\n            self._lnPsats = lnPsats\r\n            return lnPsats\r\n        self._lnPsats = lnPsats = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_LOG) for VaporPressure in self.VaporPressures]\r\n        if self.has_henry_components:\r\n            (Hs, henry_components) = (self.Henry_constants(), self.henry_components)\r\n            for i in range(N):\r\n                if henry_components[i]:\r\n                    lnPsats[i] = log(Hs[i])\r\n        return lnPsats\r\n\r\n    def dlnPsats_dT(self):\r\n        (T, N) = (self.T, self.N)\r\n        T_inv = 1.0 / T\r\n        Tinv2 = T_inv * T_inv\r\n        if self.Psats_poly_fit:\r\n            Psats_data = self._Psats_data\r\n            (Tmins, Tmaxes, dcoeffs) = (Psats_data[0], Psats_data[3], Psats_data[7])\r\n            dlnPsats_dT = []\r\n            for i in range(N):\r\n                if T < Tmins[i]:\r\n                    (A, B, C) = Psats_data[9][i]\r\n                    dPsat_dT = -B * Tinv2 + C * T_inv\r\n                elif T > Tmaxes[i]:\r\n                    (A, B, C) = Psats_data[10][i]\r\n                    dPsat_dT = -B * Tinv2 + C * T_inv\r\n                else:\r\n                    dPsat_dT = 0.0\r\n                    for c in dcoeffs[i]:\r\n                        dPsat_dT = dPsat_dT * T + c\r\n                dlnPsats_dT.append(dPsat_dT)\r\n            return dlnPsats_dT\r\n        dlnPsats_dT = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_LOG_DERIVATIVE) for VaporPressure in self.VaporPressures]\r\n        if self.has_henry_components:\r\n            (Hs, dHs, henry_components) = (self.Henry_constants(), self.dHenry_constants_dT(), self.henry_components)\r\n            for i in range(N):\r\n                if henry_components[i]:\r\n                    dlnPsats_dT[i] = dHs[i] / Hs[i]\r\n        return dlnPsats_dT\r\n\r\n    def d2lnPsats_dT2(self):\r\n        (T, N) = (self.T, self.N)\r\n        T_inv = 1.0 / T\r\n        T_inv2 = T_inv * T_inv\r\n        if self.Psats_poly_fit:\r\n            Psats_data = self._Psats_data\r\n            (Tmins, Tmaxes, d2coeffs) = (Psats_data[0], Psats_data[3], Psats_data[8])\r\n            d2lnPsats_dT2 = []\r\n            for i in range(N):\r\n                if T < Tmins[i]:\r\n                    (A, B, C) = Psats_data[9][i]\r\n                    d2lnPsat_dT2 = (2.0 * B * T_inv - C) * T_inv2\r\n                elif T > Tmaxes[i]:\r\n                    (A, B, C) = Psats_data[10][i]\r\n                    d2lnPsat_dT2 = (2.0 * B * T_inv - C) * T_inv2\r\n                else:\r\n                    d2lnPsat_dT2 = 0.0\r\n                    for c in d2coeffs[i]:\r\n                        d2lnPsat_dT2 = d2lnPsat_dT2 * T + c\r\n                d2lnPsats_dT2.append(d2lnPsat_dT2)\r\n            return d2lnPsats_dT2\r\n        d2lnPsats_dT2 = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_SECOND_LOG_DERIVATIVE) for VaporPressure in self.VaporPressures]\r\n        if self.has_henry_components:\r\n            (Hs, dHs, d2Hs, henry_components) = (self.Henry_constants(), self.dHenry_constants_dT(), self.d2Henry_constants_dT2(), self.henry_components)\r\n            for i in range(N):\r\n                if henry_components[i]:\r\n                    d2lnPsats_dT2[i] = (d2Hs[i] - dHs[i] * dHs[i] / Hs[i]) / Hs[i]\r\n        return d2lnPsats_dT2\r\n\r\n    def d2Psats_dT2_over_Psats(self):\r\n        try:\r\n            return self._d2Psats_dT2_over_Psats\r\n        except AttributeError:\r\n            pass\r\n        (T, N) = (self.T, self.N)\r\n        T_inv = 1.0 / T\r\n        Tinv2 = T_inv * T_inv\r\n        Tinv4 = Tinv2 * Tinv2\r\n        c0 = (T + T) * Tinv4\r\n        if self.Psats_poly_fit:\r\n            d2Psat_dT2_over_Psats = []\r\n            Psats_data = self._Psats_data\r\n            (Tmins, Tmaxes, dcoeffs, low_coeffs, high_coeffs) = (Psats_data[0], Psats_data[3], Psats_data[7], Psats_data[9], Psats_data[10])\r\n            for i in range(N):\r\n                if T < Tmins[i]:\r\n                    (B, C) = (low_coeffs[i][1], low_coeffs[i][2])\r\n                    x0 = B - C * T\r\n                    d2Psat_dT2_over_Psat = c0 * B - C * Tinv2 + x0 * x0 * Tinv4\r\n                elif T > Tmaxes[i]:\r\n                    (B, C) = (high_coeffs[i][1], high_coeffs[i][2])\r\n                    x0 = B - C * T\r\n                    d2Psat_dT2_over_Psat = c0 * B - C * Tinv2 + x0 * x0 * Tinv4\r\n                else:\r\n                    dPsat_dT = 0.0\r\n                    d2Psat_dT2 = 0.0\r\n                    for a in dcoeffs[i]:\r\n                        d2Psat_dT2 = T * d2Psat_dT2 + dPsat_dT\r\n                        dPsat_dT = T * dPsat_dT + a\r\n                    d2Psat_dT2_over_Psat = dPsat_dT * dPsat_dT + d2Psat_dT2\r\n                d2Psat_dT2_over_Psats.append(d2Psat_dT2_over_Psat)\r\n            self._d2Psats_dT2_over_Psats = d2Psat_dT2_over_Psats\r\n            return d2Psat_dT2_over_Psats\r\n        d2Psat_dT2_over_Psats = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_SECOND_DERIVATIVE_RATIO) for VaporPressure in self.VaporPressures]\r\n        if self.has_henry_components:\r\n            (Hs, d2Henry_constants_dT2, henry_components) = (self.Henry_constants(), self.d2Henry_constants_dT2(), self.henry_components)\r\n            for i in range(N):\r\n                if henry_components[i]:\r\n                    d2Psat_dT2_over_Psats[i] = d2Henry_constants_dT2[i] / Hs[i]\r\n        self._d2Psats_dT2_over_Psats = d2Psat_dT2_over_Psats\r\n        return d2Psat_dT2_over_Psats\r\n\r\n    @staticmethod\r\n    def _Vms_sat_at(T, Vms_sat_data, cmps):\r\n        (Tmins, Tmaxes, coeffs, coeffs_Tmin) = (Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[6], Vms_sat_data[9])\r\n        Vms_sat = []\r\n        for i in cmps:\r\n            if T < Tmins[i]:\r\n                Vm = 0.0\r\n                for c in coeffs_Tmin[i]:\r\n                    Vm = Vm * T + c\r\n            elif T > Tmaxes[i]:\r\n                Vm = (T - Tmaxes[i]) * Vms_sat_data[4][i] + Vms_sat_data[5][i]\r\n            else:\r\n                Vm = 0.0\r\n                for c in coeffs[i]:\r\n                    Vm = Vm * T + c\r\n            Vms_sat.append(Vm)\r\n        return Vms_sat\r\n\r\n    def Vms_sat_at(self, T):\r\n        if self.Vms_sat_poly_fit:\r\n            return self._Vms_sat_at(T, self._Vms_sat_data, range(self.N))\r\n        VolumeLiquids = self.VolumeLiquids\r\n        return [VolumeLiquids[i].T_dependent_property(T) for i in range(self.N)]\r\n\r\n    def Vms_sat(self):\r\n        try:\r\n            return self._Vms_sat\r\n        except AttributeError:\r\n            pass\r\n        T = self.T\r\n        if self.Vms_sat_poly_fit:\r\n            self._Vms_sat = Vms_sat = self._Vms_sat_at(T, self._Vms_sat_data, range(self.N))\r\n            return Vms_sat\r\n        elif self.use_eos_volume:\r\n            Vms = []\r\n            eoss = self.eos_pure_instances\r\n            Psats = self.Psats()\r\n            for (i, e) in enumerate(eoss):\r\n                if T < e.Tc:\r\n                    Vms.append(e.V_l_sat(T))\r\n                else:\r\n                    e = e.to(T=T, P=Psats[i])\r\n                    try:\r\n                        Vms.append(e.V_l)\r\n                    except:\r\n                        Vms.append(e.V_g)\r\n            self._Vms_sat = Vms\r\n            return Vms\r\n        VolumeLiquids = self.VolumeLiquids\r\n        self._Vms_sat = [VolumeLiquids[i].T_dependent_property(T) for i in range(self.N)]\r\n        return self._Vms_sat\r\n\r\n    @staticmethod\r\n    def _dVms_sat_dT_at(T, Vms_sat_data, cmps):\r\n        Vms_sat_dT = []\r\n        (Tmins, Tmaxes, dcoeffs) = (Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[7])\r\n        for i in cmps:\r\n            if T < Tmins[i]:\r\n                dVm = horner_and_der2(Vms_sat_data[9][i], T)[1]\r\n            elif T > Tmaxes[i]:\r\n                dVm = Vms_sat_data[4][i]\r\n            else:\r\n                dVm = 0.0\r\n                for c in dcoeffs[i]:\r\n                    dVm = dVm * T + c\r\n            Vms_sat_dT.append(dVm)\r\n        return Vms_sat_dT\r\n\r\n    def dVms_sat_dT_at(self, T):\r\n        if self.Vms_sat_poly_fit:\r\n            return self._dVms_sat_dT_at(T, self._Vms_sat_data, range(self.N))\r\n        return [obj.T_dependent_property_derivative(T=T) for obj in self.VolumeLiquids]\r\n\r\n    def dVms_sat_dT(self):\r\n        try:\r\n            return self._Vms_sat_dT\r\n        except:\r\n            pass\r\n        T = self.T\r\n        if self.Vms_sat_poly_fit:\r\n            self._Vms_sat_dT = self._dVms_sat_dT_at(T, self._Vms_sat_data, range(self.N))\r\n            return self._Vms_sat_dT\r\n        VolumeLiquids = self.VolumeLiquids\r\n        self._Vms_sat_dT = Vms_sat_dT = [obj.T_dependent_property_derivative(T=T) for obj in VolumeLiquids]\r\n        return Vms_sat_dT\r\n\r\n    def d2Vms_sat_dT2(self):\r\n        try:\r\n            return self._d2Vms_sat_dT2\r\n        except:\r\n            pass\r\n        T = self.T\r\n        if self.Vms_sat_poly_fit:\r\n            d2Vms_sat_dT2 = self._d2Vms_sat_dT2 = []\r\n            Vms_sat_data = self._Vms_sat_data\r\n            (Tmins, Tmaxes, d2coeffs) = (Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[8])\r\n            for i in range(self.N):\r\n                d2Vm = 0.0\r\n                if Tmins[i] < T < Tmaxes[i]:\r\n                    for c in d2coeffs[i]:\r\n                        d2Vm = d2Vm * T + c\r\n                elif T < Tmins[i]:\r\n                    d2Vm = horner_and_der2(Vms_sat_data[9][i], T)[2]\r\n                d2Vms_sat_dT2.append(d2Vm)\r\n            return d2Vms_sat_dT2\r\n        VolumeLiquids = self.VolumeLiquids\r\n        self._d2Vms_sat_dT2 = [obj.T_dependent_property_derivative(T=T, order=2) for obj in VolumeLiquids]\r\n        return self._d2Vms_sat_dT2\r\n\r\n    def Vms_sat_T_ref(self):\r\n        try:\r\n            return self._Vms_sat_T_ref\r\n        except AttributeError:\r\n            pass\r\n        T_REF_IG = self.T_REF_IG\r\n        if self.Vms_sat_poly_fit:\r\n            self._Vms_sat_T_ref = evaluate_linear_fits(self._Vms_sat_data, T_REF_IG)\r\n        else:\r\n            (VolumeLiquids, cmps) = (self.VolumeLiquids, range(self.N))\r\n            self._Vms_sat_T_ref = [VolumeLiquids[i].T_dependent_property(T_REF_IG) for i in cmps]\r\n        return self._Vms_sat_T_ref\r\n\r\n    def dVms_sat_dT_T_ref(self):\r\n        try:\r\n            return self._dVms_sat_dT_T_ref\r\n        except AttributeError:\r\n            pass\r\n        T_REF_IG = self.T_REF_IG\r\n        if self.Vms_sat_poly_fit:\r\n            self._dVms_sat_dT_T_ref = evaluate_linear_fits_d(self._Vms_sat_data, self.T)\r\n        else:\r\n            (VolumeLiquids, cmps) = (self.VolumeLiquids, range(self.N))\r\n            self._dVms_sat_dT_T_ref = [VolumeLiquids[i].T_dependent_property_derivative(T_REF_IG) for i in cmps]\r\n        return self._dVms_sat_dT_T_ref\r\n\r\n    def Vms(self):\r\n        return self.Vms_sat()\r\n\r\n    def dVms_dT(self):\r\n        return self.dVms_sat_dT()\r\n\r\n    def d2Vms_dT2(self):\r\n        return self.d2Vms_sat_dT2()\r\n\r\n    def dVms_dP(self):\r\n        return [0.0] * self.N\r\n\r\n    def d2Vms_dP2(self):\r\n        return [0.0] * self.N\r\n\r\n    def d2Vms_dPdT(self):\r\n        return [0.0] * self.N\r\n\r\n    def Hvaps(self):\r\n        try:\r\n"]
[23.854273, "o", "            return self._Hvaps\r\n        except AttributeError:\r\n            pass\r\n        (T, EnthalpyVaporizations, cmps) = (self.T, self.EnthalpyVaporizations, range(self.N))\r\n        self._Hvaps = Hvaps = []\r\n        if self.Hvap_poly_fit:\r\n            Hvap_data = self._Hvap_data\r\n            (Tcs, Tcs_inv, coeffs) = (Hvap_data[2], Hvap_data[3], Hvap_data[4])\r\n            for i in cmps:\r\n                Hvap = 0.0\r\n                if T < Tcs[i]:\r\n                    x = log(1.0 - T * Tcs_inv[i])\r\n                    for c in coeffs[i]:\r\n                        Hvap = Hvap * x + c\r\n                Hvaps.append(Hvap)\r\n            return Hvaps\r\n        self._Hvaps = Hvaps = [EnthalpyVaporizations[i](T) for i in cmps]\r\n        for i in cmps:\r\n            if Hvaps[i] is None:\r\n                Hvaps[i] = 0.0\r\n        return Hvaps\r\n\r\n    def dHvaps_dT(self):\r\n        try:\r\n            return self._dHvaps_dT\r\n        except AttributeError:\r\n            pass\r\n        (T, EnthalpyVaporizations, cmps) = (self.T, self.EnthalpyVaporizations, range(self.N))\r\n        self._dHvaps_dT = dHvaps_dT = []\r\n        if self.Hvap_poly_fit:\r\n            Hvap_data = self._Hvap_data\r\n            (Tcs, Tcs_inv, coeffs) = (Hvap_data[2], Hvap_data[3], Hvap_data[4])\r\n            for i in cmps:\r\n                dHvap_dT = 0.0\r\n                if T < Tcs[i]:\r\n                    p = log((Tcs[i] - T) * Tcs_inv[i])\r\n                    x = 1.0\r\n                    a = 1.0\r\n                    for c in coeffs[i][-2::-1]:\r\n                        dHvap_dT += a * c * x\r\n                        x *= p\r\n                        a += 1.0\r\n                    dHvap_dT /= T - Tcs[i]\r\n                dHvaps_dT.append(dHvap_dT)\r\n            return dHvaps_dT\r\n        self._dHvaps_dT = dHvaps_dT = [EnthalpyVaporizations[i].T_dependent_property_derivative(T) for i in cmps]\r\n        for i in cmps:\r\n            if dHvaps_dT[i] is None:\r\n                dHvaps_dT[i] = 0.0\r\n        return dHvaps_dT\r\n\r\n    def Hvaps_T_ref(self):\r\n        try:\r\n            return self._Hvaps_T_ref\r\n        except AttributeError:\r\n            pass\r\n        (EnthalpyVaporizations, cmps) = (self.EnthalpyVaporizations, range(self.N))\r\n        T_REF_IG = self.T_REF_IG\r\n        self._Hvaps_T_ref = [EnthalpyVaporizations[i](T_REF_IG) for i in cmps]\r\n        return self._Hvaps_T_ref\r\n\r\n    def Poyntings_at(self, T, P, Psats=None, Vms=None):\r\n        if not self.use_Poynting:\r\n            return [1.0] * self.N\r\n        cmps = range(self.N)\r\n        if Psats is None:\r\n            Psats = self.Psats_at(T)\r\n        if Vms is None:\r\n            Vms = self.Vms_sat_at(T)\r\n        RT_inv = 1.0 / (R * T)\r\n        return [exp(Vms[i] * (P - Psats[i]) * RT_inv) for i in cmps]\r\n\r\n    def Poyntings(self):\r\n        \"\"\"Method to calculate and return the Poynting pressure correction\r\n        factors of the phase, [-].\r\n\r\n        .. math::\r\n            \\\\text{Poynting}_i = \\\\exp\\\\left(\\\\frac{V_{m,i}(P-P_{sat})}{RT}\\\\right)\r\n\r\n        Returns\r\n        -------\r\n        Poyntings : list[float]\r\n            Poynting pressure correction factors, [-]\r\n\r\n        Notes\r\n        -----\r\n        The above formula is correct for pressure-independent molar volumes.\r\n        When the volume does depend on pressure, the full expression is:\r\n\r\n        .. math::\r\n            \\\\text{Poynting} = \\\\exp\\\\left[\\\\frac{\\\\int_{P_i^{sat}}^P V_i^l dP}{RT}\\\\right]\r\n\r\n        When a specified model e.g. the Tait equation is used, an analytical\r\n        integral of this term is normally available.\r\n\r\n        \"\"\"\r\n        try:\r\n            return self._Poyntings\r\n        except AttributeError:\r\n            pass\r\n        if not self.use_Poynting:\r\n            self._Poyntings = [1.0] * self.N\r\n            return self._Poyntings\r\n        (T, P) = (self.T, self.P)\r\n        try:\r\n            Psats = self._Psats\r\n        except AttributeError:\r\n            Psats = self.Psats()\r\n        try:\r\n            Vms_sat = self._Vms_sat\r\n        except AttributeError:\r\n            Vms_sat = self.Vms_sat()\r\n        RT_inv = 1.0 / (R * T)\r\n        self._Poyntin"]
[23.854497, "o", "gs = [trunc_exp(Vml * (P - Psat) * RT_inv) for (Psat, Vml) in zip(Psats, Vms_sat)]\r\n        return self._Poyntings\r\n\r\n    def dPoyntings_dT(self):\r\n        try:\r\n            return self._dPoyntings_dT\r\n        except AttributeError:\r\n            pass\r\n        if not self.use_Poynting:\r\n            self._dPoyntings_dT = [0.0] * self.N\r\n            return self._dPoyntings_dT\r\n        (T, P) = (self.T, self.P)\r\n        Psats = self.Psats()\r\n        dPsats_dT = self.dPsats_dT()\r\n        Vms = self.Vms_sat()\r\n        dVms_sat_dT = self.dVms_sat_dT()\r\n        x0 = 1.0 / R\r\n        x1 = 1.0 / T\r\n        RT_inv = x0 * x1\r\n        self._dPoyntings_dT = dPoyntings_dT = []\r\n        for i in range(self.N):\r\n            x2 = Vms[i]\r\n            x3 = Psats[i]\r\n            x4 = P - x3\r\n            x5 = x1 * x2 * x4\r\n            dPoyntings_dTi = -RT_inv * (x2 * dPsats_dT[i] - x4 * dVms_sat_dT[i] + x5) * trunc_exp(x0 * x5)\r\n            dPoyntings_dT.append(dPoyntings_dTi)\r\n        return dPoyntings_dT\r\n\r\n    def dPoyntings_dT_at(self, T, P, Psats=None, Vms=None, dPsats_dT=None, dVms_sat_dT=None):\r\n        if not self.use_Poynting:\r\n            return [0.0] * self.N\r\n        if Psats is None:\r\n            Psats = self.Psats_at(T)\r\n        if dPsats_dT is None:\r\n            dPsats_dT = self.dPsats_dT_at(T, Psats)\r\n        if Vms is None:\r\n            Vms = self.Vms_sat_at(T)\r\n        if dVms_sat_dT is None:\r\n            dVms_sat_dT = self.dVms_sat_dT_at(T)\r\n        x0 = 1.0 / R\r\n        x1 = 1.0 / T\r\n        dPoyntings_dT = []\r\n        for i in range(self.N):\r\n            x2 = Vms[i]\r\n            x4 = P - Psats[i]\r\n            x5 = x1 * x2 * x4\r\n            dPoyntings_dTi = -x0 * x1 * (x2 * dPsats_dT[i] - x4 * dVms_sat_dT[i] + x5) * exp(x0 * x5)\r\n            dPoyntings_dT.append(dPoyntings_dTi)\r\n        return dPoyntings_dT\r\n\r\n    def d2Poyntings_dT2(self):\r\n        try:\r\n            return self._d2Poyntings_dT2\r\n        except AttributeError:\r\n            pass\r\n        if not self.use_Poynting:\r\n            self._d2Poyntings_dT2 = [0.0] * self.N\r\n            return self._d2Poyntings_dT2\r\n        (T, P) = (self.T, self.P)\r\n        Psats = self.Psats()\r\n        dPsats_dT = self.dPsats_dT()\r\n        d2Psats_dT2 = self.d2Psats_dT2()\r\n        Vms = self.Vms_sat()\r\n        dVms_sat_dT = self.dVms_sat_dT()\r\n        d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\r\n        x6 = 1.0 / T\r\n        x7 = x6 + x6\r\n        x11 = 1.0 / R\r\n        x12 = x11 * x6\r\n        c0 = 2.0 * x6 * x6\r\n        self._d2Poyntings_dT2 = d2Poyntings_dT2 = []\r\n        \"\\n        from sympy import *\\n        R, T, P = symbols('R, T, P')\\n        Vml, Psat = symbols('Vml, Psat', cls=Function)\\n        RT_inv = 1/(R*T)\\n        Poy = exp(Vml(T)*(P-Psat(T))*RT_inv)\\n        cse(diff(Poy, T, 2), optimizations='basic')\\n        \"\r\n        for i in range(self.N):\r\n            x0 = Vms[i]\r\n            x1 = Psats[i]\r\n            x2 = P - x1\r\n            x3 = x0 * x2\r\n            x4 = dPsats_dT[i]\r\n            x5 = x0 * x4\r\n            x8 = dVms_sat_dT[i]\r\n            x9 = x2 * x8\r\n            x10 = x3 * x6\r\n            x50 = x10 + x5 - x9\r\n            d2Poyntings_dT2i = x12 * (-x0 * d2Psats_dT2[i] + x12 * x50 * x50 + x2 * d2Vms_sat_dT2[i] - 2.0 * x4 * x8 + x5 * x7 - x7 * x9 + x3 * c0) * exp(x10 * x11)\r\n            d2Poyntings_dT2.append(d2Poyntings_dT2i)\r\n        return d2Poyntings_dT2\r\n\r\n    def dPoyntings_dP(self):\r\n        \"\"\"from sympy import *\r\n        R, T, P, zi = symbols('R, T, P, zi')\r\n        Vml = symbols('Vml', cls=Function)\r\n        cse(diff(exp(Vml(T)*(P - Psati(T))/(R*T)), P), optimizations='basic')\r\n        \"\"\"\r\n        try:\r\n            return self._dPoyntings_dP\r\n        except AttributeError:\r\n            pass\r\n        if not self.use_Poynting:\r\n            self._dPoyntings_dP = [0.0] * self.N\r\n            return self._dPoyntings_dP\r\n        (T, P) = (self.T, self.P)\r\n        Psats = self.Psats()\r\n        Vms = self.Vms_sat()\r\n        self._dPoyntings_dP = dPoyntings_dPs = []\r\n        for i in range(self.N):\r\n            x0 = Vms[i] / (R * T)\r\n            dPoyntings_dPs.ap"]
[23.855758, "o", "pend(x0 * exp(x0 * (P - Psats[i])))\r\n        return dPoyntings_dPs\r\n\r\n    def d2Poyntings_dPdT(self):\r\n        \"\"\"\r\n        from sympy import *\r\n        R, T, P = symbols('R, T, P')\r\n        Vml, Psat = symbols('Vml, Psat', cls=Function)\r\n        RT_inv = 1/(R*T)\r\n        Poy = exp(Vml(T)*(P-Psat(T))*RT_inv)\r\n        Poyf = symbols('Poyf')\r\n        cse(diff(Poy, T, P).subs(Poy, Poyf), optimizations='basic')\r\n        \"\"\"\r\n        try:\r\n            return self._d2Poyntings_dPdT\r\n        except AttributeError:\r\n            pass\r\n        if not self.use_Poynting:\r\n            self._d2Poyntings_dPdT = [0.0] * self.N\r\n            return self._d2Poyntings_dPdT\r\n        try:\r\n            Psats = self._Psats\r\n        except AttributeError:\r\n            Psats = self.Psats()\r\n        try:\r\n            dPsats_dT = self._dPsats_dT\r\n        except AttributeError:\r\n            dPsats_dT = self.dPsats_dT()\r\n        try:\r\n            Vms = self._Vms_sat\r\n        except AttributeError:\r\n            Vms = self.Vms_sat()\r\n        try:\r\n            dVms_sat_dT = self._dVms_sat_dT\r\n        except AttributeError:\r\n            dVms_sat_dT = self.dVms_sat_dT()\r\n        try:\r\n            Poyntings = self._Poyntings\r\n        except AttributeError:\r\n            Poyntings = self.Poyntings()\r\n        x0 = R_inv\r\n        x1 = 1.0 / self.T\r\n        P = self.P\r\n        nRT_inv = -x0 * x1\r\n        self._d2Poyntings_dPdT = d2Poyntings_dPdT = []\r\n        for i in range(self.N):\r\n            x2 = Vms[i]\r\n            x3 = x1 * x2\r\n            x4 = dVms_sat_dT[i]\r\n            x5 = Psats[i]\r\n            x6 = P - x5\r\n            v = Poyntings[i] * nRT_inv * (x0 * x3 * (x2 * dPsats_dT[i] + x3 * x6 - x4 * x6) + x3 - x4)\r\n            d2Poyntings_dPdT.append(v)\r\n        return d2Poyntings_dPdT\r\n    d2Poyntings_dTdP = d2Poyntings_dPdT\r\n\r\n    def phis_sat_at(self, T):\r\n        if not self.use_phis_sat:\r\n            return [1.0] * self.N\r\n        phis_sat = []\r\n        for i in self.eos_pure_instances:\r\n            try:\r\n                phis_sat.append(i.phi_sat(min(T, i.Tc), polish=True))\r\n            except Exception as e:\r\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\r\n                    phis_sat.append(1.0)\r\n                else:\r\n                    raise\r\n        return phis_sat\r\n\r\n    def phis_sat(self):\r\n        \"\"\"Method to calculate and return the saturation fugacity coefficient\r\n        correction factors of the phase, [-].\r\n\r\n        These are calculated from the\r\n        provided pure-component equations of state. This term should only be\r\n        used with a consistent vapor-phase cubic equation of state.\r\n\r\n        Returns\r\n        -------\r\n        phis_sat : list[float]\r\n            Saturation fugacity coefficient correction factors, [-]\r\n\r\n        Notes\r\n        -----\r\n        .. warning::\r\n            This factor cannot be calculated when a compound is supercritical,\r\n            as there is no longer any vapor-liquid pure-component equilibrium\r\n            (by definition).\r\n\r\n        \"\"\"\r\n        try:\r\n            return self._phis_sat\r\n        except AttributeError:\r\n            pass\r\n        if not self.use_phis_sat:\r\n            self._phis_sat = [1.0] * self.N\r\n            return self._phis_sat\r\n        T = self.T\r\n        self._phis_sat = phis_sat = []\r\n        for i in self.eos_pure_instances:\r\n            try:\r\n                phis_sat.append(i.phi_sat(min(T, i.Tc), polish=True))\r\n            except Exception as e:\r\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\r\n                    phis_sat.append(1.0)\r\n                else:\r\n                    raise\r\n        return phis_sat\r\n\r\n    def dphis_sat_dT_at(self, T):\r\n        if not self.use_phis_sat:\r\n            return [0.0] * self.N\r\n        dphis_sat_dT = []\r\n        for i in self.eos_pure_instances:\r\n            try:\r\n                dphis_sat_dT.append(i.dphi_sat_dT(min(T, i.Tc)))\r\n            except Exception as e:\r\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\r\n                    dphis_sat_dT.append(0.0)\r\n                else:\r\n                    raise\r\n        return dphis_sat_dT\r\n\r\n    def dphis_sat_dT(self):\r\n        try:\r\n            return self._dphis_sat_dT\r\n        except AttributeError:\r\n            pass\r\n        if not self.use_phis_sat:\r\n            self._dphis_sat_dT = [0.0] * self.N\r\n            return self._dphis_sat_dT\r\n        T = self.T\r\n        self._dphis_sat_dT = dphis_sat_dT = []\r\n        for i in self.eos_pure_instances:\r\n            try:\r\n                dphis_sat_dT.append(i.dphi_sat_dT(min(T, i.Tc)))\r\n            except Exception as e:\r\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\r\n                    dphis_sat_dT.append(0.0)\r\n                else:\r\n                    raise\r\n        return dphis_sat_dT\r\n\r\n    def d2phis_sat_dT2(self):\r\n        try:\r\n            return self._d2phis_sat_dT2\r\n        except AttributeError:\r\n            pass\r\n        if not self.use_phis_sat:\r\n            self._d2phis_sat_dT2 = [0.0] * self.N\r\n            return self._d2phis_sat_dT2\r\n        T = self.T\r\n        self._d2phis_sat_dT2 = d2phis_sat_dT2 = []\r\n        for i in self.eos_pure_instances:\r\n            try:\r\n                d2phis_sat_dT2.append(i.d2phi_sat_dT2(min(T, i.Tc)))\r\n            except Exception as e:\r\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\r\n                    d2phis_sat_dT2.append(0.0)\r\n                else:\r\n                    raise\r\n        return d2phis_sat_dT2\r\n\r\n    def phis_at(self, T, P, zs, Psats=None, gammas=None, phis_sat=None, Poyntings=None):\r\n        P_inv = 1.0 / P\r\n        if Psats is None:\r\n            Psats = self.Psats_at(T)\r\n        if gammas is None:\r\n            gammas = self.gammas_at(T, zs)\r\n        if phis_sat is None:\r\n            phis_sat = self.phis_sat_at(T)\r\n        if Poyntings is None:\r\n            Poyntings = self.Poyntings_at(T, P, Psats=Psats)\r\n        return [gammas[i] * Psats[i] * Poyntings[i] * phis_sat[i] * P_inv for i in range(self.N)]\r\n\r\n    def phis(self):\r\n        \"\"\"Method to calculate the fugacity coefficients of the\r\n        GibbsExcessLiquid phase. Depending on the settings of the phase, can\r\n        include the effects of activity coefficients `gammas`, pressure\r\n        correction terms `Poyntings`, and pure component saturation fugacities\r\n        `phis_sat` as well as the pure component vapor pressures.\r\n\r\n        .. math::\r\n            \\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat} \\\\phi_i^{sat} \\\\text{Poynting}_i}\r\n            {P}\r\n\r\n        Returns\r\n        -------\r\n        phis : list[float]\r\n            Fugacity coefficients of all components in the phase, [-]\r\n\r\n        Notes\r\n        -----\r\n        Poyntings, gammas, and pure component saturation phis default to 1.\r\n        \"\"\"\r\n        try:\r\n            return self._phis\r\n        except AttributeError:\r\n            pass\r\n        P = self.P\r\n        try:\r\n            gammas = self._gammas\r\n        except AttributeError:\r\n            gammas = self.gammas()\r\n        try:\r\n            Psats = self._Psats\r\n        except AttributeError:\r\n            Psats = self.Psats()\r\n        try:\r\n            phis_sat = self._phis_sat\r\n        except AttributeError:\r\n            phis_sat = self.phis_sat()\r\n        try:\r\n            Poyntings = self._Poyntings\r\n        except AttributeError:\r\n            Poyntings = self.Poyntings()\r\n        P_inv = 1.0 / P\r\n        self._phis = [gammas[i] * Psats[i] * Poyntings[i] * phis_sat[i] * P_inv for i in range(self.N)]\r\n        return self._phis\r\n\r\n    def lnphis(self):\r\n        try:\r\n            return self._lnphis\r\n        except AttributeError:\r\n            pass\r\n        try:\r\n            self._lnphis = [log(i) for i in self.phis()]\r\n        except:\r\n            P = self.P\r\n            try:\r\n                gammas = self._gammas\r\n            except AttributeError:\r\n                gammas = self.gammas()\r\n            try:\r\n                lnPsats = self._lnPsats\r\n            except AttributeError:\r\n                lnPsats = self.lnPsats()\r\n            try:\r\n                phis_sat = self._phis_sat\r\n            except AttributeError:\r\n                phis_sat = self.phis_sat()\r\n            try:\r\n                Poyntings = self._Poyntings\r\n            except AttributeError:\r\n                Poyntings = self.Poyntings()\r\n            P_inv = 1.0 / P\r\n            self._lnphis = [log(gammas[i] * Poyntings[i] * phis_sat[i] * P_inv) + lnPsats[i] for i in range(self.N)]\r\n        return self._lnphis\r\n    lnphis_G_min = lnphis\r\n    lnphis_lowest_Gibbs = lnphis\r\n\r\n    def dphis_dT(self):\r\n        try:\r\n            return self._dphis_dT\r\n        except AttributeError:\r\n            pass\r\n        P = self.P\r\n        Psats = self.Psats()\r\n        gammas = self.gammas()\r\n        if self.use_Poynting:\r\n            dPoyntings_dT = self.dPoyntings_dT()\r\n            Poyntings = self.Poyntings()\r\n        else:\r\n            dPoyntings_dT = [0.0] * self.N\r\n            Poyntings = [1.0] * self.N\r\n        dPsats_dT = self.dPsats_dT()\r\n        dgammas_dT = self.GibbsExcessModel.dgammas_dT()\r\n        if self.use_phis_sat:\r\n            dphis_sat_dT = self.dphis_sat_dT()\r\n            phis_sat = self.phis_sat()\r\n        else:\r\n            dphis_sat_dT = [0.0] * self.N\r\n            phis_sat = [1.0] * self.N\r\n        self._dphis_dT = dphis_dTl = []\r\n        for i in range(self.N):\r\n            x0 = gammas[i]\r\n            x1 = phis_sat[i]\r\n            x2 = Psats[i]\r\n            x3 = Poyntings[i]\r\n            x4 = x2 * x3\r\n            x5 = x0 * x1\r\n            v = (x0 * x4 * dphis_sat_dT[i] + x1 * x4 * dgammas_dT[i] + x2 * x5 * dPoyntings_dT[i] + x3 * x5 * dPsats_dT[i]) / P\r\n            dphis_dTl.append(v)\r\n        return dphis_dTl\r\n\r\n    def dphis_dT_at(self, T, P, zs, phis_also=False):\r\n        Psats = self.Psats_at(T)\r\n        dPsats_dT = self.dPsats_dT_at(T, Psats)\r\n        Vms = self.Vms_sat_at(T)\r\n        dVms_sat_dT = self.dVms_sat_dT_at(T)\r\n        gammas = self.gammas_at(T, zs)\r\n        dgammas_dT = self.dgammas_dT_at(T, zs)\r\n        if self.use_Poynting:\r\n            Poyntings = self.Poyntings_at(T, P, Psats, Vms)\r\n            dPoyntings_dT = self.dPoyntings_dT_at(T, P, Psats=Psats, Vms=Vms, dPsats_dT=dPsats_dT, dVms_sat_dT=dVms_sat_dT)\r\n        else:\r\n            Poyntings = [1.0] * self.N\r\n            dPoyntings_dT = [0.0] * self.N\r\n        if self.use_phis_sat:\r\n            dphis_sat_dT = self.dphis_sat_dT_at(T)\r\n            phis_sat = self.phis_sat_at(T)\r\n        else:\r\n            dphis_sat_dT = [0.0] * self.N\r\n            phis_sat = [1.0] * self.N\r\n        dphis_dT = []\r\n        for i in range(self.N):\r\n            x0 = gammas[i]\r\n            x1 = phis_sat[i]\r\n            x2 = Psats[i]\r\n            x3 = Poyntings[i]\r\n            x4 = x2 * x3\r\n            x5 = x0 * x1\r\n            v = (x0 * x4 * dphis_sat_dT[i] + x1 * x4 * dgammas_dT[i] + x2 * x5 * dPoyntings_dT[i] + x3 * x5 * dPsats_dT[i]) / P\r\n            dphis_dT.append(v)\r\n        if phis_also:\r\n            P_inv = 1.0 / P\r\n            phis = [gammas[i] * Psats[i] * Poyntings[i] * phis_sat[i] * P_inv for i in range(self.N)]\r\n            return (dphis_dT, phis)\r\n        return dphis_dT\r\n\r\n    def dlnphis_dT(self):\r\n        try:\r\n            return self._dlnphis_dT\r\n        except AttributeError:\r\n            pass\r\n        dphis_dT = self.dphis_dT()\r\n        phis = self.phis()\r\n        self._dlnphis_dT = [i / j for (i, j) in zip(dphis_dT, phis)]\r\n        return self._dlnphis_dT\r\n\r\n    def dlnphis_dP(self):\r\n        \"\"\"Method to calculate the pressure derivative of log fugacity\r\n        coefficients of the phase. Depending on the settings of the phase, can\r\n        include the effects of activity coefficients `gammas`, pressure\r\n        correction terms `Poyntings`, and pure component saturation fugacities\r\n        `phis_sat` as well as the pure component vapor pressures.\r\n\r\n        .. math::\r\n            \\\\frac{\\\\partial \\\\ln \\\\phi_i}{\\\\partial P} =\r\n            \\\\frac{\\\\frac{\\\\partial \\\\text{Poynting}_i}{\\\\partial P}}\r\n            {\\\\text{Poynting}_i} - \\\\frac{1}{P}\r\n\r\n        Returns\r\n        -------\r\n        dlnphis_dP : list[float]\r\n            Pressure derivative of log fugacity coefficients of all components\r\n            in the phase, [1/Pa]\r\n\r\n        Notes\r\n        -----\r\n        Poyntings, gammas, and pure component saturation phis default to 1. For\r\n        that case, :math:`\\\\frac{\\\\partial \\\\ln \\\\phi_i}{\\\\partial P}=\\\\frac{1}{P}`.\r\n        \"\"\"\r\n        try:\r\n            return self._dlnphis_dP\r\n        except AttributeError:\r\n            pass\r\n        try:\r\n            Poyntings = self._Poyntings\r\n        except AttributeError:\r\n            Poyntings = self.Poyntings()\r\n        try:\r\n            dPoyntings_dP = self._dPoyntings_dP\r\n        except AttributeError:\r\n            dPoyntings_dP = self.dPoyntings_dP()\r\n        P_inv = 1.0 / self.P\r\n        self._dlnphis_dP = [dPoyntings_dP[i] / Poyntings[i] - P_inv for i in range(self.N)]\r\n        return self._dlnphis_dP\r\n\r\n    def gammas_at(self, T, zs):\r\n        if self.composition_independent:\r\n            return [1.0] * self.N\r\n        return self.GibbsExcessModel.to_T_xs(T, zs).gammas()\r\n\r\n    def dgammas_dT_at(self, T, zs):\r\n        if self.composition_independent:\r\n            return [0.0] * self.N\r\n        return self.GibbsExcessModel.to_T_xs(T, zs).dgammas_dT()\r\n\r\n    def gammas(self):\r\n        \"\"\"Method to calculate and return the activity coefficients of the\r\n        phase, [-]. This is a direct call to\r\n        :obj:`GibbsExcess.gammas <thermo.activity.GibbsExcess.gammas>`.\r\n\r\n        Returns\r\n        -------\r\n        gammas : list[float]\r\n            Activity coefficients, [-]\r\n        \"\"\"\r\n        try:\r\n            return self.GibbsExcessModel._gammas\r\n        except AttributeError:\r\n            return self.GibbsExcessModel.gammas()\r\n\r\n    def dgammas_dT(self):\r\n        \"\"\"Method to calculate and return the temperature derivative of\r\n        activity coefficients of the phase, [-].\r\n\r\n        This is a direct call to\r\n        :obj:`GibbsExcess.dgammas_dT <thermo.activity.GibbsExcess.dgammas_dT>`.\r\n\r\n        Returns\r\n        -------\r\n        dgammas_dT : list[float]\r\n            First temperature derivative of the activity coefficients, [1/K]\r\n        \"\"\"\r\n        return self.GibbsExcessModel.dgammas_dT()\r\n\r\n    def H_old(self):\r\n        T = self.T\r\n        RT = R * T\r\n        P = self.P\r\n        (zs, cmps) = (self.zs, range(self.N))\r\n        T_REF_IG = self.T_REF_IG\r\n        P_DEPENDENT_H_LIQ = self.P_DEPENDENT_H_LIQ\r\n        try:\r\n            Cpig_integrals_pure = self._Cpig_integrals_pure\r\n        except AttributeError:\r\n            Cpig_integrals_pure = self.Cpig_integrals_pure()\r\n        H = 0.0\r\n        if P_DEPENDENT_H_LIQ:\r\n            \"\\n            from scipy.integrate import *\\n            from CoolProp.CoolProp import PropsSI\\n\\n            fluid = 'decane'\\n            T = 400\\n            Psat = PropsSI('P', 'T', T, 'Q', 0, fluid)\\n            P2 = Psat*100\\n            dP = P2 - Psat\\n            Vm = 1/PropsSI('DMOLAR', 'T', T, 'Q', 0, fluid)\\n            Vm2 = 1/PropsSI('DMOLAR', 'T', T, 'P', P2, fluid)\\n            dH = PropsSI('HMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('HMOLAR', 'T', T, 'Q', 0, fluid)\\n\\n            def to_int(P):\\n                Vm = 1/PropsSI('DMOLAR', 'T', T, 'P', P, fluid)\\n                alpha = PropsSI('ISOBARIC_EXPANSION_COEFFICIENT', 'T', T, 'P', P, fluid)\\n                return Vm -alpha*T*Vm\\n            quad(to_int, Psat, P2, epsabs=1.49e-14, epsrel=1.49e-14)[0]/dH\\n            \"\r\n            if self.use_IG_Cp:\r\n                try:\r\n                    Psats = self._Psats\r\n                except AttributeError:\r\n                    Psats = self.Psats()\r\n                try:\r\n                    dPsats_dT = self._dPsats_dT\r\n                except AttributeError:\r\n                    dPsats_dT = self.dPsats_dT()\r\n                try:\r\n                    Vms_sat = self._Vms_sat\r\n                except AttributeError:\r\n                    Vms_sat = self.Vms_sat()\r\n                try:\r\n                    dVms_sat_dT = self._Vms_sat_dT\r\n                except AttributeError:\r\n                    dVms_sat_dT = self.dVms_sat_dT()\r\n                failed_dPsat_dT = False\r\n                try:\r\n                    H = 0.0\r\n                    for i in cmps:\r\n                        dV_vap = R * T / Psats[i] - Vms_sat[i]\r\n                        dS_vap = dPsats_dT[i] * dV_vap\r\n                        Hvap = T * dS_vap\r\n                        H += zs[i] * (Cpig_integrals_pure[i] - Hvap)\r\n                except ZeroDivisionError:\r\n                    failed_dPsat_dT = True\r\n                if failed_dPsat_dT or isinf(H):\r\n                    dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\r\n                    H = 0.0\r\n                    for i in cmps:\r\n                        Hvap = T * dPsats_dT_over_Psats[i] * RT\r\n                        H += zs[i] * (Cpig_integrals_pure[i] - Hvap)\r\n                if self.use_Tait:\r\n                    dH_dP_integrals_Tait = self.dH_dP_integrals_Tait()\r\n                    for i in cmps:\r\n                        H += zs[i] * dH_dP_integrals_Tait[i]\r\n                elif self.use_Poynting:\r\n                    for i in cmps:\r\n                        dP = P - Psats[i]\r\n                        H += zs[i] * dP * (Vms_sat[i] - T * dVms_sat_dT[i])\r\n            else:\r\n                Psats = self.Psats()\r\n                Vms_sat = self.Vms_sat()\r\n                dVms_sat_dT = self.dVms_sat_dT()\r\n                dPsats_dT = self.dPsats_dT()\r\n                Hvaps_T_ref = self.Hvaps_T_ref()\r\n                Cpl_integrals_pure = self._Cpl_integrals_pure()\r\n                dVms_sat_dT_T_ref = self.dVms_sat_dT_T_ref()\r\n                Vms_sat_T_ref = self.Vms_sat_T_ref()\r\n                Psats_T_ref = self.Psats_T_ref()\r\n                Hvaps = self.Hvaps()\r\n                H = 0.0\r\n                for i in range(self.N):\r\n                    H += zs[i] * (Cpl_integrals_pure[i] - Hvaps_T_ref[i])\r\n                    dP = P - Psats_T_ref[i]\r\n                    H += zs[i] * dP * (Vms_sat_T_ref[i] - T_REF_IG * dVms_sat_dT_T_ref[i])\r\n        else:\r\n            Hvaps = self.Hvaps()\r\n            for i in range(self.N):\r\n                H += zs[i] * (Cpig_integrals_pure[i] - Hvaps[i])\r\n        H += self.GibbsExcessModel.HE()\r\n        return H\r\n    del H_old\r\n\r\n    def H(self):\r\n        \"\"\"\r\n        TODO: Implement this function\r\n        \"\"\"\r\n        ...\r\n\r\n    def S_old(self):\r\n        \"\"\"\r\n        from scipy.integrate import *\r\n        from CoolProp.CoolProp import PropsSI\r\n\r\n        fluid = 'decane'\r\n        T = 400\r\n        Psat = PropsSI('P', 'T', T, 'Q', 0, fluid)\r\n        P2 = Psat*100\r\n        dP = P2 - Psat\r\n        Vm = 1/PropsSI('DMOLAR', 'T', T, 'Q', 0, fluid)\r\n        Vm2 = 1/PropsSI('DMOLAR', 'T', T, 'P', P2, fluid)\r\n        dH = PropsSI('HMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('HMOLAR', 'T', T, 'Q', 0, fluid)\r\n        dS = PropsSI('SMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('SMOLAR', 'T', T, 'Q', 0, fluid)\r\n        def to_int2(P):\r\n            Vm = 1/PropsSI('DMOLAR', 'T', T, 'P', P, fluid)\r\n            alpha = PropsSI('ISOBARIC_EXPANSION_COEFFICIENT', 'T', T, 'P', P, fluid)\r\n            return -alpha*Vm\r\n        quad(to_int2, Psat, P2, epsabs=1.49e-14, epsrel=1.49e-14)[0]/dS\r\n        \"\"\"\r\n        S = 0.0\r\n        (T, P, zs, cmps) = (self.T, self.P, self.zs, range(self.N))\r\n        log_zs = self.log_zs()\r\n        for i in cmps:\r\n            S -= zs[i] * log_zs[i]\r\n        S *= R\r\n        S_base = S\r\n        T_inv = 1.0 / T\r\n        RT = R * T\r\n        P_REF_IG_INV = self.P_REF_IG_INV\r\n        try:\r\n            Cpig_integrals_over_T_pure = self._Cpig_integrals_over_T_pure\r\n        except AttributeError:\r\n            Cpig_integrals_over_T_pure = self.Cpig_integrals_over_T_pure()\r\n        try:\r\n            Psats = self._Psats\r\n        except AttributeError:\r\n            Psats = self.Psats()\r\n        try:\r\n            dPsats_dT = self._dPsats_dT\r\n        except AttributeError:\r\n            dPsats_dT = self.dPsats_dT()\r\n        try:\r\n            Vms_sat = self._Vms_sat\r\n        except AttributeError:\r\n            Vms_sat = self.Vms_sat()\r\n        try:\r\n            dVms_sat_dT = self._Vms_sat_dT\r\n        except AttributeError:\r\n            dVms_sat_dT = self.dVms_sat_dT()\r\n        if self.P_DEPENDENT_H_LIQ:\r\n            if self.use_IG_Cp:\r\n                failed_dPsat_dT = False\r\n                try:\r\n                    for i in range(self.N):\r\n                        dSi = Cpig_integrals_over_T_pure[i]\r\n                        dVsat = R * T / Psats[i] - Vms_sat[i]\r\n                        dSvap = dPsats_dT[i] * dVsat\r\n                        dSi -= dSvap\r\n                        dSi -= R * log(Psats[i] * P_REF_IG_INV)\r\n                        dP = P - Psats[i]\r\n                        dSi -= dP * dVms_sat_dT[i]\r\n                        S += dSi * zs[i]\r\n                except (ZeroDivisionError, ValueError):\r\n                    failed_dPsat_dT = True\r\n                if failed_dPsat_dT or isinf(S):\r\n                    S = S_base\r\n                    dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\r\n                    lnPsats = self.lnPsats()\r\n                    LOG_P_REF_IG = self.LOG_P_REF_IG\r\n                    for i in cmps:\r\n                        dSi = Cpig_integrals_over_T_pure[i]\r\n                        dSvap = RT * dPsats_dT_over_Psats[i]\r\n                        dSi -= dSvap\r\n                        dSi -= R * (lnPsats[i] - LOG_P_REF_IG)\r\n                        dSi -= P * dVms_sat_dT[i]\r\n                        S += dSi * zs[i]\r\n                if self.use_Tait:\r\n                    pass\r\n                elif self.use_Poynting:\r\n                    pass\r\n            else:\r\n                Hvaps_T_ref = self.Hvaps_T_ref()\r\n                Psats_T_ref = self.Psats_T_ref()\r\n                Cpl_integrals_over_T_pure = self._Cpl_integrals_over_T_pure()\r\n                T_REF_IG_INV = self.T_REF_IG_INV\r\n                dVms_sat_dT_T_ref = self.dVms_sat_dT_T_ref()\r\n                for i in range(self.N):\r\n                    dSi = Cpl_integrals_over_T_pure[i]\r\n                    dSi -= Hvaps_T_ref[i] * T_REF_IG_INV\r\n                    dSi -= R * log(Psats_T_ref[i] * P_REF_IG_INV)\r\n                    dP = P - Psats_T_ref[i]\r\n                    dSi -= dP * dVms_sat_dT_T_ref[i]\r\n                    S += dSi * zs[i]\r\n        else:\r\n            Hvaps = self.Hvaps()\r\n            for i in cmps:\r\n                Sg298_to_T = Cpig_integrals_over_T_pure[i]\r\n                Svap = -Hvaps[i] * T_inv\r\n                S += zs[i] * (Sg298_to_T + Svap - R * log(P * P_REF_IG_INV))\r\n        S = S + self.GibbsExcessModel.SE()\r\n        return S\r\n\r\n    def S(self):\r\n        \"\"\"Method to calculate the entropy of the\r\n"]
[23.855996, "o", "        :obj:`GibbsExcessLiquid` phase. Depending on the settings of the phase, this can\r\n        include the effects of activity coefficients\r\n        :obj:`gammas <GibbsExcessLiquid.gammas>`, pressure correction terms\r\n        :obj:`Poyntings <GibbsExcessLiquid.Poyntings>`, and pure component\r\n        saturation fugacities :obj:`phis_sat <GibbsExcessLiquid.phis_sat>`\r\n        as well as the pure component vapor pressures.\r\n\r\n        When `caloric_basis` is 'Poynting&PhiSat':\r\n\r\n        .. math::\r\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\r\n            - \\\\sum_i z_i\\\\left[R\\\\left(\r\n            T \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\r\n            + T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\r\n            + T\\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}}\r\n            + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{\\\\text{Poynting}\\\\cdot\\\\phi_{\\\\text{sat},i}}{P}\\\\right)\r\n            \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\r\n\r\n        When `caloric_basis` is 'PhiSat':\r\n\r\n        .. math::\r\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\r\n            - \\\\sum_i z_i\\\\left[R\\\\left(\r\n            T \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\r\n            + T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\r\n            + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{\\\\phi_{\\\\text{sat},i}}{P}\\\\right)\r\n            \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\r\n\r\n        When `caloric_basis` is 'Poynting':\r\n\r\n        .. math::\r\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\r\n            - \\\\sum_i z_i\\\\left[R\\\\left(\r\n            T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\r\n            + T\\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}}\r\n            + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{\\\\text{Poynting}}{P}\\\\right)\r\n            \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\r\n\r\n        When `caloric_basis` is 'Psat':\r\n\r\n        .. math::\r\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\r\n            - \\\\sum_i z_i\\\\left[R\\\\left(\r\n            T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\r\n            + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{1}{P}\\\\right)\r\n            \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\r\n\r\n        When `caloric_basis` is 'Hvap':\r\n\r\n        .. math::\r\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\r\n            - \\\\sum_i z_i\\\\left[R\\\\left(\\\\ln P_{\\\\text{sat},i} + \\\\ln\\\\left(\\\\frac{1}{P}\\\\right)\\\\right)\r\n            + \\\\frac{H_{vap,i}}{T}\r\n            - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\r\n\r\n        Returns\r\n        -------\r\n        S : float\r\n            Entropy of the phase, [J/(mol*K)]\r\n\r\n        Notes\r\n        -----\r\n        \"\"\"\r\n        try:\r\n            return self._S\r\n        except AttributeError:\r\n            pass\r\n        (T, P) = (self.T, self.P)\r\n        P_inv = 1.0 / P\r\n        (zs, cmps) = (self.zs, range(self.N))\r\n        log_zs = self.log_zs()\r\n        S_comp = 0.0\r\n        for i in cmps:\r\n            S_comp -= zs[i] * log_zs[i]\r\n        S = S_comp - log(P * self.P_REF_IG_INV)\r\n        S *= R\r\n        try:\r\n            Cpig_integrals_over_T_pure = self._Cpig_integrals_over_T_pure\r\n        except AttributeError:\r\n            Cpig_integrals_over_T_pure = self.Cpig_integrals_over_T_pure()\r\n        try:\r\n            lnPsats = self._lnPsats\r\n        except AttributeError:\r\n            lnPsats = self.lnPsats()\r\n        (use_Poynting, use_phis_sat, use_Hvap_caloric) = (self.use_Poynting, self.use_phis_sat, self.use_Hvap_caloric)\r\n        if use_Hvap_caloric:\r\n            Hvaps = self.Hvaps()\r\n            T_inv = 1.0 / T\r\n      "]
[23.856207, "o", "      logP_inv = log(P_inv)\r\n            for i in cmps:\r\n                S -= zs[i] * (R * (lnPsats[i] + logP_inv) - Cpig_integrals_over_T_pure[i] + Hvaps[i] * T_inv)\r\n        else:\r\n            dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\r\n            if use_Poynting:\r\n                try:\r\n                    Poyntings = self._Poyntings\r\n                except AttributeError:\r\n                    Poyntings = self.Poyntings()\r\n                try:\r\n                    dPoyntings_dT = self._dPoyntings_dT\r\n                except AttributeError:\r\n                    dPoyntings_dT = self.dPoyntings_dT()\r\n            if use_phis_sat:\r\n                try:\r\n                    dphis_sat_dT = self._dphis_sat_dT\r\n                except AttributeError:\r\n                    dphis_sat_dT = self.dphis_sat_dT()\r\n                try:\r\n                    phis_sat = self._phis_sat\r\n                except AttributeError:\r\n                    phis_sat = self.phis_sat()\r\n            if use_Poynting and use_phis_sat:\r\n                for i in cmps:\r\n                    S -= zs[i] * (R * (T * (dphis_sat_dT[i] / phis_sat[i] + dPsats_dT_over_Psats[i] + dPoyntings_dT[i] / Poyntings[i]) + lnPsats[i] + log(Poyntings[i] * phis_sat[i] * P_inv)) - Cpig_integrals_over_T_pure[i])\r\n            elif use_Poynting:\r\n                for i in cmps:\r\n                    S -= zs[i] * (R * (T * (dPsats_dT_over_Psats[i] + dPoyntings_dT[i] / Poyntings[i]) + lnPsats[i] + log(Poyntings[i] * P_inv)) - Cpig_integrals_over_T_pure[i])\r\n            elif use_phis_sat:\r\n                for i in cmps:\r\n                    S -= zs[i] * (R * (T * (dphis_sat_dT[i] / phis_sat[i] + dPsats_dT_over_Psats[i]) + lnPsats[i] + log(phis_sat[i] * P_inv)) - Cpig_integrals_over_T_pure[i])\r\n            else:\r\n                logP_inv = log(P_inv)\r\n                for i in cmps:\r\n                    S -= zs[i] * (R * (T * dPsats_dT_over_Psats[i] + lnPsats[i] + logP_inv) - Cpig_integrals_over_T_pure[i])\r\n        if not self.composition_independent:\r\n            S += self.GibbsExcessModel.SE()\r\n        self._S = S\r\n        return S\r\n\r\n    def Cp_old(self):\r\n        try:\r\n            return self._Cp\r\n        except AttributeError:\r\n            pass\r\n        (T, P, P_DEPENDENT_H_LIQ) = (self.T, self.P, self.P_DEPENDENT_H_LIQ)\r\n        (Cp, zs) = (0.0, self.zs)\r\n        Cpigs_pure = self.Cpigs_pure()\r\n        if P_DEPENDENT_H_LIQ:\r\n            try:\r\n                Psats = self._Psats\r\n            except AttributeError:\r\n                Psats = self.Psats()\r\n            try:\r\n                dPsats_dT = self._dPsats_dT\r\n            except AttributeError:\r\n                dPsats_dT = self.dPsats_dT()\r\n            try:\r\n                d2Psats_dT2 = self._d2Psats_dT2\r\n            except AttributeError:\r\n                d2Psats_dT2 = self.d2Psats_dT2()\r\n            try:\r\n                Vms_sat = self._Vms_sat\r\n            except AttributeError:\r\n                Vms_sat = self.Vms_sat()\r\n            try:\r\n                dVms_sat_dT = self._Vms_sat_dT\r\n            except AttributeError:\r\n                dVms_sat_dT = self.dVms_sat_dT()\r\n            try:\r\n                d2Vms_sat_dT2 = self._d2Vms_sat_dT2\r\n            except AttributeError:\r\n                d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\r\n            failed_dPsat_dT = False\r\n            try:\r\n                for i in range(self.N):\r\n                    x0 = Psats[i]\r\n                    Psat_inv = 1.0 / x0\r\n                    x1 = Vms_sat[i]\r\n                    x2 = dPsats_dT[i]\r\n                    x3 = R * Psat_inv\r\n                    x4 = T * x3\r\n                    x5 = -x1\r\n                    x6 = dVms_sat_dT[i]\r\n                    x7 = T * x2\r\n                    Cp += zs[i] * (-T * (P - x0) * d2Vms_sat_dT2[i] - T * (x4 + x5) * d2Psats_dT2[i] + x2 * (x1 - x4) + x2 * (T * x6 + x5) - x7 * (-R * x7 * Psat_inv * Psat_inv + x3 - x6) + Cpigs_pure[i])\r\n                \"\\n                from sympy import *\\n                T, P, R, zi = symbols('T, P, R, zi')\\n                Psat, Cpig_int, Vmsat = symbols('Psat, Cpig_int, Vms"]
[23.856427, "o", "at', cls=Function)\\n                dVmsatdT = diff(Vmsat(T), T)\\n                dPsatdT = diff(Psat(T), T)\\n                dV_vap = R*T/Psat(T) - Vmsat(T)\\n                dS_vap = dPsatdT*dV_vap\\n                Hvap = T*dS_vap\\n                H = zi*(Cpig_int(T) - Hvap)\\n\\n                dP = P - Psat(T)\\n                H += zi*dP*(Vmsat(T) - T*dVmsatdT)\\n\\n                (cse(diff(H, T), optimizations='basic'))\\n                \"\r\n            except (ZeroDivisionError, ValueError):\r\n                failed_dPsat_dT = True\r\n            if failed_dPsat_dT or isinf(Cp) or isnan(Cp):\r\n                dlnPsats_dT = self.dlnPsats_dT()\r\n                d2lnPsats_dT2 = self.d2lnPsats_dT2()\r\n                Cp = 0.0\r\n                for i in range(self.N):\r\n                    Cp += zs[i] * (Cpigs_pure[i] - P * T * d2Vms_sat_dT2[i] - R * T * T * d2lnPsats_dT2[i] - 2.0 * R * T * dlnPsats_dT[i])\r\n                    \"\\n                    from sympy import *\\n                    T, P, R, zi = symbols('T, P, R, zi')\\n                    lnPsat, Cpig_T_int, Vmsat = symbols('lnPsat, Cpig_T_int, Vmsat', cls=Function)\\n                    dVmsatdT = diff(Vmsat(T), T)\\n                    dPsatdT = diff(exp(lnPsat(T)), T)\\n                    dV_vap = R*T/exp(lnPsat(T)) - Vmsat(T)\\n                    dS_vap = dPsatdT*dV_vap\\n                    Hvap = T*dS_vap\\n                    H = zi*(Cpig_int(T) - Hvap)\\n                    dP = P\\n                    H += zi*dP*(Vmsat(T) - T*dVmsatdT)\\n                    print(simplify(expand(diff(H, T)).subs(exp(lnPsat(T)), 0)/zi))\\n                    \"\r\n        else:\r\n            dHvaps_dT = self.dHvaps_dT()\r\n            for i in range(self.N):\r\n                Cp += zs[i] * (Cpigs_pure[i] - dHvaps_dT[i])\r\n        Cp += self.GibbsExcessModel.CpE()\r\n        return Cp\r\n\r\n    def Cp(self):\r\n        try:\r\n            return self._Cp\r\n        except AttributeError:\r\n            pass\r\n        (T, zs, cmps) = (self.T, self.zs, range(self.N))\r\n        Cpigs_pure = self.Cpigs_pure()\r\n        (use_Poynting, use_phis_sat) = (self.use_Poynting, self.use_phis_sat)\r\n        if use_Poynting:\r\n            try:\r\n                d2Poyntings_dT2 = self._d2Poyntings_dT2\r\n            except AttributeError:\r\n                d2Poyntings_dT2 = self.d2Poyntings_dT2()\r\n            try:\r\n                dPoyntings_dT = self._dPoyntings_dT\r\n            except AttributeError:\r\n                dPoyntings_dT = self.dPoyntings_dT()\r\n            try:\r\n                Poyntings = self._Poyntings\r\n            except AttributeError:\r\n                Poyntings = self.Poyntings()\r\n        if use_phis_sat:\r\n            try:\r\n                d2phis_sat_dT2 = self._d2phis_sat_dT2\r\n            except AttributeError:\r\n                d2phis_sat_dT2 = self.d2phis_sat_dT2()\r\n            try:\r\n                dphis_sat_dT = self._dphis_sat_dT\r\n            except AttributeError:\r\n                dphis_sat_dT = self.dphis_sat_dT()\r\n            try:\r\n                phis_sat = self._phis_sat\r\n            except AttributeError:\r\n                phis_sat = self.phis_sat()\r\n        dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\r\n        d2Psats_dT2_over_Psats = self.d2Psats_dT2_over_Psats()\r\n        RT = R * T\r\n        RT2 = RT * T\r\n        RT2_2 = RT + RT\r\n        Cp = 0.0\r\n        if use_Poynting and use_phis_sat:\r\n            for i in cmps:\r\n                Poy_inv = 1.0 / Poyntings[i]\r\n                phi_inv = 1.0 / phis_sat[i]\r\n                dPoy_ratio = dPoyntings_dT[i] * Poy_inv\r\n                dphi_ratio = dphis_sat_dT[i] * phi_inv\r\n                a = d2phis_sat_dT2[i] * phi_inv - dphi_ratio * dphi_ratio + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i] + d2Poyntings_dT2[i] * Poy_inv - dPoy_ratio * dPoy_ratio\r\n                b = dphi_ratio + dPsats_dT_over_Psats[i] + dPoy_ratio\r\n                Cp -= zs[i] * (RT2 * a + RT2_2 * b - Cpigs_pure[i])\r\n        elif use_Poynting:\r\n            for i in cmps:\r\n                Poy_inv = 1.0 / Poyntings[i]\r\n                dPoy_ratio = dPoyntings_d"]
[23.857059, "o", "T[i] * Poy_inv\r\n                a = d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i] + d2Poyntings_dT2[i] * Poy_inv - dPoy_ratio * dPoy_ratio\r\n                b = dPsats_dT_over_Psats[i] + dPoy_ratio\r\n                Cp -= zs[i] * (RT2 * a + RT2_2 * b - Cpigs_pure[i])\r\n        elif use_phis_sat:\r\n            for i in cmps:\r\n                phi_inv = 1.0 / phis_sat[i]\r\n                dphi_ratio = dphis_sat_dT[i] * phi_inv\r\n                a = d2phis_sat_dT2[i] * phi_inv - dphi_ratio * dphi_ratio + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i]\r\n                b = dphi_ratio + dPsats_dT_over_Psats[i]\r\n                Cp -= zs[i] * (RT2 * a + RT2_2 * b - Cpigs_pure[i])\r\n        else:\r\n            for i in cmps:\r\n                a = d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i]\r\n                b = dPsats_dT_over_Psats[i]\r\n                Cp -= zs[i] * (RT2 * a + RT2_2 * b - Cpigs_pure[i])\r\n        if not self.composition_independent:\r\n            Cp += self.GibbsExcessModel.CpE()\r\n        self._Cp = Cp\r\n        return Cp\r\n    dH_dT = Cp\r\n\r\n    def dS_dT_old(self):\r\n        (T, P, P_DEPENDENT_H_LIQ) = (self.T, self.P, self.P_DEPENDENT_H_LIQ)\r\n        RT = R * T\r\n        zs = self.zs\r\n        Cpigs_pure = self.Cpigs_pure()\r\n        dS_dT = 0.0\r\n        T_inv = 1.0 / T\r\n        if P_DEPENDENT_H_LIQ:\r\n            d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\r\n            dVms_sat_dT = self.dVms_sat_dT()\r\n            Vms_sat = self.Vms_sat()\r\n            Psats = self.Psats()\r\n            dPsats_dT = self.dPsats_dT()\r\n            d2Psats_dT2 = self.d2Psats_dT2()\r\n            failed_dPsat_dT = False\r\n            for Psat in Psats:\r\n                if Psat < 1e-40:\r\n                    failed_dPsat_dT = True\r\n            if not failed_dPsat_dT:\r\n                try:\r\n                    \"\\n                    from sympy import *\\n                    T, P, R, zi, P_REF_IG = symbols('T, P, R, zi, P_REF_IG')\\n\\n                    Psat, Cpig_T_int, Vmsat = symbols('Psat, Cpig_T_int, Vmsat', cls=Function)\\n                    dVmsatdT = diff(Vmsat(T), T)\\n                    dPsatdT = diff(Psat(T), T)\\n\\n                    S = 0\\n                    dSi = Cpig_T_int(T)\\n                    dVsat = R*T/Psat(T) - Vmsat(T)\\n                    dSvap = dPsatdT*dVsat\\n                    dSi -= dSvap\\n                    dSi -= R*log(Psat(T)/P_REF_IG)\\n                    dP = P - Psat(T)\\n                    dSi -= dP*dVmsatdT\\n                    S += dSi*zi\\n                    # cse(diff(S, T), optimizations='basic')\\n                    \"\r\n                    for i in range(self.N):\r\n                        x0 = Psats[i]\r\n                        x1 = dPsats_dT[i]\r\n                        x2 = R / x0\r\n                        x3 = Vms_sat[i]\r\n                        x4 = dVms_sat_dT[i]\r\n                        dS_dT -= zs[i] * (x1 * x2 - x1 * x4 - x1 * (RT * x1 / x0 ** 2 - x2 + x4) + (P - x0) * d2Vms_sat_dT2[i] + (T * x2 - x3) * d2Psats_dT2[i] - Cpigs_pure[i] * T_inv)\r\n                except (ZeroDivisionError, ValueError):\r\n                    failed_dPsat_dT = True\r\n            if failed_dPsat_dT:\r\n                dlnPsats_dT = self.dlnPsats_dT()\r\n                d2lnPsats_dT2 = self.d2lnPsats_dT2()\r\n                \"\\n                from sympy import *\\n                T, P, R, zi, P_REF_IG = symbols('T, P, R, zi, P_REF_IG')\\n\\n                lnPsat, Cpig_T_int, Vmsat = symbols('lnPsat, Cpig_T_int, Vmsat', cls=Function)\\n                # Psat, Cpig_T_int, Vmsat = symbols('Psat, Cpig_T_int, Vmsat', cls=Function)\\n                dVmsatdT = diff(Vmsat(T), T)\\n                dPsatdT = diff(exp(lnPsat(T)), T)\\n\\n                S = 0\\n                dSi = Cpig_T_int(T)\\n                dVsat = R*T/exp(lnPsat(T)) - Vmsat(T)\\n                dSvap = dPsatdT*dVsat\\n                dSi -= dSvap\\n                # dSi -= R*log(Psat(T)/P_REF_IG)\\n                dSi -= R*(lnPsat(T) - log(P_REF_IG))\\n                dP = P - exp(lnPsat(T))\\n                dSi -= dP*dVmsatdT\\n                S += dSi*zi\\n                # cse(diff(S, T), optimizations='basic')\\n                print(simplify(expand(diff(S, T)).subs(exp(lnPsat(T)), 0)/zi))\\n\\n\\n                \"\r\n                dS_dT = 0.0\r\n                for i in range(self.N):\r\n                    dS_dT -= zs[i] * (P * d2Vms_sat_dT2[i] + RT * d2lnPsats_dT2[i] + 2.0 * R * dlnPsats_dT[i] - Cpigs_pure[i] * T_inv)\r\n        dS_dT += self.GibbsExcessModel.dSE_dT()\r\n        return dS_dT\r\n\r\n    def dS_dT(self):\r\n        try:\r\n            return self._dS_dT\r\n        except AttributeError:\r\n            pass\r\n        (T, zs, cmps) = (self.T, self.zs, range(self.N))\r\n        (use_Poynting, use_phis_sat) = (self.use_Poynting, self.use_phis_sat)\r\n        if use_Poynting:\r\n            try:\r\n                d2Poyntings_dT2 = self._d2Poyntings_dT2\r\n            except AttributeError:\r\n                d2Poyntings_dT2 = self.d2Poyntings_dT2()\r\n            try:\r\n                dPoyntings_dT = self._dPoyntings_dT\r\n            except AttributeError:\r\n                dPoyntings_dT = self.dPoyntings_dT()\r\n            try:\r\n                Poyntings = self._Poyntings\r\n            except AttributeError:\r\n                Poyntings = self.Poyntings()\r\n        if use_phis_sat:\r\n            try:\r\n                d2phis_sat_dT2 = self._d2phis_sat_dT2\r\n            except AttributeError:\r\n                d2phis_sat_dT2 = self.d2phis_sat_dT2()\r\n            try:\r\n                dphis_sat_dT = self._dphis_sat_dT\r\n            except AttributeError:\r\n                dphis_sat_dT = self.dphis_sat_dT()\r\n            try:\r\n                phis_sat = self._phis_sat\r\n            except AttributeError:\r\n                phis_sat = self.phis_sat()\r\n        dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\r\n        d2Psats_dT2_over_Psats = self.d2Psats_dT2_over_Psats()\r\n        Cpigs_pure = self.Cpigs_pure()\r\n        T_inv = 1.0 / T\r\n        RT = R * T\r\n        R_2 = R + R\r\n        dS_dT = 0.0\r\n        if use_Poynting and use_phis_sat:\r\n            for i in cmps:\r\n                Poy_inv = 1.0 / Poyntings[i]\r\n                phi_inv = 1.0 / phis_sat[i]\r\n                dPoy_ratio = dPoyntings_dT[i] * Poy_inv\r\n                dphi_ratio = dphis_sat_dT[i] * phi_inv\r\n                a = d2phis_sat_dT2[i] * phi_inv - dphi_ratio * dphi_ratio + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i] + d2Poyntings_dT2[i] * Poy_inv - dPoy_ratio * dPoy_ratio\r\n                b = dphi_ratio + dPsats_dT_over_Psats[i] + dPoy_ratio\r\n                dS_dT -= zs[i] * (RT * a + b * R_2 - Cpigs_pure[i] * T_inv)\r\n        elif use_Poynting:\r\n            for i in cmps:\r\n                Poy_inv = 1.0 / Poyntings[i]\r\n                dPoy_ratio = dPoyntings_dT[i] * Poy_inv\r\n                a = d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i] + d2Poyntings_dT2[i] * Poy_inv - dPoy_ratio * dPoy_ratio\r\n                b = dPsats_dT_over_Psats[i] + dPoy_ratio\r\n                dS_dT -= zs[i] * (RT * a + b * R_2 - Cpigs_pure[i] * T_inv)\r\n        elif use_phis_sat:\r\n            for i in cmps:\r\n                phi_inv = 1.0 / phis_sat[i]\r\n                dphi_ratio = dphis_sat_dT[i] * phi_inv\r\n                a = d2phis_sat_dT2[i] * phi_inv - dphi_ratio * dphi_ratio + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i]\r\n                b = dphi_ratio + dPsats_dT_over_Psats[i]\r\n                dS_dT -= zs[i] * (RT * a + b * R_2 - Cpigs_pure[i] * T_inv)\r\n        else:\r\n            for i in cmps:\r\n                a = d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i]\r\n                b = dPsats_dT_over_Psats[i]\r\n                dS_dT -= zs[i] * (RT * a + b * R_2 - Cpigs_pure[i] * T_inv)\r\n        if not self.composition_independent:\r\n            dS_dT += self.GibbsExcessModel.dSE_dT()\r\n        self._dS_dT = dS_dT\r\n        return dS_dT\r\n\r\n    def dH_dP(self):\r\n        \"\"\"\r\n        TODO: Implement this function\r\n        \"\"\"\r\n        ...\r\n\r\n    def dS_dP(self):\r\n        try:\r\n            return self._dS_dP\r\n        except AttributeError:\r\n            pass\r\n        T = self.T\r\n        P = self.P\r\n        P_inv = 1.0 / P\r\n        zs = self.zs\r\n        if self.use_Poynting:\r\n            dS_dP = -R * P_inv\r\n            Poyntings = self.Poyntings()\r\n            dPoyntings_dP = self.dPoyntings_dP()\r\n            dPoyntings_dT = self.dPoyntings_dT()\r\n            d2Poyntings_dPdT = self.d2Poyntings_dPdT()\r\n            for i in range(self.N):\r\n                Poy_inv = 1.0 / Poyntings[i]\r\n                dS_dP -= zs[i] * R * Poy_inv * (dPoyntings_dP[i] - Poyntings[i] * P_inv + T * (d2Poyntings_dPdT[i] - dPoyntings_dP[i] * dPoyntings_dT[i] * Poy_inv))\r\n        else:\r\n            dS_dP = 0.0\r\n        self._dS_dP = dS_dP\r\n        return dS_dP\r\n\r\n    def H_dep(self):\r\n        return self.H() - self.H_ideal_gas()\r\n\r\n    def S_dep(self):\r\n        return self.S() - self.S_ideal_gas()\r\n\r\n    def Cp_dep(self):\r\n        return self.Cp() - self.Cp_ideal_gas()\r\n\r\n    def V(self):\r\n        try:\r\n            return self._V\r\n        except AttributeError:\r\n            pass\r\n        zs = self.zs\r\n        Vms = self.Vms()\r\n        'To make a fugacity-volume identity consistent, cannot use pressure\\n        correction unless the Poynting factor is calculated with quadrature/\\n        integration.\\n        '\r\n        V = 0.0\r\n        for i in range(self.N):\r\n            V += zs[i] * Vms[i]\r\n        self._V = V\r\n        return V\r\n\r\n    def dV_dT(self):\r\n        try:\r\n            return self._dV_dT\r\n        except AttributeError:\r\n            pass\r\n        zs = self.zs\r\n        dVms_sat_dT = self.dVms_sat_dT()\r\n        dV_dT = 0.0\r\n        for i in range(self.N):\r\n            dV_dT += zs[i] * dVms_sat_dT[i]\r\n        self._dV_dT = dV_dT\r\n        return dV_dT\r\n\r\n    def d2V_dT2(self):\r\n        try:\r\n            return self._d2V_dT2\r\n        except AttributeError:\r\n            pass\r\n        zs = self.zs\r\n        d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\r\n        d2V_dT2 = 0.0\r\n        for i in range(self.N):\r\n            d2V_dT2 += zs[i] * d2Vms_sat_dT2[i]\r\n        self._d2V_dT2 = d2V_dT2\r\n        return d2V_dT2\r\n\r\n    def dP_dV(self):\r\n        try:\r\n            return self._dP_dV\r\n        except AttributeError:\r\n            pass\r\n        if self.incompressible:\r\n            self._dP_dV = self.INCOMPRESSIBLE_CONST\r\n        return self._dP_dV\r\n\r\n    def d2P_dV2(self):\r\n        try:\r\n            return self._d2P_dV2\r\n        except AttributeError:\r\n            pass\r\n        if self.incompressible:\r\n            self._d2P_dV2 = self.INCOMPRESSIBLE_CONST\r\n        return self._d2P_dV2\r\n\r\n    def dP_dT(self):\r\n        try:\r\n            return self._dP_dT\r\n        except AttributeError:\r\n            pass\r\n        self._dP_dT = self.dV_dT() / -self.dP_dV()\r\n        return self._dP_dT\r\n\r\n    def d2P_dTdV(self):\r\n        try:\r\n            return self._d2P_dTdV\r\n        except AttributeError:\r\n            pass\r\n        if self.incompressible:\r\n            self._d2P_dTdV = 0.0\r\n        else:\r\n            P = self.P\r\n\r\n            def dP_dV_for_diff(T):\r\n                return 1.0 / self.VolumeLiquidMixture.property_derivative_P(T, P, self.zs, order=1)\r\n            self._d2P_dTdV = derivative(dP_dV_for_diff, self.T)\r\n        return self._d2P_dTdV\r\n\r\n    def d2P_dT2(self):\r\n        try:\r\n            return self._d2P_dT2\r\n        except AttributeError:\r\n            pass\r\n        if self.incompressible:\r\n            self._d2P_dT2 = -self.d2V_dT2() / self.INCOMPRESSIBLE_CONST\r\n        else:\r\n            (P, zs) = (self.P, self.zs)\r\n\r\n            def dP_dT_for_diff(T):\r\n                dV_dT = self.VolumeLiquidMixture.property_derivative_T(T, P, zs, order=1)\r\n                dP_dV = 1.0 / self.VolumeLiquidMixture.property_derivative_P(T, P, zs, order=1)\r\n                dP_dT = dV_dT / -dP_dV\r\n                return dP_dT\r\n            self._d2P_dT2 = derivative(dP_dT_for_diff, self.T)\r\n        return self._d2P_dT2\r\n\r\n    def d2V_dP2(self):\r\n        try:\r\n            return self._d2V_dP2\r\n        except AttributeError:\r\n         "]
[23.857248, "o", "   pass\r\n        if self.incompressible:\r\n            self._d2V_dP2 = 0.0\r\n        return self._d2V_dP2\r\n\r\n    def Tait_Bs(self):\r\n        try:\r\n            return self._Tait_Bs\r\n        except:\r\n            pass\r\n        self._Tait_Bs = evaluate_linear_fits(self._Tait_B_data, self.T)\r\n        return self._Tait_Bs\r\n\r\n    def dTait_B_dTs(self):\r\n        try:\r\n            return self._dTait_B_dTs\r\n        except:\r\n            pass\r\n        self._dTait_B_dTs = evaluate_linear_fits_d(self._Tait_B_data, self.T)\r\n        return self._dTait_B_dTs\r\n\r\n    def d2Tait_B_dT2s(self):\r\n        try:\r\n            return self._d2Tait_B_dT2s\r\n        except:\r\n            pass\r\n        self._d2Tait_B_dT2s = evaluate_linear_fits_d2(self._Tait_B_data, self.T)\r\n        return self._d2Tait_B_dT2s\r\n\r\n    def Tait_Cs(self):\r\n        try:\r\n            return self._Tait_Cs\r\n        except:\r\n            pass\r\n        self._Tait_Cs = evaluate_linear_fits(self._Tait_C_data, self.T)\r\n        return self._Tait_Cs\r\n\r\n    def dTait_C_dTs(self):\r\n        try:\r\n            return self._dTait_C_dTs\r\n        except:\r\n            pass\r\n        self._dTait_C_dTs = evaluate_linear_fits_d(self._Tait_C_data, self.T)\r\n        return self._dTait_C_dTs\r\n\r\n    def d2Tait_C_dT2s(self):\r\n        try:\r\n            return self._d2Tait_C_dT2s\r\n        except:\r\n            pass\r\n        self._d2Tait_C_dT2s = evaluate_linear_fits_d2(self._Tait_C_data, self.T)\r\n        return self._d2Tait_C_dT2s\r\n\r\n    def Tait_Vs(self):\r\n        Vms_sat = self.Vms_sat()\r\n        Psats = self.Psats()\r\n        Tait_Bs = self.Tait_Bs()\r\n        Tait_Cs = self.Tait_Cs()\r\n        P = self.P\r\n        return [Vms_sat[i] * (1.0 - Tait_Cs[i] * log((Tait_Bs[i] + P) / (Tait_Bs[i] + Psats[i]))) for i in range(self.N)]\r\n\r\n    def dH_dP_integrals_Tait(self):\r\n        try:\r\n            return self._dH_dP_integrals_Tait\r\n        except AttributeError:\r\n            pass\r\n        Psats = self.Psats()\r\n        Vms_sat = self.Vms_sat()\r\n        dVms_sat_dT = self.dVms_sat_dT()\r\n        dPsats_dT = self.dPsats_dT()\r\n        Tait_Bs = self.Tait_Bs()\r\n        Tait_Cs = self.Tait_Cs()\r\n        dTait_C_dTs = self.dTait_C_dTs()\r\n        dTait_B_dTs = self.dTait_B_dTs()\r\n        (T, P) = (self.T, self.P)\r\n        self._dH_dP_integrals_Tait = dH_dP_integrals_Tait = []\r\n        for i in range(self.N):\r\n            x0 = Tait_Bs[i]\r\n            x1 = P + x0\r\n            x2 = Psats[i]\r\n            x3 = x0 + x2\r\n            x4 = 1.0 / x3\r\n            x5 = Tait_Cs[i]\r\n            x6 = Vms_sat[i]\r\n            x7 = x5 * x6\r\n            x8 = T * dVms_sat_dT[i]\r\n            x9 = x5 * x8\r\n            x10 = T * dTait_C_dTs[i]\r\n            x11 = x0 * x6\r\n            x12 = T * x7\r\n            x13 = -x0 * x7 + x0 * x9 + x10 * x11 + x12 * dTait_B_dTs[i]\r\n            x14 = x2 * x6\r\n            x15 = x4 * (x0 * x8 + x10 * x14 - x11 + x12 * dPsats_dT[i] + x13 - x14 - x2 * x7 + x2 * x8 + x2 * x9)\r\n            val = -P * x15 + P * (x10 * x6 - x7 + x9) * log(x1 * x4) + x13 * log(x1) - x13 * log(x3) + x15 * x2\r\n            dH_dP_integrals_Tait.append(val)\r\n        return dH_dP_integrals_Tait\r\n\r\n    def mu(self):\r\n        try:\r\n            return self._mu\r\n        except AttributeError:\r\n            pass\r\n        mu = self._mu = self.correlations.ViscosityLiquidMixture.mixture_property(self.T, self.P, self.zs, self.ws())\r\n        return mu\r\n\r\n    def k(self):\r\n        try:\r\n            return self._k\r\n        except AttributeError:\r\n            pass\r\n        self._k = k = self.correlations.ThermalConductivityLiquidMixture.mixture_property(self.T, self.P, self.zs, self.ws())\r\n        return k\r\n\r\nclass GibbsExcessSolid(GibbsExcessLiquid):\r\n    ideal_gas_basis = True\r\n    force_phase = 's'\r\n    phase = 's'\r\n    is_gas = False\r\n    is_liquid = False\r\n    is_solid = True\r\n    pure_references = ('HeatCapacityGases', 'SublimationPressures', 'VolumeSolids', 'EnthalpySublimations')\r\n    pure_reference_types = (HeatCapacityGas, SublimationPressure, VolumeSolid, EnthalpySublimation)\r\n    model_attributes = ('Hfs', 'Gfs', 'Sfs', 'GibbsExcessModel', 'eos"]
[23.857289, "o", "_pure_instances', 'use_Poynting', 'use_phis_sat', 'use_eos_volume', 'henry_components', 'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'Psat_extrpolation') + pure_references\r\n\r\n    def __init__(self, SublimationPressures, VolumeSolids=None, GibbsExcessModel=IdealSolution, eos_pure_instances=None, VolumeLiquidMixture=None, HeatCapacityGases=None, EnthalpySublimations=None, use_Poynting=False, use_phis_sat=False, Hfs=None, Gfs=None, Sfs=None, T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None):\r\n        super().__init__(VaporPressures=SublimationPressures, VolumeLiquids=VolumeSolids, HeatCapacityGases=HeatCapacityGases, EnthalpyVaporizations=EnthalpySublimations, use_Poynting=use_Poynting, Hfs=Hfs, Gfs=Gfs, Sfs=Sfs, T=T, P=P, zs=zs)\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[29.736984, "i", "cat thermo/phases/gibbs_excess.py | grep -A 10 'def to_TP_zs'\n"]
[29.737568, "o", "cat thermo/phases/gibbs_excess.py | grep -A 10 'def to_TP_zs'\r\n\u001b[?2004l\r"]
[29.73991, "o", "    def to_TP_zs(self, T, P, zs):\r\n        \"\"\"\r\n        TODO: Implement this function\r\n        \"\"\"\r\n        ...\r\n\r\n"]
[29.740001, "o", "    def to(self, zs, T=None, P=None, V=None):\r\n        \"\"\"\r\n        TODO: Implement this function\r\n        \"\"\"\r\n        ...\r\n"]
[29.740375, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[34.265883, "i", "nano thermo/phases/gibbs_excess.py\n"]
[34.266338, "o", "nano thermo/phases/gibbs_excess.py\r\n\u001b[?2004l\r"]
[34.266925, "o", "bash: nano: command not found\r\n"]
[34.267209, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[50.907778, "i", "vi thermo/phases/gibbs_excess.py\n"]
[50.908237, "o", "vi thermo/phases/gibbs_excess.py\r\n\u001b[?2004l\r"]
[50.908687, "o", "bash: vi: command not found\r\n"]
[50.908915, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[80.14161, "i", "cat > thermo/phases/gibbs_excess.py << 'EOF'\nimport numpy as np\n\nclass GibbsExcessLiquid:\n    # Existing code...\n\n    def to_TP_zs(self, T, P, zs):\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\n\n    def to(self, zs, T=None, P=None, V=None):\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\n        T = T if T is not None else self.T\n        P = P if P is not None else self.P\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\n\n# Rest of the existing code...\nEOF\n"]
[80.1422, "o", "cat > thermo/phases/gibbs_excess.py << 'EOF'\r\n\u001b[?2004l\r"]
[80.142279, "o", "\u001b[?2004h> "]
[80.142469, "o", "import numpy as np\r\n\u001b[?2004l\r"]
[80.142543, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h"]
[80.14268, "o", "> "]
[80.142829, "o", "class GibbsExcessLiquid:\r\n\u001b[?2004l\r"]
[80.142895, "o", "\u001b[?2004h> "]
[80.143123, "o", "    # Existing code...\r\n\u001b[?2004l\r"]
[80.143229, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h"]
[80.143326, "o", "> "]
[80.143556, "o", "    def to_TP_zs(self, T, P, zs):\r\n\u001b[?2004l\r"]
[80.143621, "o", "\u001b[?2004h> "]
[80.144297, "o", "        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\r\n\u001b[?2004l\r"]
[80.144362, "o", "\u001b[?2004h> "]
[80.144901, "o", "        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n\u001b[?2004l\r"]
[80.144966, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[80.145102, "o", "\u001b[?2004h> "]
[80.145423, "o", "    def to(self, zs, T=None, P=None, V=None):\r\n\u001b[?2004l\r"]
[80.145486, "o", "\u001b[?2004h> "]
[80.146178, "o", "        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\r\n\u001b[?2004l\r"]
[80.146243, "o", "\u001b[?2004h> "]
[80.146579, "o", "        T = T if T is not None else self.T\r\n\u001b[?2004l\r"]
[80.146644, "o", "\u001b[?2004h> "]
[80.147001, "o", "        P = P if P is not None else self.P\r\n\u001b[?2004l\r"]
[80.147076, "o", "\u001b[?2004h> "]
[80.147627, "o", "        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n\u001b[?2004l\r"]
[80.147693, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[80.147754, "o", "\u001b[?2004h> "]
[80.148041, "o", "# Rest of the existing code...\r\n\u001b[?2004l\r"]
[80.148113, "o", "\u001b[?2004h> EOF\r\n"]
[80.148177, "o", "\u001b[?2004l\r"]
[80.150946, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[103.579036, "i", "pytest tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi -v\n"]
[103.579791, "o", "pytest tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi -v\r\n\u001b[?2004l\r"]
[103.703229, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[103.704996, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[103.705139, "o", "\u001b[1mcollecting ... \u001b[0m"]
[104.275602, "o", "\u001b[1m\rcollecting 0 items / 2 errors                                                                                                                                  \u001b[0m\u001b[1m\rcollected 0 items / 2 errors                                                                                                                                   \u001b[0m\r\n"]
[104.276265, "o", "\r\n============================================================================ ERRORS ============================================================================\r\n"]
[104.276416, "o", "\u001b[31m\u001b[1m____________________________________________________________ ERROR collecting tests/test_phases.py _____________________________________________________________\u001b[0m\r\n\u001b[31mImportError while importing test module '/workspace/repo/tests/test_phases.py'.\r\nHint: make sure your test modules/packages have valid Python names.\r\nTraceback:\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\ntests/test_phases.py:33: in <module>\r\n    from thermo import EXP_POLY_FIT\r\nthermo/__init__.py:66: in <module>\r\n    from . import (\r\nthermo/bulk.py:82: in <module>\r\n    from thermo.phases import Phase\r\nthermo/phases/__init__.py:185: in <module>\r\n    from thermo.phases.gibbs_excess import GibbsExcessLiquid, GibbsExcessSolid\r\nE   ImportError: cannot import name 'GibbsExcessSolid' from 'thermo.phases.gibbs_excess' (/workspace/repo/thermo/phases/gibbs_excess.py)\u001b[0m\r\n\u001b[31m\u001b[1m____________________________________________________________ ERROR collecting tests/test_phases.py _____________________________________________________________\u001b[0m\r\n\u001b[31mImportError while importing test module '/workspace/repo/tests/test_phases.py'.\r\nHint: make sure your test modules/packages have valid Python names.\r\nTraceback:\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\ntests/test_phases.py:33: in <module>\r\n    from thermo import EXP_POLY_FIT\r\nthermo/__init__.py:66: in <module>\r\n    from . import (\r\nthermo/bulk.py:82: in <module>\r\n    from thermo.phases import Phase\r\nthermo/phases/__init__.py:185: in <module>\r\n    from thermo.phases.gibbs_excess import GibbsExcessLiquid, GibbsExcessSolid\r\nE   ImportError: cannot import name 'GibbsExcessSolid' from 'thermo.phases.gibbs_excess' (/workspace/repo/thermo/phases/gibbs_excess.py)\u001b[0m"]
[104.276489, "o", "\r\n\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_phases.py\r\n\u001b[31mERROR\u001b[0m tests/test_phases.py\r\n"]
[104.27663, "o", "\u001b[31m====================================================================== \u001b[31m\u001b[1m2 errors\u001b[0m\u001b[31m in 0.57s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[104.303151, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi\r\n\u001b[0m\r\n"]
[104.388473, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[146.68487, "i", "cat thermo/phases/gibbs_excess.py\n"]
[146.685208, "o", "cat thermo/phases/gibbs_excess.py\r\n\u001b[?2004l\r"]
[146.68683, "o", "import numpy as np\r\n\r\nclass GibbsExcessLiquid:\r\n    # Existing code...\r\n\r\n    def to_TP_zs(self, T, P, zs):\r\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\r\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n\r\n    def to(self, zs, T=None, P=None, V=None):\r\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\r\n        T = T if T is not None else self.T\r\n        P = P if P is not None else self.P\r\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n\r\n# Rest of the existing code...\r\n"]
[146.687154, "o", "\u001b[?2004h"]
[146.687181, "o", "root@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[180.01542, "i", "sed -i '/def to_TP_zs/,/def to/c\\    def to_TP_zs(self, T, P, zs):\\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\\n\\n    def to(self, zs, T=None, P=None, V=None):\\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\\n        T = T if T is not None else self.T\\n        P = P if P is not None else self.P\\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())' thermo/phases/gibbs_excess.py\n"]
[180.017108, "o", "sed -i '/def to_TP_zs/,/def to/c\\    def to_TP_zs(self, T, P, zs):\\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\\n\\n    def to(self, zs, T=None, P=None, V=None):\\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\\n        T = T if T is not None else self.T\\n        P = P if P is not None else self.P\\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())' thermo/phases/gibbs_excess.py\r\n\u001b[?2004l\r"]
[180.019716, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[190.034203, "i", "pytest tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi -v\n"]
[190.034939, "o", "pytest tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi -v\r\n\u001b[?2004l\r"]
[190.152627, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[190.15432, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[190.154442, "o", "\u001b[1mcollecting ... \u001b[0m"]
[190.682811, "o", "\u001b[1m\rcollecting 0 items / 1 error                                                                                                                                   \u001b[0m"]
[190.789902, "o", "\u001b[1m\rcollected 0 items / 2 errors                                                                                                                                   \u001b[0m\r\n"]
[190.790477, "o", "\r\n============================================================================ ERRORS ============================================================================\r\n\u001b[31m\u001b[1m____________________________________________________________ ERROR collecting tests/test_phases.py _____________________________________________________________\u001b[0m\r\n\u001b[31mImportError while importing test module '/workspace/repo/tests/test_phases.py'.\r\nHint: make sure your test modules/packages have valid Python names.\r\nTraceback:\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\ntests/test_phases.py:33: in <module>\r\n    from thermo import EXP_POLY_FIT\r\nthermo/__init__.py:66: in <module>\r\n    from . import (\r\nthermo/bulk.py:82: in <module>\r\n    from thermo.phases import Phase\r\nthermo/phases/__init__.py:185: in <module>\r\n    from thermo.phases.gibbs_excess import GibbsExcessLiquid, GibbsExcessSolid\r\nE   ImportError: cannot import name 'GibbsExcessSolid' from 'thermo.phases.gibbs_excess' (/workspace/repo/thermo/phases/gibbs_excess.py)\u001b[0m\r\n\u001b[31m\u001b[1m____________________________________________________________ ERROR collecting tests/test_phases.py _____________________________________________________________\u001b[0m\r\n\u001b[31mImportError while importing test module '/workspace/repo/tests/test_phases.py'.\r\nHint: make sure your test modules/packages have valid Python names.\r\nTraceback:\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\ntests/test_phases.py:33: in <module>\r\n    from thermo import EXP_POLY_FIT\r\nthermo/__init__.py:66: in <module>\r\n    from . import (\r\nthermo/bulk.py:82: in <module>\r\n    from thermo.phases import Phase\r\nthermo/phases/__init__.py:185: in <module>\r\n    from thermo.phases.gibbs_excess import GibbsExcessLiquid, GibbsExcessSolid\r\nE   ImportError: cannot import name 'GibbsExcessSolid' from 'thermo.phases.gibbs_excess' (/workspace/repo/thermo/phases/gibbs_excess.py)\u001b[0m"]
[190.790651, "o", "\r\n"]
[190.790703, "o", "\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_phases.py\r\n\u001b[31mERROR\u001b[0m tests/test_phases.py\r\n\u001b[31m====================================================================== \u001b[31m\u001b[1m2 errors\u001b[0m\u001b[31m in 0.64s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[190.816077, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi\r\n\u001b[0m\r\n"]
[190.847173, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[210.723517, "i", "cat thermo/phases/gibbs_excess.py\n"]
[210.72388, "o", "cat thermo/phases/gibbs_excess.py\r\n\u001b[?2004l\r"]
[210.725492, "o", "import numpy as np\r\n\r\nclass GibbsExcessLiquid:\r\n    # Existing code...\r\n\r\n    def to_TP_zs(self, T, P, zs):\r\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\r\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n\r\n    def to(self, zs, T=None, P=None, V=None):\r\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\r\n        T = T if T is not None else self.T\r\n        P = P if P is not None else self.P\r\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\r\n        T = T if T is not None else self.T\r\n        P = P if P is not None else self.P\r\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n\r\n# Rest of the existing code...\r\n"]
[210.725805, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[253.5677, "i", "sed -i '/def to_TP_zs/,/def to/c\\    def to_TP_zs(self, T, P, zs):\\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\\n\\n    def to(self, zs, T=None, P=None, V=None):\\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\\n        T = T if T is not None else self.T\\n        P = P if P is not None else self.P\\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())' thermo/phases/gibbs_excess.py\n"]
[253.571414, "o", "sed -i '/def to_TP_zs/,/def to/c\\    def to_TP_zs(self, T, P, zs):\\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\\n\\n    def to(self, zs, T=None, P=None, V=None):\\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\\n        T = T if T is not None else self.T\\n        P = P if P is not None else self.P\\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())' thermo/phases/gibbs_excess.py\r\n\u001b[?2004l\r"]
[253.573374, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[254.215215, "i", "pytest tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi -v\n"]
[254.21577, "o", "pytest tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi -v\r\n\u001b[?2004l\r"]
[254.342599, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[254.344266, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[254.344324, "o", "\u001b[1mcollecting ... \u001b[0m"]
[254.937315, "o", "\u001b[1m\rcollecting 0 items / 2 errors                                                                                                                                  \u001b[0m\u001b[1m\rcollected 0 items / 2 errors                                                                                                                                   \u001b[0m\r\n"]
[254.937782, "o", "\r\n"]
[254.937844, "o", "============================================================================ ERRORS ============================================================================\r\n\u001b[31m\u001b[1m____________________________________________________________ ERROR collecting tests/test_phases.py _____________________________________________________________\u001b[0m\r\n\u001b[31mImportError while importing test module '/workspace/repo/tests/test_phases.py'.\r\nHint: make sure your test modules/packages have valid Python names.\r\nTraceback:\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\ntests/test_phases.py:33: in <module>\r\n    from thermo import EXP_POLY_FIT\r\nthermo/__init__.py:66: in <module>\r\n    from . import (\r\nthermo/bulk.py:82: in <module>\r\n    from thermo.phases import Phase\r\nthermo/phases/__init__.py:185: in <module>\r\n    from thermo.phases.gibbs_excess import GibbsExcessLiquid, GibbsExcessSolid\r\nE   ImportError: cannot import name 'GibbsExcessSolid' from 'thermo.phases.gibbs_excess' (/workspace/repo/thermo/phases/gibbs_excess.py)\u001b[0m\r\n\u001b[31m\u001b[1m____________________________________________________________ ERROR collecting tests/test_phases.py _____________________________________________________________\u001b[0m\r\n\u001b[31mImportError while importing test module '/workspace/repo/tests/test_phases.py'.\r\nHint: make sure your test modules/packages have valid Python names.\r\nTraceback:\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\ntests/test_phases.py:33: in <module>\r\n    from thermo import EXP_POLY_FIT\r\nthermo/__init__.py:66: in <module>\r\n    from . import (\r\nthermo/bulk.py:82: in <module>\r\n    from thermo.phases import Phase\r\nthermo/phases/__init__.py:185: in <module>\r\n    from thermo.phases.gibbs_excess import GibbsExcessLiquid, GibbsExcessSolid\r\nE   ImportError: cannot import name 'GibbsExcessSolid' from 'thermo.phases.gibbs_excess' (/workspace/repo/thermo/phases/gibbs_excess.py)\u001b[0m"]
[254.937983, "o", "\r\n\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_phases.py\r\n\u001b[31mERROR\u001b[0m tests/test_phases.py\r\n"]
[254.938105, "o", "\u001b[31m====================================================================== \u001b[31m\u001b[1m2 errors\u001b[0m\u001b[31m in 0.60s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[254.96631, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi\r\n\u001b[0m\r\n"]
[254.999386, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[285.054289, "i", "cat thermo/phases/gibbs_excess.py\n"]
[285.054636, "o", "cat thermo/phases/gibbs_excess.py\r\n\u001b[?2004l\r"]
[285.056122, "o", "import numpy as np\r\n\r\nclass GibbsExcessLiquid:\r\n    # Existing code...\r\n\r\n    def to_TP_zs(self, T, P, zs):\r\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\r\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n\r\n    def to(self, zs, T=None, P=None, V=None):\r\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\r\n        T = T if T is not None else self.T\r\n        P = P if P is not None else self.P\r\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\r\n        T = T if T is not None else self.T\r\n        P = P if P is not None else self.P\r\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\r\n        T = T if T is not None else self.T\r\n        P = P if P is not None else self.P\r\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n\r\n# Rest of the existing code...\r\n"]
[285.056411, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[376.253861, "i", "cat > thermo/phases/gibbs_excess.py << 'EOF'\nimport numpy as np\n\nclass GibbsExcessLiquid:\n    # Existing code...\n\n    def to_TP_zs(self, T, P, zs):\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\n\n    def to(self, zs, T=None, P=None, V=None):\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\n        T = T if T is not None else self.T\n        P = P if P is not None else self.P\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\n\nclass GibbsExcessSolid(GibbsExcessLiquid):\n    ideal_gas_basis = True\n    force_phase = 's'\n    phase = 's'\n    is_gas = False\n    is_liquid = False\n    is_solid = True\n    pure_references = ('HeatCapacityGases', 'SublimationPressures', 'VolumeSolids', 'EnthalpySublimations')\n    pure_reference_types = (HeatCapacityGas, SublimationPressure, VolumeSolid, EnthalpySublimation)\n    model_attributes = ('Hfs', 'Gfs', 'Sfs', 'GibbsExcessModel', 'eos_pure_instances', 'use_Poynting', 'use_phis_sat', 'use_eos_volume', 'henry_components', 'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'Psat_extrpolation') + pure_references\n\n    def __init__(self, SublimationPressures, VolumeSolids=None, GibbsExcessModel=IdealSolution, eos_pure_instances=None, VolumeLiquidMixture=None, HeatCapacityGases=None, EnthalpySublimations=None, use_Poynting=False, use_phis_sat=False, Hfs=None, Gfs=None, Sfs=None, T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None):\n        super().__init__(VaporPressures=SublimationPressures, VolumeLiquids=VolumeSolids, HeatCapacityGases=HeatCapacityGases, EnthalpyVaporizations=EnthalpySublimations, use_Poynting=use_Poynting, Hfs=Hfs, Gfs=Gfs, Sfs=Sfs, T=T, P=P, zs=zs)\n\n# Rest of the existing code...\nEOF\n"]
[376.254192, "o", "cat > thermo/phases/gibbs_excess.py << 'EOF'\r\n\u001b[?2004l\r\u001b[?2004h"]
[376.254252, "o", "> import numpy as np\r\n\u001b[?2004l\r"]
[376.254374, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> class GibbsExcessLiquid:\r\n\u001b[?2004l\r\u001b[?2004h> "]
[376.25445, "o", "    # Existing code...\r\n\u001b[?2004l\r\u001b[?2004h"]
[376.25449, "o", "> \r\n\u001b[?2004l\r\u001b[?2004h> "]
[376.25458, "o", "    def to_TP_zs(self, T, P, zs):\r\n\u001b[?2004l\r\u001b[?2004h> "]
[376.25482, "o", "        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\r\n\u001b[?2004l\r\u001b[?2004h> "]
[376.255036, "o", "        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n\u001b[?2004l\r\u001b[?2004h> "]
[376.255079, "o", "\r\n\u001b[?2004l\r\u001b[?2004h> "]
[376.255192, "o", "    def to(self, zs, T=None, P=None, V=None):\r\n\u001b[?2004l\r\u001b[?2004h> "]
[376.255437, "o", "        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\r\n\u001b[?2004l\r\u001b[?2004h> "]
[376.255568, "o", "        T = T if T is not None else self.T\r\n\u001b[?2004l\r\u001b[?2004h"]
[376.255606, "o", "> "]
[376.255706, "o", "        P = P if P is not None else self.P\r\n\u001b[?2004l\r\u001b[?2004h> "]
[376.255881, "o", "        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n\u001b[?2004l\r\u001b[?2004h"]
[376.255929, "o", "> \r\n\u001b[?2004l\r\u001b[?2004h"]
[376.25598, "o", "> "]
[376.256036, "o", "class GibbsExcessSolid(GibbsExcessLiquid):\r\n\u001b[?2004l\r"]
[376.256079, "o", "\u001b[?2004h> "]
[376.256125, "o", "    ideal_gas_basis = True\r\n\u001b[?2004l\r"]
[376.256174, "o", "\u001b[?2004h> "]
[376.25622, "o", "    force_phase = 's'\r\n\u001b[?2004l\r\u001b[?2004h> "]
[376.256263, "o", "    phase = 's'\r\n\u001b[?2004l\r"]
[376.256305, "o", "\u001b[?2004h> "]
[376.25635, "o", "    is_gas = False\r\n\u001b[?2004l\r\u001b[?2004h> "]
[376.256414, "o", "    is_liquid = False\r\n\u001b[?2004l\r"]
[376.256464, "o", "\u001b[?2004h> "]
[376.256516, "o", "    is_solid = True\r\n\u001b[?2004l\r\u001b[?2004h"]
[376.256565, "o", "> "]
[376.256785, "o", "    pure_references = ('HeatCapacityGases', 'SublimationPressures', 'VolumeSolids', 'EnthalpySublimations')\r\n\u001b[?2004l\r"]
[376.256825, "o", "\u001b[?2004h> "]
[376.257062, "o", "    pure_reference_types = (HeatCapacityGas, SublimationPressure, VolumeSolid, EnthalpySublimation)\r\n\u001b[?2004l\r"]
[376.257103, "o", "\u001b[?2004h> "]
[376.257775, "o", "    model_attributes = ('Hfs', 'Gfs', 'Sfs', 'GibbsExcessModel', 'eos_pure_instances', 'use_Poynting', 'use_phis_sat', 'use_eos_volume', 'henry_components', 'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'Psat_extrpolation') + pure_references\r\n\u001b[?2004l\r"]
[376.257822, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[376.257866, "o", "\u001b[?2004h> "]
[376.258625, "o", "    def __init__(self, SublimationPressures, VolumeSolids=None, GibbsExcessModel=IdealSolution, eos_pure_instances=None, VolumeLiquidMixture=None, HeatCapacityGases=None, EnthalpySublimations=None, use_Poynting=False, use_phis_sat=False, Hfs=None, Gfs=None, Sfs=None, T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None):\r\n\u001b[?2004l\r\u001b[?2004h"]
[376.258648, "o", "> "]
[376.25927, "o", "        super().__init__(VaporPressures=SublimationPressures, VolumeLiquids=VolumeSolids, HeatCapacityGases=HeatCapacityGases, EnthalpyVaporizations=EnthalpySublimations, use_Poynting=use_Poynting, Hfs=Hfs, Gfs=Gfs, Sfs=Sfs, T=T, P=P, zs=zs)\r\n\u001b[?2004l\r"]
[376.259292, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[376.259368, "o", "\u001b[?2004h> "]
[376.259414, "o", "# Rest of the existing code...\r\n\u001b[?2004l\r\u001b[?2004h> "]
[376.259464, "o", "EOF\r\n\u001b[?2004l\r"]
[376.260999, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[376.691961, "i", "pytest tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi -v\n"]
[376.692251, "o", "pytest tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi -v\r\n\u001b[?2004l\r"]
[376.810136, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[376.811901, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[376.812012, "o", "\u001b[1mcollecting ... \u001b[0m"]
[377.398738, "o", "\u001b[1m\rcollecting 0 items / 2 errors                                                                                                                                  \u001b[0m\u001b[1m\rcollected 0 items / 2 errors                                                                                                                                   \u001b[0m\r\n"]
[377.399465, "o", "\r\n"]
[377.399527, "o", "============================================================================ ERRORS ============================================================================\r\n\u001b[31m\u001b[1m____________________________________________________________ ERROR collecting tests/test_phases.py _____________________________________________________________\u001b[0m\r\n\u001b[1m\u001b[31mtests/test_phases.py\u001b[0m:33: in <module>\r\n"]
[377.419758, "o", "    \u001b[0m\u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mthermo\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mimport\u001b[39;49;00m EXP_POLY_FIT\u001b[90m\u001b[39;49;00m\r\n\u001b[1m\u001b[31mthermo/__init__.py\u001b[0m:66: in <module>\r\n"]
[377.419846, "o", "    \u001b[0m\u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96m.\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mimport\u001b[39;49;00m (\u001b[90m\u001b[39;49;00m\r\n\u001b[1m\u001b[31mthermo/bulk.py\u001b[0m:82: in <module>\r\n"]
[377.419902, "o", "    \u001b[0m\u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mthermo\u001b[39;49;00m\u001b[04m\u001b[96m.\u001b[39;49;00m\u001b[04m\u001b[96mphases\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mimport\u001b[39;49;00m Phase\u001b[90m\u001b[39;49;00m\r\n\u001b[1m\u001b[31mthermo/phases/__init__.py\u001b[0m:180: in <module>\r\n"]
[377.420149, "o", "    \u001b[0m\u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mthermo\u001b[39;49;00m\u001b[04m\u001b[96m.\u001b[39;49;00m\u001b[04m\u001b[96mphases\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mimport\u001b[39;49;00m air_phase, ceos, combined, coolprop_phase, gibbs_excess, helmholtz_eos, iapws_phase, ideal_gas, petroleum, phase, virial_phase\u001b[90m\u001b[39;49;00m\r\n\u001b[1m\u001b[31mthermo/phases/gibbs_excess.py\u001b[0m:16: in <module>\r\n"]
[377.42022, "o", "    \u001b[0m\u001b[94mclass\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[92mGibbsExcessSolid\u001b[39;49;00m(GibbsExcessLiquid):\u001b[90m\u001b[39;49;00m\r\n\u001b[1m\u001b[31mthermo/phases/gibbs_excess.py\u001b[0m:24: in GibbsExcessSolid\r\n"]
[377.420359, "o", "    \u001b[0mpure_reference_types = (HeatCapacityGas, SublimationPressure, VolumeSolid, EnthalpySublimation)\u001b[90m\u001b[39;49;00m\r\n\u001b[1m\u001b[31mE   NameError: name 'HeatCapacityGas' is not defined\u001b[0m\r\n"]
[377.420411, "o", "\u001b[31m\u001b[1m____________________________________________________________ ERROR collecting tests/test_phases.py _____________________________________________________________\u001b[0m\r\n\u001b[1m\u001b[31mtests/test_phases.py\u001b[0m:33: in <module>\r\n"]
[377.420491, "o", "    \u001b[0m\u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mthermo\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mimport\u001b[39;49;00m EXP_POLY_FIT\u001b[90m\u001b[39;49;00m\r\n\u001b[1m\u001b[31mthermo/__init__.py\u001b[0m:66: in <module>\r\n"]
[377.42055, "o", "    \u001b[0m\u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96m.\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mimport\u001b[39;49;00m (\u001b[90m\u001b[39;49;00m\r\n\u001b[1m\u001b[31mthermo/bulk.py\u001b[0m:82: in <module>\r\n"]
[377.420606, "o", "    \u001b[0m\u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mthermo\u001b[39;49;00m\u001b[04m\u001b[96m.\u001b[39;49;00m\u001b[04m\u001b[96mphases\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mimport\u001b[39;49;00m Phase\u001b[90m\u001b[39;49;00m\r\n\u001b[1m\u001b[31mthermo/phases/__init__.py\u001b[0m:180: in <module>\r\n"]
[377.420849, "o", "    \u001b[0m\u001b[94mfrom\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[96mthermo\u001b[39;49;00m\u001b[04m\u001b[96m.\u001b[39;49;00m\u001b[04m\u001b[96mphases\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[94mimport\u001b[39;49;00m air_phase, ceos, combined, coolprop_phase, gibbs_excess, helmholtz_eos, iapws_phase, ideal_gas, petroleum, phase, virial_phase\u001b[90m\u001b[39;49;00m\r\n\u001b[1m\u001b[31mthermo/phases/gibbs_excess.py\u001b[0m:16: in <module>\r\n"]
[377.420915, "o", "    \u001b[0m\u001b[94mclass\u001b[39;49;00m\u001b[90m \u001b[39;49;00m\u001b[04m\u001b[92mGibbsExcessSolid\u001b[39;49;00m(GibbsExcessLiquid):\u001b[90m\u001b[39;49;00m\r\n\u001b[1m\u001b[31mthermo/phases/gibbs_excess.py\u001b[0m:24: in GibbsExcessSolid\r\n"]
[377.421051, "o", "    \u001b[0mpure_reference_types = (HeatCapacityGas, SublimationPressure, VolumeSolid, EnthalpySublimation)\u001b[90m\u001b[39;49;00m\r\n\u001b[1m\u001b[31mE   NameError: name 'HeatCapacityGas' is not defined\u001b[0m\r\n"]
[377.421226, "o", "\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_phases.py - NameError: name 'HeatCapacityGas' is not defined\r\n\u001b[31mERROR\u001b[0m tests/test_phases.py - NameError: name 'HeatCapacityGas' is not defined\r\n"]
[377.42129, "o", "\u001b[31m====================================================================== \u001b[31m\u001b[1m2 errors\u001b[0m\u001b[31m in 0.61s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[377.449357, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi\r\n\u001b[0m\r\n"]
[377.484142, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[446.66821, "i", "cat > thermo/phases/gibbs_excess.py << 'EOF'\nimport numpy as np\nfrom thermo.phases.phase import Phase\nfrom thermo.heat_capacity import HeatCapacityGas\nfrom thermo.vapor_pressure import SublimationPressure\nfrom thermo.volume import VolumeSolid\nfrom thermo.enthalpy import EnthalpySublimation\nfrom thermo.activity import IdealSolution\n\nclass GibbsExcessLiquid:\n    # Existing code...\n\n    def to_TP_zs(self, T, P, zs):\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\n\n    def to(self, zs, T=None, P=None, V=None):\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\n        T = T if T is not None else self.T\n        P = P if P is not None else self.P\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\n\nclass GibbsExcessSolid(GibbsExcessLiquid):\n    ideal_gas_basis = True\n    force_phase = 's'\n    phase = 's'\n    is_gas = False\n    is_liquid = False\n    is_solid = True\n    pure_references = ('HeatCapacityGases', 'SublimationPressures', 'VolumeSolids', 'EnthalpySublimations')\n    pure_reference_types = (HeatCapacityGas, SublimationPressure, VolumeSolid, EnthalpySublimation)\n    model_attributes = ('Hfs', 'Gfs', 'Sfs', 'GibbsExcessModel', 'eos_pure_instances', 'use_Poynting', 'use_phis_sat', 'use_eos_volume', 'henry_components', 'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'Psat_extrpolation') + pure_references\n\n    def __init__(self, SublimationPressures, VolumeSolids=None, GibbsExcessModel=IdealSolution, eos_pure_instances=None, VolumeLiquidMixture=None, HeatCapacityGases=None, EnthalpySublimations=None, use_Poynting=False, use_phis_sat=False, Hfs=None, Gfs=None, Sfs=None, T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None):\n        super().__init__(VaporPressures=SublimationPressures, VolumeLiquids=VolumeSolids, HeatCapacityGases=HeatCapacityGases, EnthalpyVaporizations=EnthalpySublimations, use_Poynting=use_Poynting, Hfs=Hfs, Gfs=Gfs, Sfs=Sfs, T=T, P=P, zs=zs)\n\n# Rest of the existing code...\nEOF\n"]
[446.668804, "o", "cat > thermo/phases/gibbs_excess.py << 'EOF'\r\n\u001b[?2004l\r"]
[446.668891, "o", "\u001b[?2004h> "]
[446.66901, "o", "import numpy as np\r\n\u001b[?2004l\r"]
[446.669155, "o", "\u001b[?2004h> "]
[446.669337, "o", "from thermo.phases.phase import Phase\r\n\u001b[?2004l\r"]
[446.669413, "o", "\u001b[?2004h> "]
[446.669699, "o", "from thermo.heat_capacity import HeatCapacityGas\r\n\u001b[?2004l\r"]
[446.66977, "o", "\u001b[?2004h> "]
[446.6701, "o", "from thermo.vapor_pressure import SublimationPressure\r\n\u001b[?2004l\r"]
[446.670171, "o", "\u001b[?2004h> "]
[446.670383, "o", "from thermo.volume import VolumeSolid\r\n\u001b[?2004l\r"]
[446.670455, "o", "\u001b[?2004h> "]
[446.670743, "o", "from thermo.enthalpy import EnthalpySublimation\r\n\u001b[?2004l\r"]
[446.670811, "o", "\u001b[?2004h> "]
[446.67106, "o", "from thermo.activity import IdealSolution\r\n\u001b[?2004l\r"]
[446.67114, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h"]
[446.67121, "o", "> "]
[446.671326, "o", "class GibbsExcessLiquid:\r\n\u001b[?2004l\r"]
[446.671407, "o", "\u001b[?2004h> "]
[446.671521, "o", "    # Existing code...\r\n\u001b[?2004l\r"]
[446.67159, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h"]
[446.671655, "o", "> "]
[446.671847, "o", "    def to_TP_zs(self, T, P, zs):\r\n\u001b[?2004l\r"]
[446.671909, "o", "\u001b[?2004h> "]
[446.67247, "o", "        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\r\n\u001b[?2004l\r"]
[446.67254, "o", "\u001b[?2004h> "]
[446.67297, "o", "        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n\u001b[?2004l\r"]
[446.673051, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> "]
[446.673366, "o", "    def to(self, zs, T=None, P=None, V=None):\r\n\u001b[?2004l\r"]
[446.673431, "o", "\u001b[?2004h> "]
[446.673979, "o", "        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\r\n\u001b[?2004l\r"]
[446.674058, "o", "\u001b[?2004h> "]
[446.674307, "o", "        T = T if T is not None else self.T\r\n\u001b[?2004l\r"]
[446.67437, "o", "\u001b[?2004h> "]
[446.674637, "o", "        P = P if P is not None else self.P\r\n\u001b[?2004l\r"]
[446.674699, "o", "\u001b[?2004h> "]
[446.675133, "o", "        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n\u001b[?2004l\r"]
[446.675202, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[446.675268, "o", "\u001b[?2004h> "]
[446.675519, "o", "class GibbsExcessSolid(GibbsExcessLiquid):\r\n\u001b[?2004l\r"]
[446.675581, "o", "\u001b[?2004h> "]
[446.675736, "o", "    ideal_gas_basis = True\r\n\u001b[?2004l\r"]
[446.675799, "o", "\u001b[?2004h> "]
[446.675937, "o", "    force_phase = 's'\r\n\u001b[?2004l\r"]
[446.676005, "o", "\u001b[?2004h> "]
[446.676104, "o", "    phase = 's'\r\n\u001b[?2004l\r"]
[446.676164, "o", "\u001b[?2004h> "]
[446.676274, "o", "    is_gas = False\r\n\u001b[?2004l\r"]
[446.676334, "o", "\u001b[?2004h> "]
[446.676459, "o", "    is_liquid = False\r\n\u001b[?2004l\r"]
[446.676519, "o", "\u001b[?2004h> "]
[446.676645, "o", "    is_solid = True\r\n\u001b[?2004l\r"]
[446.676705, "o", "\u001b[?2004h> "]
[446.677376, "o", "    pure_references = ('HeatCapacityGases', 'SublimationPressures', 'VolumeSolids', 'EnthalpySublimations')\r\n\u001b[?2004l\r"]
[446.677444, "o", "\u001b[?2004h> "]
[446.678076, "o", "    pure_reference_types = (HeatCapacityGas, SublimationPressure, VolumeSolid, EnthalpySublimation)\r\n\u001b[?2004l\r"]
[446.67814, "o", "\u001b[?2004h> "]
[446.679803, "o", "    model_attributes = ('Hfs', 'Gfs', 'Sfs', 'GibbsExcessModel', 'eos_pure_instances', 'use_Poynting', 'use_phis_sat', 'use_eos_volume', 'henry_components', 'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'Psat_extrpolation') + pure_references\r\n\u001b[?2004l\r"]
[446.679866, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h"]
[446.67993, "o", "> "]
[446.68196, "o", "    def __init__(self, SublimationPressures, VolumeSolids=None, GibbsExcessModel=IdealSolution, eos_pure_instances=None, VolumeLiquidMixture=None, HeatCapacityGases=None, EnthalpySublimations=None, use_Poynting=False, use_phis_sat=False, Hfs=None, Gfs=None, Sfs=None, T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None):\r\n\u001b[?2004l\r"]
[446.682042, "o", "\u001b[?2004h> "]
[446.683558, "o", "        super().__init__(VaporPressures=SublimationPressures, VolumeLiquids=VolumeSolids, HeatCapacityGases=HeatCapacityGases, EnthalpyVaporizations=EnthalpySublimations, use_Poynting=use_Poynting, Hfs=Hfs, Gfs=Gfs, Sfs=Sfs, T=T, P=P, zs=zs)\r\n\u001b[?2004l\r"]
[446.683627, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[446.683699, "o", "\u001b[?2004h> "]
[446.683896, "o", "# Rest of the existing code...\r\n\u001b[?2004l\r"]
[446.683971, "o", "\u001b[?2004h> EOF\r\n\u001b[?2004l\r"]
[446.686395, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[447.021987, "i", "pytest tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi -v\n"]
[447.022772, "o", "pytest tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi -v\r\n\u001b[?2004l\r"]
[447.147391, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[447.149104, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n\u001b[1mcollecting ... \u001b[0m"]
[447.651198, "o", "\u001b[1m\rcollecting 0 items / 1 error                                                                                                                                   \u001b[0m"]
[447.755648, "o", "\u001b[1m\rcollected 0 items / 2 errors                                                                                                                                   \u001b[0m\r\n"]
[447.756372, "o", "\r\n============================================================================ ERRORS ============================================================================\r\n"]
[447.756444, "o", "\u001b[31m\u001b[1m____________________________________________________________ ERROR collecting tests/test_phases.py _____________________________________________________________\u001b[0m\r\n\u001b[31mImportError while importing test module '/workspace/repo/tests/test_phases.py'.\r\nHint: make sure your test modules/packages have valid Python names.\r\nTraceback:\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\ntests/test_phases.py:33: in <module>\r\n    from thermo import EXP_POLY_FIT\r\nthermo/__init__.py:66: in <module>\r\n    from . import (\r\nthermo/bulk.py:82: in <module>\r\n    from thermo.phases import Phase\r\nthermo/phases/__init__.py:180: in <module>\r\n    from thermo.phases import air_phase, ceos, combined, coolprop_phase, gibbs_excess, helmholtz_eos, iapws_phase, ideal_gas, petroleum, phase, virial_phase\r\nthermo/phases/gibbs_excess.py:6: in <module>\r\n    from thermo.enthalpy import EnthalpySublimation\r\nE   ModuleNotFoundError: No module named 'thermo.enthalpy'\u001b[0m\r\n\u001b[31m\u001b[1m____________________________________________________________ ERROR collecting tests/test_phases.py _____________________________________________________________\u001b[0m\r\n\u001b[31mImportError while importing test module '/workspace/repo/tests/test_phases.py'.\r\nHint: make sure your test modules/packages have valid Python names.\r\nTraceback:\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\ntests/test_phases.py:33: in <module>\r\n    from thermo import EXP_POLY_FIT\r\nthermo/__init__.py:66: in <module>\r\n    from . import (\r\nthermo/bulk.py:82: in <module>\r\n    from thermo.phases import Phase\r\nthermo/phases/__init__.py:180: in <module>\r\n    from thermo.phases import air_phase, ceos, combined, coolprop_phase, gibbs_excess, helmholtz_eos, iapws_phase, ideal_gas, petroleum, phase, virial_phase\r\nthermo/phases/gibbs_excess.py:6: in <module>\r\n    from thermo.enthalpy import EnthalpySublimation\r\nE   ModuleNotFoundError: No module named 'thermo.enthalpy'\u001b[0m"]
[447.756583, "o", "\r\n\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_phases.py\r\n\u001b[31mERROR\u001b[0m tests/test_phases.py\r\n"]
[447.75672, "o", "\u001b[31m====================================================================== \u001b[31m\u001b[1m2 errors\u001b[0m\u001b[31m in 0.61s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[447.782838, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi\r\n\u001b[0m\r\n"]
[447.813545, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[542.787277, "i", "cat > thermo/phases/gibbs_excess.py << 'EOF'\nimport numpy as np\nfrom thermo.phases.phase import Phase\nfrom thermo.heat_capacity import HeatCapacityGas\nfrom thermo.vapor_pressure import VaporPressure as SublimationPressure\nfrom thermo.volume import VolumeLiquid as VolumeSolid\nfrom thermo.enthalpy import EnthalpyVaporization as EnthalpySublimation\nfrom thermo.activity import IdealSolution\n\nclass GibbsExcessLiquid:\n    # Existing code...\n\n    def to_TP_zs(self, T, P, zs):\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\n\n    def to(self, zs, T=None, P=None, V=None):\n        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\n        T = T if T is not None else self.T\n        P = P if P is not None else self.P\n        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\n\nclass GibbsExcessSolid(GibbsExcessLiquid):\n    ideal_gas_basis = True\n    force_phase = 's'\n    phase = 's'\n    is_gas = False\n    is_liquid = False\n    is_solid = True\n    pure_references = ('HeatCapacityGases', 'SublimationPressures', 'VolumeSolids', 'EnthalpySublimations')\n    pure_reference_types = (HeatCapacityGas, SublimationPressure, VolumeSolid, EnthalpySublimation)\n    model_attributes = ('Hfs', 'Gfs', 'Sfs', 'GibbsExcessModel', 'eos_pure_instances', 'use_Poynting', 'use_phis_sat', 'use_eos_volume', 'henry_components', 'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'Psat_extrpolation') + pure_references\n\n    def __init__(self, SublimationPressures, VolumeSolids=None, GibbsExcessModel=IdealSolution, eos_pure_instances=None, VolumeLiquidMixture=None, HeatCapacityGases=None, EnthalpySublimations=None, use_Poynting=False, use_phis_sat=False, Hfs=None, Gfs=None, Sfs=None, T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None):\n        super().__init__(VaporPressures=SublimationPressures, VolumeLiquids=VolumeSolids, HeatCapacityGases=HeatCapacityGases, EnthalpyVaporizations=EnthalpySublimations, use_Poynting=use_Poynting, Hfs=Hfs, Gfs=Gfs, Sfs=Sfs, T=T, P=P, zs=zs)\n\n# Rest of the existing code...\nEOF\n"]
[542.788083, "o", "cat > thermo/phases/gibbs_excess.py << 'EOF'\r\n\u001b[?2004l\r"]
[542.788228, "o", "\u001b[?2004h> "]
[542.788347, "o", "import numpy as np\r\n\u001b[?2004l\r\u001b[?2004h> "]
[542.788637, "o", "from thermo.phases.phase import Phase\r\n\u001b[?2004l\r\u001b[?2004h"]
[542.788772, "o", "> "]
[542.789072, "o", "from thermo.heat_capacity import HeatCapacityGas\r\n\u001b[?2004l\r\u001b[?2004h> "]
[542.789632, "o", "from thermo.vapor_pressure import VaporPressure as SublimationPressure\r\n\u001b[?2004l\r"]
[542.789733, "o", "\u001b[?2004h> "]
[542.790118, "o", "from thermo.volume import VolumeLiquid as VolumeSolid\r\n\u001b[?2004l\r\u001b[?2004h> "]
[542.790685, "o", "from thermo.enthalpy import EnthalpyVaporization as EnthalpySublimation\r\n\u001b[?2004l\r\u001b[?2004h> "]
[542.791058, "o", "from thermo.activity import IdealSolution\r\n\u001b[?2004l\r\u001b[?2004h"]
[542.791188, "o", "> \r\n\u001b[?2004l\r\u001b[?2004h> "]
[542.791341, "o", "class GibbsExcessLiquid:\r\n\u001b[?2004l\r\u001b[?2004h"]
[542.791426, "o", "> "]
[542.791609, "o", "    # Existing code...\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r"]
[542.791669, "o", "\u001b[?2004h> "]
[542.791942, "o", "    def to_TP_zs(self, T, P, zs):\r\n\u001b[?2004l\r\u001b[?2004h"]
[542.792083, "o", "> "]
[542.792699, "o", "        \"\"\"Return a new instance of GibbsExcessLiquid at the specified T, P, and zs.\"\"\"\r\n\u001b[?2004l\r\u001b[?2004h"]
[542.792823, "o", "> "]
[542.793382, "o", "        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n\u001b[?2004l\r"]
[542.793519, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> "]
[542.793848, "o", "    def to(self, zs, T=None, P=None, V=None):\r\n\u001b[?2004l\r\u001b[?2004h"]
[542.793969, "o", "> "]
[542.794595, "o", "        \"\"\"Return a new instance of GibbsExcessLiquid at the specified zs, T, P, or V.\"\"\"\r\n\u001b[?2004l\r\u001b[?2004h> "]
[542.794961, "o", "        T = T if T is not None else self.T\r\n\u001b[?2004l\r\u001b[?2004h"]
[542.795097, "o", "> "]
[542.795336, "o", "        P = P if P is not None else self.P\r\n\u001b[?2004l\r\u001b[?2004h"]
[542.795434, "o", "> "]
[542.795926, "o", "        return GibbsExcessLiquid(T=T, P=P, zs=zs, **self.constants())\r\n\u001b[?2004l\r\u001b[?2004h"]
[542.79606, "o", "> \r\n\u001b[?2004l\r\u001b[?2004h> "]
[542.796374, "o", "class GibbsExcessSolid(GibbsExcessLiquid):\r\n\u001b[?2004l\r\u001b[?2004h> "]
[542.796617, "o", "    ideal_gas_basis = True\r\n\u001b[?2004l\r\u001b[?2004h"]
[542.796736, "o", "> "]
[542.796847, "o", "    force_phase = 's'\r\n\u001b[?2004l\r\u001b[?2004h> "]
[542.796998, "o", "    phase = 's'\r\n\u001b[?2004l\r\u001b[?2004h"]
[542.797123, "o", "> "]
[542.797227, "o", "    is_gas = False\r\n\u001b[?2004l\r\u001b[?2004h> "]
[542.79741, "o", "    is_liquid = False\r\n\u001b[?2004l\r"]
[542.797466, "o", "\u001b[?2004h> "]
[542.797635, "o", "    is_solid = True\r\n\u001b[?2004l\r\u001b[?2004h"]
[542.797744, "o", "> "]
[542.798517, "o", "    pure_references = ('HeatCapacityGases', 'SublimationPressures', 'VolumeSolids', 'EnthalpySublimations')\r\n\u001b[?2004l\r\u001b[?2004h> "]
[542.799356, "o", "    pure_reference_types = (HeatCapacityGas, SublimationPressure, VolumeSolid, EnthalpySublimation)\r\n\u001b[?2004l\r"]
[542.799462, "o", "\u001b[?2004h> "]
[542.801489, "o", "    model_attributes = ('Hfs', 'Gfs', 'Sfs', 'GibbsExcessModel', 'eos_pure_instances', 'use_Poynting', 'use_phis_sat', 'use_eos_volume', 'henry_components', 'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'Psat_extrpolation') + pure_references\r\n\u001b[?2004l\r\u001b[?2004h"]
[542.801661, "o", "> \r\n\u001b[?2004l\r\u001b[?2004h> "]
[542.803897, "o", "    def __init__(self, SublimationPressures, VolumeSolids=None, GibbsExcessModel=IdealSolution, eos_pure_instances=None, VolumeLiquidMixture=None, HeatCapacityGases=None, EnthalpySublimations=None, use_Poynting=False, use_phis_sat=False, Hfs=None, Gfs=None, Sfs=None, T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None):\r\n\u001b[?2004l\r\u001b[?2004h"]
[542.80405, "o", "> "]
[542.805731, "o", "        super().__init__(VaporPressures=SublimationPressures, VolumeLiquids=VolumeSolids, HeatCapacityGases=HeatCapacityGases, EnthalpyVaporizations=EnthalpySublimations, use_Poynting=use_Poynting, Hfs=Hfs, Gfs=Gfs, Sfs=Sfs, T=T, P=P, zs=zs)\r\n\u001b[?2004l\r"]
[542.805842, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h"]
[542.805932, "o", "> "]
[542.806166, "o", "# Rest of the existing code...\r\n\u001b[?2004l\r"]
[542.806221, "o", "\u001b[?2004h> EOF\r\n"]
[542.806334, "o", "\u001b[?2004l\r"]
[542.809424, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
[543.189984, "i", "pytest tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi -v\n"]
[543.19044, "o", "pytest tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi -v\r\n\u001b[?2004l\r"]
[543.312987, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\nplatform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10\r\n"]
[543.314719, "o", "cachedir: .pytest_cache\r\nrootdir: /workspace/repo\r\nconfigfile: pyproject.toml\r\nplugins: mock-3.15.1, timeout-2.4.0\r\n"]
[543.314782, "o", "\u001b[1mcollecting ... \u001b[0m"]
[543.900842, "o", "\u001b[1m\rcollecting 0 items / 2 errors                                                                                                                                  \u001b[0m\u001b[1m\rcollected 0 items / 2 errors                                                                                                                                   \u001b[0m\r\n"]
[543.901393, "o", "\r\n============================================================================ ERRORS ============================================================================\r\n"]
[543.901495, "o", "\u001b[31m\u001b[1m____________________________________________________________ ERROR collecting tests/test_phases.py _____________________________________________________________\u001b[0m\r\n\u001b[31mImportError while importing test module '/workspace/repo/tests/test_phases.py'.\r\nHint: make sure your test modules/packages have valid Python names.\r\nTraceback:\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\ntests/test_phases.py:33: in <module>\r\n    from thermo import EXP_POLY_FIT\r\nthermo/__init__.py:66: in <module>\r\n    from . import (\r\nthermo/bulk.py:82: in <module>\r\n    from thermo.phases import Phase\r\nthermo/phases/__init__.py:180: in <module>\r\n    from thermo.phases import air_phase, ceos, combined, coolprop_phase, gibbs_excess, helmholtz_eos, iapws_phase, ideal_gas, petroleum, phase, virial_phase\r\nthermo/phases/gibbs_excess.py:6: in <module>\r\n    from thermo.enthalpy import EnthalpyVaporization as EnthalpySublimation\r\nE   ModuleNotFoundError: No module named 'thermo.enthalpy'\u001b[0m\r\n\u001b[31m\u001b[1m____________________________________________________________ ERROR collecting tests/test_phases.py _____________________________________________________________\u001b[0m\r\n\u001b[31mImportError while importing test module '/workspace/repo/tests/test_phases.py'.\r\nHint: make sure your test modules/packages have valid Python names.\r\nTraceback:\r\n/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\ntests/test_phases.py:33: in <module>\r\n    from thermo import EXP_POLY_FIT\r\nthermo/__init__.py:66: in <module>\r\n    from . import (\r\nthermo/bulk.py:82: in <module>\r\n    from thermo.phases import Phase\r\nthermo/phases/__init__.py:180: in <module>\r\n    from thermo.phases import air_phase, ceos, combined, coolprop_phase, gibbs_excess, helmholtz_eos, iapws_phase, ideal_gas, petroleum, phase, virial_phase\r\nthermo/phases/gibbs_excess.py:6: in <module>\r\n    from thermo.enthalpy import EnthalpyVaporization as EnthalpySublimation\r\nE   ModuleNotFoundError: No module named 'thermo.enthalpy'\u001b[0m\r\n"]
[543.901618, "o", "\u001b[36m\u001b[1m=================================================================== short test summary info ====================================================================\u001b[0m\r\n\u001b[31mERROR\u001b[0m tests/test_phases.py\r\n\u001b[31mERROR\u001b[0m tests/test_phases.py\r\n"]
[543.901701, "o", "\u001b[31m====================================================================== \u001b[31m\u001b[1m2 errors\u001b[0m\u001b[31m in 0.59s\u001b[0m\u001b[31m =======================================================================\u001b[0m\r\n"]
[543.928146, "o", "\u001b[31mERROR: found no collectors for /workspace/repo/tests/test_phases.py::test_GibbbsExcessLiquid_NoPoyNoGammaNoPhi\r\n\u001b[0m\r\n"]
[543.961729, "o", "\u001b[?2004hroot@d190e0e5-9523-4919-8e70-a6d0f62e1f29:/workspace/repo# "]
