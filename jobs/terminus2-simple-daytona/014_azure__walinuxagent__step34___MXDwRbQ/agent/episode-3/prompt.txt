Previous response had warnings:
WARNINGS: - Extra text detected before JSON object
- Extra text detected after JSON object

New Terminal Output:

root@f6d8e0b1-4f5c-4c17-9e06-81a7d6755cd4:/workspace/repo/azurelinuxagent/common/utils# cat restutil.py
import os
import threading
import time
import socket
import struct
import azurelinuxagent.common.conf as conf
import azurelinuxagent.common.logger as logger
import azurelinuxagent.common.utils.textutil as textutil
from azurelinuxagent.common.exception import HttpError, ResourceGoneError, InvalidContainerError
from azurelinuxagent.common.future import httpclient, urlparse, ustr
from azurelinuxagent.common.version import PY_VERSION_MAJOR, AGENT_NAME, GOAL_STATE_AGENT_VERSION
SECURE_WARNING_EMITTED = False
DEFAULT_RETRIES = 6
DELAY_IN_SECONDS = 1
THROTTLE_RETRIES = 25
THROTTLE_DELAY_IN_SECONDS = 1
TELEMETRY_THROTTLE_DELAY_IN_SECONDS = 8
TELEMETRY_FLUSH_THROTTLE_DELAY_IN_SECONDS = 2
RETRY_CODES = [httpclient.RESET_CONTENT, httpclient.PARTIAL_CONTENT, httpclient.FORBIDDEN, httpclient.INTERNAL_SERVER_ERROR, httpclient.NOT_IMPLEMENTED, httpcli
ent.BAD_GATEWAY, httpclient.SERVICE_UNAVAILABLE, httpclient.GATEWAY_TIMEOUT, httpclient.INSUFFICIENT_STORAGE, 429]
HGAP_GET_EXTENSION_ARTIFACT_RETRY_CODES = RETRY_CODES[:]
HGAP_GET_EXTENSION_ARTIFACT_RETRY_CODES.append(httpclient.BAD_REQUEST)
RESOURCE_GONE_CODES = [httpclient.GONE]
OK_CODES = [httpclient.OK, httpclient.CREATED, httpclient.ACCEPTED]
NOT_MODIFIED_CODES = [httpclient.NOT_MODIFIED]
HOSTPLUGIN_UPSTREAM_FAILURE_CODES = [502]
THROTTLE_CODES = [httpclient.FORBIDDEN, httpclient.SERVICE_UNAVAILABLE, 429]
RETRY_EXCEPTIONS = [httpclient.NotConnected, httpclient.IncompleteRead, httpclient.ImproperConnectionState, httpclient.BadStatusLine]
HTTP_PROXY_ENV = 'http_proxy'
HTTPS_PROXY_ENV = 'https_proxy'
NO_PROXY_ENV = 'no_proxy'
HTTP_USER_AGENT = '{0}/{1}'.format(AGENT_NAME, GOAL_STATE_AGENT_VERSION)
HTTP_USER_AGENT_HEALTH = '{0}+health'.format(HTTP_USER_AGENT)
INVALID_CONTAINER_CONFIGURATION = 'InvalidContainerConfiguration'
REQUEST_ROLE_CONFIG_FILE_NOT_FOUND = 'RequestRoleConfigFileNotFound'
KNOWN_WIRESERVER_IP = '168.63.129.16'
HOST_PLUGIN_PORT = 32526
TELEMETRY_DATA = 'telemetrydata'

class IOErrorCounter(object):
    _lock = threading.RLock()
    _protocol_endpoint = KNOWN_WIRESERVER_IP
    _counts = {'hostplugin': 0, 'protocol': 0, 'other': 0}

    @staticmethod
    def increment(host=None, port=None):
        with IOErrorCounter._lock:
            if host == IOErrorCounter._protocol_endpoint:
                if port == HOST_PLUGIN_PORT:
                    IOErrorCounter._counts['hostplugin'] += 1
                else:
                    IOErrorCounter._counts['protocol'] += 1
            else:
                IOErrorCounter._counts['other'] += 1

    @staticmethod
    def get_and_reset():
        with IOErrorCounter._lock:
            counts = IOErrorCounter._counts.copy()
            IOErrorCounter.reset()
            return counts

    @staticmethod
    def reset():
        with IOErrorCounter._lock:
            IOErrorCounter._counts = {'hostplugin': 0, 'protocol': 0, 'other': 0}

    @staticmethod
    def set_protocol_endpoint(endpoint=KNOWN_WIRESERVER_IP):
        IOErrorCounter._protocol_endpoint = endpoint

def _compute_delay(retry_attempt=1, delay=DELAY_IN_SECONDS):
    fib = (1, 1)
    for _ in range(retry_attempt):
        fib = (fib[1], fib[0] + fib[1])
    return delay * fib[1]

def _is_retry_status(status, retry_codes=None):
    if retry_codes is None:
        retry_codes = RETRY_CODES
    return status in retry_codes

def _is_retry_exception(e):
    return len([x for x in RETRY_EXCEPTIONS if isinstance(e, x)]) > 0

def _is_throttle_status(status):
    return status in THROTTLE_CODES

def _is_telemetry_req(url):
    if TELEMETRY_DATA in url:
        return True
    return False

def _parse_url(url):
    """
    Parse URL to get the components of the URL broken down to host, port
    :rtype: string, int, bool, string
    """
    o = urlparse(url)
    rel_uri = o.path
    if o.fragment:
        rel_uri = '{0}#{1}'.format(rel_uri, o.fragment)
    if o.query:
        rel_uri = '{0}?{1}'.format(rel_uri, o.query)
    secure = False
    if o.scheme.lower() == 'https':
        secure = True
    return (o.hostname, o.port, secure, rel_uri)

def _trim_url_parameters(url):
    """
    Parse URL and return scheme://hostname:port/path
    """
    o = urlparse(url)
    if o.hostname:
        if o.port:
            return '{0}://{1}:{2}{3}'.format(o.scheme, o.hostname, o.port, o.path)
        else:
            return '{0}://{1}{2}'.format(o.scheme, o.hostname, o.path)
    return url

def is_valid_cidr(string_network):
    """
    Very simple check of the cidr format in no_proxy variable.
    :rtype: bool
    """
    if string_network.count('/') == 1:
        try:
            mask = int(string_network.split('/')[1])
        except ValueError:
            return False
        if mask < 1 or mask > 32:
            return False
        try:
            socket.inet_aton(string_network.split('/')[0])
        except socket.error:
            return Fa
[... output limited to 10000 bytes; 70 interior bytes omitted ...]
ON in response_error:
                    raise InvalidContainerError(response_error)
            return resp
        except httpclient.HTTPException as e:
            if return_raw_response:
                raise
            clean_url = _trim_url_parameters(url)
            msg = '[HTTP Failed] {0} {1} -- HttpException {2}'.format(method, clean_url, e)
            if _is_retry_exception(e):
                continue
            break
        except IOError as e:
            if return_raw_response:
                raise
            IOErrorCounter.increment(host=host, port=port)
            clean_url = _trim_url_parameters(url)
            msg = '[HTTP Failed] {0} {1} -- IOError {2}'.format(method, clean_url, e)
            continue
    raise HttpError('{0} -- {1} attempts made'.format(msg, attempt))

def http_get(url, headers=None, use_proxy=False, max_retry=None, retry_codes=None, retry_delay=DELAY_IN_SECONDS, return_raw_response=False, timeout=10):
    """
    NOTE: This method provides some logic to handle errors in the HTTP request, including checking the HTTP status of the response
          and handling some exceptions. If return_raw_response is set to True all the error handling will be skipped and the
          method will return the actual HTTP response and bubble up any exceptions while issuing the request. Also note that if
          return_raw_response is True no retries will be done.
    """
    if max_retry is None:
        max_retry = DEFAULT_RETRIES
    if retry_codes is None:
        retry_codes = RETRY_CODES
    return http_request('GET', url, None, timeout, headers=headers, use_proxy=use_proxy, max_retry=max_retry, retry_codes=retry_codes, retry_delay=retry_delay,
return_raw_response=return_raw_response)

def http_head(url, headers=None, use_proxy=False, max_retry=None, retry_codes=None, retry_delay=DELAY_IN_SECONDS, timeout=10):
    if max_retry is None:
        max_retry = DEFAULT_RETRIES
    if retry_codes is None:
        retry_codes = RETRY_CODES
    return http_request('HEAD', url, None, timeout, headers=headers, use_proxy=use_proxy, max_retry=max_retry, retry_codes=retry_codes, retry_delay=retry_delay)

def http_post(url, data, headers=None, use_proxy=False, max_retry=None, retry_codes=None, retry_delay=DELAY_IN_SECONDS, throttle_delay=THROTTLE_DELAY_IN_SECONDS
, timeout=10):
    if max_retry is None:
        max_retry = DEFAULT_RETRIES
    if retry_codes is None:
        retry_codes = RETRY_CODES
    return http_request('POST', url, data, timeout, headers=headers, use_proxy=use_proxy, max_retry=max_retry, retry_codes=retry_codes, retry_delay=retry_delay,
 throttle_delay=throttle_delay)

def http_put(url, data, headers=None, use_proxy=False, max_retry=None, retry_codes=None, retry_delay=DELAY_IN_SECONDS, redact_data=False, timeout=10):
    if max_retry is None:
        max_retry = DEFAULT_RETRIES
    if retry_codes is None:
        retry_codes = RETRY_CODES
    return http_request('PUT', url, data, timeout, headers=headers, use_proxy=use_proxy, max_retry=max_retry, retry_codes=retry_codes, retry_delay=retry_delay,
redact_data=redact_data)

def http_delete(url, headers=None, use_proxy=False, max_retry=None, retry_codes=None, retry_delay=DELAY_IN_SECONDS, timeout=10):
    if max_retry is None:
        max_retry = DEFAULT_RETRIES
    if retry_codes is None:
        retry_codes = RETRY_CODES
    return http_request('DELETE', url, None, timeout, headers=headers, use_proxy=use_proxy, max_retry=max_retry, retry_codes=retry_codes, retry_delay=retry_dela
y)

def request_failed(resp, ok_codes=None):
    if ok_codes is None:
        ok_codes = OK_CODES
    return not request_succeeded(resp, ok_codes=ok_codes)

def request_succeeded(resp, ok_codes=None):
    if ok_codes is None:
        ok_codes = OK_CODES
    return resp is not None and resp.status in ok_codes

def request_not_modified(resp):
    return resp is not None and resp.status in NOT_MODIFIED_CODES

def request_failed_at_hostplugin(resp, upstream_failure_codes=None):
    """
    Host plugin will return 502 for any upstream issue, so a failure is any 5xx except 502
    """
    if upstream_failure_codes is None:
        upstream_failure_codes = HOSTPLUGIN_UPSTREAM_FAILURE_CODES
    return resp is not None and resp.status >= 500 and (resp.status not in upstream_failure_codes)

def read_response_error(resp):
    result = ''
    if resp is not None:
        try:
            result = '[HTTP Failed] [{0}: {1}] {2}'.format(resp.status, resp.reason, resp.read())
            if PY_VERSION_MAJOR < 3:
                result = ustr(result, encoding='ascii', errors='ignore')
            else:
                result = result.encode(encoding='ascii', errors='ignore').decode(encoding='ascii', errors='ignore')
            result = textutil.replace_non_ascii(result)
        except Exception as e:
            logger.warn(textutil.format_exception(e))
    return resultroot@f6d8e0b1-4f5c-4c17-9e06-81a7d6755cd4:/workspace/repo/azurelinuxagent/common/utils#
