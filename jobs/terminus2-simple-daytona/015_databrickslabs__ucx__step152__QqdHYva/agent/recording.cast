{"version": 2, "width": 160, "height": 40, "timestamp": 1770669311, "env": {"SHELL": "/bin/bash", "TERM": "tmux-256color"}}
[0.003657, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo# "]
[0.949888, "i", "clear\r"]
[0.950058, "o", "clear\r\n\u001b[?2004l\r"]
[0.95107, "o", "\u001b[H\u001b[J\u001b[3J"]
[0.951232, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo# "]
[7.381834, "i", "cd src/databricks/labs/ucx/azure/\n"]
[7.382023, "o", "cd src/databricks/labs/ucx/azure/\r\n\u001b[?2004l\r"]
[7.382162, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/src/databricks/labs/ucx/azure# "]
[7.820101, "i", "vi resources.py\n"]
[7.82026, "o", "vi resources.py\r\n\u001b[?2004l\r"]
[7.82062, "o", "bash: vi: command not found\r\n"]
[7.820855, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/src/databricks/labs/ucx/azure# "]
[11.298121, "i", "nano resources.py\n"]
[11.29828, "o", "nano resources.py\r\n\u001b[?2004l\r"]
[11.298629, "o", "bash: nano: command not found\r\n"]
[11.298866, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/src/databricks/labs/ucx/azure# "]
[15.820681, "i", "cat resources.py\n"]
[15.820847, "o", "cat resources.py\r\n\u001b[?2004l\r"]
[15.821847, "o", "import urllib.parse\r\nimport time\r\nfrom collections.abc import Iterable\r\nfrom dataclasses import dataclass, field\r\nfrom datetime import timedelta\r\nfrom typing import Any\r\nfrom databricks.sdk.core import ApiClient, AzureCliTokenSource, Config, CredentialsProvider, CredentialsStrategy, credentials_strategy\r\nfrom databricks.sdk.errors import NotFound, PermissionDenied, ResourceConflict\r\nfrom databricks.sdk.retries import retried\r\nfrom databricks.labs.ucx.assessment.crawlers import logger\r\n_ROLES = {'STORAGE_BLOB_DATA_READER': '2a2b9908-6ea1-4ae2-8e65-a410df84e7d1', 'STORAGE_BLOB_DATA_CONTRIBUTOR': 'ba92f5b4-2d11-453d-a403-e96b0029c9fe'}\r\n\r\n@dataclass\r\nclass AzureSubscription:\r\n    name: str\r\n    subscription_id: str\r\n    tenant_id: str\r\n\r\nclass AzureResource:\r\n\r\n    def __init__(self, resource_id: str):\r\n        self._pairs = {}\r\n        self._resource_id = resource_id\r\n        split = resource_id.lstrip('/').split('/')\r\n        if len(split) % 2 != 0:\r\n            msg = f'not a list of pairs: {resource_id}'\r\n            raise ValueError(msg)\r\n        i = 0\r\n        while i < len(split):\r\n            k = split[i]\r\n            value = split[i + 1]\r\n            i += 2\r\n            self._pairs[k] = value\r\n\r\n    @property\r\n    def subscription_id(self):\r\n        return self._pairs.get('subscriptions')\r\n\r\n    @property\r\n    def resource_group(self):\r\n        return self._pairs.get('resourceGroups')\r\n\r\n    @property\r\n    def storage_account(self):\r\n        return self._pairs.get('storageAccounts')\r\n\r\n    @property\r\n    def container(self):\r\n        return self._pairs.get('containers')\r\n\r\n    @property\r\n    def access_connector(self):\r\n        return self._pairs.get('accessConnectors')\r\n\r\n    def __eq__(self, other):\r\n        if not isinstance(other, AzureResource):\r\n            return NotImplemented\r\n        return self._resource_id == other._resource_id\r\n\r\n    def __repr__(self):\r\n        properties = ['subscription_id', 'resource_group', 'storage_account', 'container', 'access_connector']\r\n        pairs = [f'{_}={getattr(self, _)}' for _ in properties]\r\n        return f\"AzureResource<{', '.join(pairs)}>\"\r\n\r\n    def __str__(self):"]
[15.821903, "o", "\r\n        return self._resource_id\r\n\r\nclass RawResource:\r\n\r\n    def __init__(self, raw_resource: dict[str, Any]):\r\n        if 'id' not in raw_resource:\r\n            raise KeyError(\"Raw resource must contain an 'id' field\")\r\n        self._id = AzureResource(raw_resource['id'])\r\n        self._raw_resource = raw_resource\r\n\r\n    @property\r\n    def id(self) -> AzureResource:\r\n        return self._id\r\n\r\n    def get(self, key: str, default: Any) -> Any:\r\n        return self._raw_resource.get(key, default)\r\n\r\n@dataclass\r\nclass Principal:\r\n    client_id: str\r\n    display_name: str\r\n    object_id: str\r\n    type: str\r\n    directory_id: str | None = None\r\n\r\n@dataclass\r\nclass StorageAccount:\r\n    id: AzureResource\r\n    name: str\r\n    location: str\r\n    default_network_action: str\r\n\r\n    @classmethod\r\n    def from_raw_resource(cls, raw: RawResource) -> 'StorageAccount':\r\n        if raw.id is None:\r\n            raise KeyError(f'Missing id: {raw}')\r\n        name = raw.get('name', '')\r\n        if name == '':\r\n            raise KeyError(f'Missing name: {raw}')\r\n        location = raw.get('location', '')\r\n        if location == '':\r\n            raise KeyError(f'Missing location: {raw}')\r\n        default_network_action = raw.get('properties', {}).get('networkAcls', {}).get('defaultAction', 'Unknown')\r\n        storage_account = cls(id=raw.id, name=name, location=location, default_network_action=default_network_action)\r\n        return storage_account\r\n\r\n@dataclass\r\nclass PrincipalSecret:\r\n    client: Principal\r\n    secret: str\r\n\r\n@dataclass\r\nclass AzureRoleAssignment:\r\n    id: str\r\n    resource: AzureResource\r\n"]
[15.821982, "o", "    scope: AzureResource\r\n    principal: Principal\r\n    role_name: str\r\n    role_type: str\r\n    role_permissions: list[str]\r\n\r\n@dataclass\r\nclass AzureRoleDetails:\r\n    role_name: str | None\r\n    role_type: str\r\n    role_permissions: list[str]\r\n\r\n@dataclass\r\nclass AccessConnector:\r\n    id: AzureResource\r\n    name: str\r\n    location: str\r\n    provisioning_state: str\r\n    identity_type: str\r\n    principal_id: str\r\n    managed_identity_type: str | None = None\r\n    client_id: str | None = None\r\n    tenant_id: str | None = None\r\n    tags: dict[str, str] = field(default_factory=dict)\r\n\r\n    @classmethod\r\n    def from_raw_resource(cls, raw: RawResource) -> 'AccessConnector':\r\n        if raw.id is None:\r\n            raise KeyError(f'Missing id: {raw}')\r\n        name = raw.get('name', '')\r\n        if name == '':\r\n            raise KeyError(f'Missing name: {raw}')\r\n        location = raw.get('location', '')\r\n        if location == '':\r\n            raise KeyError(f'Missing location: {raw}')\r\n        provisioning_state = raw.get('properties', {}).get('provisioningState', '')\r\n        if provisioning_state == '':\r\n            raise KeyError(f'Missing provisioning state: {raw}')\r\n        identity = raw.get('identity', {})\r\n        identity_type = identity.get('type')\r\n        if identity_type == 'UserAssigned':\r\n            if len(identity.keys()) > 1:\r\n                raise KeyError(f'Multiple user assigned identities: {identity.keys()}')\r\n            if len(identity.keys()) == 0:\r\n                raise KeyError(f'No user assigned identity: {identity.keys()}')\r\n            managed_identity_id = list(identity.keys())[0]\r\n            principal_id = identity[managed_identity_id]['principalId']\r\n            client_id = identity[managed_identity_id]['clientId']\r\n            tenant_id = None\r\n        elif identity_type == 'SystemAssigned':\r\n            principal_id = identity['principalId']\r\n            managed_identity_id = client_id = None\r\n            tenant_id = identity['tenantId']\r\n        else:\r\n            raise KeyError(f'Unsupported identity type: {identity_type}')\r\n        access_connector = cls(id=raw.id, name=name, location=location, provisioning_state=provisioning_state, identity_type=identity_type, principal_id=principal_id, managed_identity_type=managed_identity_id, client_id=client_id, tenant_id=tenant_id, tags=raw.get('tags', {}))\r\n        return access_connector\r\n\r\nclass AzureAPIClient:\r\n\r\n    def __init__(self, host_endpoint: str, service_endpoint: str):\r\n        self.api_client = ApiClient(Config(host=host_endpoint, credentials_strategy=self._strategy_for(service_endpoint)))\r\n        self._token_source = AzureCliTokenSource(host_endpoint)\r\n\r\n    @staticmethod\r\n    def _strategy_for(endpoint: str) -> CredentialsStrategy:\r\n\r\n        @credentials_strategy('azure-cli', ['host'])\r\n        def _credentials(_: Config) -> CredentialsProvider:\r\n            token_source = AzureCliTokenSource(endpoint)\r\n\r\n            def inner() -> dict[str, str]:\r\n                token = token_source.token()\r\n                return {'Authorization': f'{token.token_type} {token.access_token}'}\r\n            return inner\r\n        return _credentials\r\n\r\n    def get(self, path: str, api_version: str | None=None, query: dict[str, str] | None=None):\r\n        headers = {'Accept': 'application/json'}\r\n        _query: dict[str, str] = query or {}\r\n        if api_version is not None:\r\n            _query['api-version'] = api_version\r\n        return self.api_client.do('GET', path, query=_query, headers=headers)\r\n\r\n    def put(self, path: str, api_version: str | None=None, body: dict | None=None):\r\n        headers = {'Content-Type': 'application/json'}\r\n        query: dict[str, str] = {}\r\n        if api_version is not None:\r\n            query['api-version'] = api_version\r\n        if body is not None:\r\n            return self.api_client.do('PUT', path, query=query, headers=headers, body=body)\r\n        return None\r\n\r\n    def post(self, path: str, body: dict | None=None):\r\n        headers = {'Content-Type': 'application/json'}\r\n        query: dict[str, str] = {}\r\n        if body is not None:\r\n            return self.api_client.do('POST', path, query=query, headers=headers, body=body)\r\n        return self.api_client.do('POST', path, query=query, headers=headers)\r\n\r\n    def delete(self, path: str, api_version: str | None=None):\r\n        \"\"\"\r\n        TODO: Implement this function\r\n        \"\"\"\r\n        ...\r\n\r\n    def token(self):\r\n        return self._token_source.token()\r\n\r\nclass AzureResources:\r\n\r\n    def __init__(self, azure_mgmt: AzureAPIClient, azure_graph: AzureAPIClient, include_subscriptions=None):\r\n        if not include_subscriptions:\r\n            include_subscriptions = []\r\n        self._mgmt = azure_mgmt\r\n        self._graph = azure_graph\r\n        self._include_subscriptions = include_subscriptions\r\n        self._role_definitions = {}\r\n        self._principals: dict[str, Principal | None] = {}\r\n\r\n    def _get_subscriptions(self) -> Iterable[AzureSubscription]:\r\n        for subscription in self._mgmt.get('/subscriptions', '2022-12-01').get('value', []):\r\n            yield AzureSubscription(name=subscription['displayName'], subscription_id=subscription['subscriptionId'], tenant_id=subscription['tenantId'])\r\n\r\n    def create_service_principal(self, display_name: str) -> PrincipalSecret:\r\n        try:\r\n            application_info: dict[str, str] = self._graph.post('/v1.0/applications', {'displayName': display_name})\r\n            app_id = application_info.get('appId')\r\n            assert app_id is not None\r\n            service_principal_info: dict[str, str] = self._graph.post('/v1.0/servicePrincipals', {'appId': app_id})\r\n            object_id = service_principal_info.get('id')\r\n            assert object_id is not None\r\n            secret_info: dict[str, str] = self._graph.post(f'/v1.0/servicePrincipals/{object_id}/addPassword')\r\n        except PermissionDenied:\r\n            msg = 'Permission denied. Please run this cmd under the identity of a user who has create service principal permission.'\r\n            logger.error(msg)\r\n            raise PermissionDenied(msg) from None\r\n        secret = secret_info.get('secretText')\r\n        client_id = service_principal_info.get('appId')\r\n        principal_type = service_principal_info.get('servicePrincipalType')\r\n        directory_id = service_principal_info.get('appOwnerOrganizationId')\r\n        assert client_id is not None\r\n        assert object_id is not None\r\n        assert principal_type is not None\r\n        assert directory_id is not None\r\n        assert secret is not None\r\n        principal_secret = PrincipalSecret(Principal(client_id, display_name, object_id, principal_type, directory_id), secret)\r\n        logger.info(f'Created service principal ({principal_secret.client.client_id}) with access to used storage accounts: ' + principal_secret.client.display_name)\r\n        return principal_secret\r\n\r\n    def delete_service_principal(self, principal_id: str, *, safe: bool=False):\r\n        \"\"\"Delete the service principal.\r\n\r\n        Parameters\r\n        ----------\r\n        principal_id : str\r\n            The principal id to delete.\r\n        safe : bool, optional (default: True)\r\n            If True, will not raise an error if the service principal does not exists.\r\n\r\n        Raises\r\n        ------\r\n        NotFound :\r\n            If the principal is not found.\r\n        PermissionDenied :\r\n            If missing permission to delete the service principal\r\n        \"\"\"\r\n        try:\r\n            self._graph.delete(f\"/v1.0/applications(appId='{principal_id}')\")\r\n        except PermissionDenied:\r\n            msg = f'User doesnt have permission to delete application {principal_id}'\r\n            logger.error(msg)\r\n            raise PermissionDenied(msg) from None\r\n        except NotFound:\r\n            if safe:\r\n                return\r\n            raise\r\n\r\n    def _log_permission_denied_error_for_storage_permission(self, path: str) -> None:\r\n        logger.error(f'Permission denied. Please run this cmd under the identity of a user who has create service principal permission: {path}')\r\n\r\n    def get_storage_permission(self, storage_account: StorageAccount, role_guid: str, *, timeout: timedelta=timedelta(seconds=1)) -> AzureRoleAssignment | None:\r\n        \"\"\"Get a storage permission.\r\n\r\n        Parameters\r\n        ----------\r\n        storage_account : StorageAccount\r\n            The storage account to get the permission for.\r\n        role_guid : str\r\n            The role guid to get the permission for.\r\n        timeout : timedelta, optional (default: timedelta(seconds=1))\r\n            The timeout to wait for the permission to be found.\r\n\r\n        Raises\r\n        ------\r\n        PermissionDenied :\r\n            If user is missing permission to get the storage permission.\r\n        \"\"\"\r\n        retry = retried(on=[NotFound], timeout=timeout)\r\n"]
[15.822076, "o", "        path = f'{storage_account.id}/providers/Microsoft.Authorization/roleAssignments/{role_guid}'\r\n        try:\r\n            response = retry(self._mgmt.get)(path, '2022-04-01')\r\n            assignment = self._role_assignment(response, str(storage_account.id))\r\n            return assignment\r\n        except TimeoutError:\r\n            logger.warning(f'Storage permission not found: {path}')\r\n            return None\r\n        except PermissionDenied:\r\n            self._log_permission_denied_error_for_storage_permission(path)\r\n            raise\r\n\r\n    def _get_storage_permissions(self, principal_id: str, storage_account: StorageAccount) -> Iterable[AzureRoleAssignment]:\r\n        \"\"\"Get storage permissions for a principal.\r\n\r\n        Parameters\r\n        ----------\r\n        principal_id : str\r\n            The principal id to get the storage permissions for.\r\n        storage_account : StorageAccount\r\n            The storage account to get the permission for.\r\n\r\n        Yields\r\n        ------\r\n        AzureRoleAssignment :\r\n            The role assignment\r\n\r\n        Raises\r\n        ------\r\n        PermissionDenied :\r\n            If user is missing permission to get the storage permission.\r\n        \"\"\"\r\n        path = f\"{storage_account.id}/providers/Microsoft.Authorization/roleAssignments?$filter=principalId%20eq%20'{principal_id}'\"\r\n        try:\r\n            response = self._mgmt.get(path, '2022-04-01')\r\n        except PermissionDenied:\r\n            self._log_permission_denied_error_for_storage_permission(path)\r\n            raise\r\n        for role_assignment in response.get('value', []):\r\n            assignment = self._role_assignment(role_assignment, str(storage_account.id))\r\n            if assignment:\r\n                yield assignment\r\n\r\n    def apply_storage_permission(self, principal_id: str, storage_account: StorageAccount, role_name: str, role_guid: str):\r\n        role_id = _ROLES[role_name]\r\n        path = f'{storage_account.id}/providers/Microsoft.Authorization/roleAssignments/{role_guid}'\r\n        try:\r\n            role_definition_id = f'/subscriptions/{storage_account.id.subscription_id}/providers/Microsoft.Authorization/roleDefinitions/{role_id}'\r\n            body = {'properties': {'roleDefinitionId': role_definition_id, 'principalId': principal_id, 'principalType': 'ServicePrincipal'}}\r\n            self._mgmt.put(path, '2022-04-01', body)\r\n        except ResourceConflict:\r\n            logger.warning(f'Role assignment already exists for role {role_guid} on storage {storage_account.name} for spn {principal_id}.')\r\n        except PermissionDenied:\r\n            self._log_permission_denied_error_for_storage_permission(path)\r\n            raise\r\n\r\n    def _delete_storage_permission(self, principal_id: str, storage_account: StorageAccount, *, safe: bool=False) -> None:\r\n        \"\"\"See meth:delete_storage_permission\"\"\"\r\n        try:\r\n            storage_permissions = list(self._get_storage_permissions(principal_id, storage_account))\r\n        except NotFound:\r\n            if safe:\r\n                return\r\n            raise\r\n        permission_denied_ids = []\r\n        for permission in storage_permissions:\r\n            try:\r\n                self._mgmt.delete(permission.id, '2022-04-01')\r\n            except PermissionDenied:\r\n                self._log_permission_denied_error_for_storage_permission(permission.id)\r\n                permission_denied_ids.append(permission.id)\r\n            except NotFound:\r\n                continue\r\n        if permission_denied_ids:\r\n            raise PermissionDenied(f\"Permission denied for deleting role assignments: {', '.join(permission_denied_ids)}\")\r\n\r\n    def delete_storage_permission(self, principal_id: str, *storage_accounts: StorageAccount, safe: bool=False) -> None:\r\n        \"\"\"Delete storage permission(s) for a principal\r\n\r\n        Parameters\r\n        ----------\r\n        principal_id : str\r\n            The principal id to delete the role assignment(s) for.\r\n        storage_accounts : StorageAccount\r\n            The storage account(s) to delete permission for.\r\n        safe : bool, optional (default: False)\r\n            If True, will not raise an exception if no role assignment are found.\r\n\r\n        Raises\r\n        ------\r\n        PermissionDenied :\r\n            If user is missing permission to get the storage permission.\r\n        \"\"\"\r\n        for storage_account in storage_accounts:\r\n            self._delete_storage_permission(principal_id, storage_account, safe=safe)\r\n\r\n    def tenant_id(self):\r\n        token = self._mgmt.token()\r\n        return token.jwt_claims().get('tid')\r\n\r\n    def subscriptions(self):\r\n        tenant_id = self.tenant_id()\r\n        for subscription in self._get_subscriptions():\r\n            if subscription.tenant_id != tenant_id:\r\n                continue\r\n            if subscription.subscription_id not in self._include_subscriptions:\r\n                continue\r\n            yield subscription\r\n\r\n    def storage_accounts(self) -> Iterable[StorageAccount]:\r\n        for subscription in self.subscriptions():\r\n            logger.info(f'Checking in subscription {subscription.name} for storage accounts')\r\n            path = f'/subscriptions/{subscription.subscription_id}/providers/Microsoft.Storage/storageAccounts'\r\n            for response in self._mgmt.get(path, '2023-01-01').get('value', []):\r\n                try:\r\n                    storage_account = StorageAccount.from_raw_resource(RawResource(response))\r\n                except KeyError:\r\n                    logger.warning(f'Failed parsing storage account: {response}')\r\n                else:\r\n                    yield storage_account\r\n\r\n    def containers(self, storage: AzureResource):\r\n        for raw in self._mgmt.get(f'{storage}/blobServices/default/containers', '2023-01-01').get('value', []):\r\n            resource_id = raw.get('id')\r\n            if not resource_id:\r\n                continue\r\n            yield AzureResource(resource_id)\r\n\r\n    def _get_principal(self, principal_id: str) -> Principal | None:\r\n        if principal_id in self._principals:\r\n            return self._principals[principal_id]\r\n        try:\r\n            path = f'/v1.0/directoryObjects/{principal_id}'\r\n            raw: dict[str, str] = self._graph.get(path)\r\n        except NotFound:\r\n            self._principals[principal_id] = None\r\n            return self._principals[principal_id]\r\n        client_id = raw.get('appId')\r\n        display_name = raw.get('displayName')\r\n        object_id = raw.get('id')\r\n        principal_type = raw.get('servicePrincipalType')\r\n        directory_id = raw.get('appOwnerOrganizationId')\r\n        assert client_id is not None\r\n        assert display_name is not None\r\n        assert object_id is not None\r\n        assert principal_type is not None\r\n        if principal_type == 'Application':\r\n            assert directory_id is not None\r\n        self._principals[principal_id] = Principal(client_id, display_name, object_id, principal_type, directory_id)\r\n        return self._principals[principal_id]\r\n\r\n    def role_assignments(self, resource_id: str, *, principal_types: list[str] | None=None) -> Iterable[AzureRoleAssignment]:\r\n        \"\"\"See https://learn.microsoft.com/en-us/rest/api/authorization/role-assignments/list-for-resource\"\"\"\r\n        if not principal_types:\r\n            principal_types = ['ServicePrincipal']\r\n        result = self._mgmt.get(f'{resource_id}/providers/Microsoft.Authorization/roleAssignments', '2022-04-01')\r\n        for role_assignment in result.get('value', []):\r\n            principal_type = role_assignment.get('properties', {}).get('principalType')\r\n            if not principal_type or principal_type not in principal_types:\r\n                continue\r\n            assignment = self._role_assignment(role_assignment, resource_id)\r\n            if not assignment:\r\n                continue\r\n            yield assignment\r\n\r\n    def _role_assignment(self, role_assignment: dict, resource_id: str) -> AzureRoleAssignment | None:\r\n        id_ = role_assignment.get('id')\r\n        if not id_:\r\n            return None\r\n        assignment_properties = role_assignment.get('properties', {})\r\n        principal_type = assignment_properties.get('principalType')\r\n        if not principal_type:\r\n            return None\r\n        principal_id = assignment_properties.get('principalId')\r\n        if not principal_id:\r\n            return None\r\n        role_definition_id = assignment_properties.get('roleDefinitionId')\r\n        if not role_definition_id:\r\n            return None\r\n        scope = assignment_properties.get('scope')\r\n        if not scope:\r\n            return None\r\n        role_details = self._role_name(role_definition_id)\r\n        role_name = role_details.role_name\r\n        if not role_name:\r\n            return None\r\n        principal = self._get_principal(principal_id)\r\n        if not principal:\r\n            return None\r\n        if scope == '/':\r\n            scope = resource_id\r\n"]
[15.822255, "o", "        return AzureRoleAssignment(id=id_, resource=AzureResource(resource_id), scope=AzureResource(scope), principal=principal, role_name=role_name, role_type=role_details.role_type, role_permissions=role_details.role_permissions)\r\n\r\n    def _role_name(self, role_definition_id) -> AzureRoleDetails:\r\n        if role_definition_id not in self._role_definitions:\r\n            role_definition = self._mgmt.get(role_definition_id, '2022-04-01')\r\n            definition_properties = role_definition.get('properties', {})\r\n            role_name = definition_properties.get('roleName')\r\n            if not role_name:\r\n                return AzureRoleDetails(role_name=None, role_type='BuiltInRole', role_permissions=[])\r\n            role_type = definition_properties.get('type', 'BuiltInRole')\r\n            role_permissions = []\r\n            if role_type == 'CustomRole':\r\n                role_permissions_list = definition_properties.get('permissions', [])\r\n                for each_role_permissions in role_permissions_list:\r\n                    role_permissions = each_role_permissions.get('actions', []) + each_role_permissions.get('dataActions', [])\r\n            self._role_definitions[role_definition_id] = AzureRoleDetails(role_name=role_name, role_type=role_type, role_permissions=role_permissions)\r\n        return self._role_definitions[role_definition_id]\r\n\r\n    def managed_identity_client_id(self, access_connector_id: str, user_assigned_identity_id: str | None=None) -> str | None:\r\n        try:\r\n            identity = self._mgmt.get(access_connector_id, '2023-05-01').get('identity')\r\n        except NotFound:\r\n            logger.warning(f'Access connector {access_connector_id} no longer exists')\r\n            return None\r\n        if not identity:\r\n            return None\r\n        if identity.get('type') == 'UserAssigned':\r\n            if not user_assigned_identity_id:\r\n                return None\r\n            identities = identity.get('userAssignedIdentities')\r\n            if user_assigned_identity_id in identities:\r\n                return identities.get(user_assigned_identity_id).get('clientId')\r\n            alternative_identity_id = user_assigned_identity_id.replace('resourcegroups', 'resourceGroups')\r\n            if alternative_identity_id in identities:\r\n                return identities.get(alternative_identity_id).get('clientId')\r\n            return None\r\n        if identity.get('type') == 'SystemAssigned':\r\n            principal = self._get_principal(identity.get('principalId'))\r\n            if not principal:\r\n                return None\r\n            return principal.client_id\r\n        return None\r\n\r\n    def get_access_connector(self, subscription_id: str, resource_group_name: str, name: str) -> AccessConnector | None:\r\n        \"\"\"Get an access connector.\r\n\r\n        Docs:\r\n            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/get?view=rest-databricks-2023-05-01&tabs=HTTP\r\n        \"\"\"\r\n        url = f'/subscriptions/{subscription_id}/resourceGroups/{resource_group_name}/providers/Microsoft.Databricks/accessConnectors/{name}'\r\n        response = self._mgmt.get(url, api_version='2023-05-01')\r\n        raw = RawResource(response)\r\n        try:\r\n            access_connector = AccessConnector.from_raw_resource(raw)\r\n        except KeyError:\r\n            logger.warning(f'Tried getting non-existing access connector: {url}')\r\n            access_connector = None\r\n        return access_connector\r\n\r\n    def list_resources(self, subscription: AzureSubscription, resource_type: str) -> Iterable[RawResource]:\r\n        \"\"\"List all resources of a type within subscription\"\"\"\r\n        query = {'api-version': '2020-06-01', '$filter': f\"resourceType eq '{resource_type}'\"}\r\n        while True:\r\n            res = self._mgmt.get(f'/subscriptions/{subscription.subscription_id}/resources', query=query)\r\n            for resource in res['value']:\r\n                try:\r\n                    yield RawResource(resource)\r\n                except KeyError:\r\n                    logger.warning(f'Could not parse resource: {resource}')\r\n            next_link = res.get('nextLink', None)\r\n            if not next_link:\r\n                break\r\n            parsed_link = urllib.parse.urlparse(next_link)\r\n            query = dict(urllib.parse.parse_qsl(parsed_link.query))\r\n\r\n    def access_connectors(self) -> Iterable[AccessConnector]:\r\n        \"\"\"List all access connector within subscription\r\n\r\n        Docs:\r\n            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/list-by-subscription?view=rest-databricks-2023-05-01&tabs=HTTP\r\n        \"\"\"\r\n        for subscription in self.subscriptions():\r\n            for raw in self.list_resources(subscription, 'Microsoft.Databricks/accessConnectors'):\r\n                try:\r\n                    yield AccessConnector.from_raw_resource(raw)\r\n                except KeyError:\r\n                    logger.warning(f'Could not parse access connector: {raw}')\r\n\r\n    def create_or_update_access_connector(self, subscription_id: str, resource_group_name: str, name: str, location: str, tags: dict[str, str] | None, *, wait_for_provisioning: bool=False, wait_for_provisioning_timeout_in_seconds: int=300) -> AccessConnector:\r\n        \"\"\"Create access connector.\r\n\r\n        Docs:\r\n            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/create-or-update?view=rest-databricks-2023-05-01&tabs=HTTP\r\n        \"\"\"\r\n        url = f'/subscriptions/{subscription_id}/resourceGroups/{resource_group_name}/providers/Microsoft.Databricks/accessConnectors/{name}'\r\n        body = {'location': location, 'identity': {'type': 'SystemAssigned'}}\r\n        if tags is not None:\r\n            body['tags'] = tags\r\n        self._mgmt.put(url, api_version='2023-05-01', body=body)\r\n        access_connector = self.get_access_connector(subscription_id, resource_group_name, name)\r\n        start_time = time.time()\r\n        if access_connector is None or (wait_for_provisioning and access_connector.provisioning_state != 'Succeeded'):\r\n            if time.time() - start_time > wait_for_provisioning_timeout_in_seconds:\r\n                raise TimeoutError(f'Timeout waiting for creating or updating access connector: {url}')\r\n            time.sleep(5)\r\n            access_connector = self.get_access_connector(subscription_id, resource_group_name, name)\r\n            assert access_connector is not None\r\n        return access_connector\r\n\r\n    def delete_access_connector(self, url: str) -> None:\r\n        \"\"\"Delete an access connector.\r\n\r\n        Docs:\r\n            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/delete?view=rest-databricks-2023-05-01&tabs=HTTP\r\n        \"\"\"\r\n        self._mgmt.delete(url, api_version='2023-05-01')"]
[15.822344, "o", "\u001b[?2004h"]
[15.822383, "o", "root@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/src/databricks/labs/ucx/azure# "]
[21.669002, "i", "echo'       \"\"\"Delete an access connector.\\n\\n        Docs:\\n            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/delete?view=rest-databricks-2023-05-01&tabs=HTTP\\n        \"\"\"\\n        self._mgmt.delete(url, api_version=\\'2023-05-01\\')' > resources.py\n"]
[21.669932, "o", "echo'       \"\"\"Delete an access connector.\\n\\n        Docs:\\n            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/delete?view=rest-databricks-2023-05-01&tabs=HTTP\\n        \"\"\"\\n        self._mgmt.delete(url, api_version=\\'2023-05-01\\')' > resources.py\r\n\u001b[?2004l\r"]
[21.669958, "o", "bash: syntax error near unexpected token `)'\r\n"]
[21.670031, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/src/databricks/labs/ucx/azure# "]
[36.30052, "i", "printf '        \"\"\"Delete an access connector.\\n\\n        Docs:\\n            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/delete?view=rest-databricks-2023-05-01&tabs=HTTP\\n        \"\"\"\\n        self._mgmt.delete(url, api_version=\\'2023-05-01\\')\\n' > resources.py\n"]
[36.301347, "o", "printf '        \"\"\"Delete an access connector.\\n\\n        Docs:\\n            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/delete?view=rest-databricks-2023-05-01&tabs=HTTP\\n        \"\"\"\\n        self._mgmt.delete(url, api_version=\\'2023-05-01\\')\\n' > resources.py\r\n\u001b[?2004l\r"]
[36.301375, "o", "bash: syntax error near unexpected token `)'\r\n"]
[36.301436, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/src/databricks/labs/ucx/azure# "]
[57.179808, "i", "cat > resources.py <<'EOF'\n        \"\"\"Delete an access connector.\n\n        Docs:\n            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/delete?view=rest-databricks-2023-05-01&tabs=HTTP\n        \"\"\"\n        self._mgmt.delete(url, api_version='2023-05-01')\nEOF\n"]
[57.179976, "o", "cat > resources.py <<'EOF'\r\n\u001b[?2004l\r"]
[57.180019, "o", "\u001b[?2004h> "]
[57.180126, "o", "        \"\"\"Delete an access connector.\r\n\u001b[?2004l\r"]
[57.180154, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[57.180179, "o", "\u001b[?2004h> "]
[57.180222, "o", "        Docs:\r\n\u001b[?2004l\r"]
[57.180247, "o", "\u001b[?2004h> "]
[57.180603, "o", "            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/delete?view=rest-databricks-2023-05-01&tabs=HTTP\r\n\u001b[?2004l\r"]
[57.18064, "o", "\u001b[?2004h> "]
[57.180664, "o", "        \"\"\"\r\n\u001b[?2004l\r\u001b[?2004h"]
[57.180687, "o", "> "]
[57.180836, "o", "        self._mgmt.delete(url, api_version='2023-05-01')\r\n\u001b[?2004l\r"]
[57.180862, "o", "\u001b[?2004h> EOF\r\n\u001b[?2004l\r"]
[57.183328, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/src/databricks/labs/ucx/azure# "]
[76.071404, "i", "pytest tests/unit/azure/test_resources.py::test_azure_client_api_delete_spn -v\n"]
[76.071765, "o", "pytest tests/unit/azure/test_resources.py::test_azure_client_api_delete_spn -v\r\n\u001b[?2004l\r"]
[76.244771, "o", "\u001b[1m===================================================================== test session starts ======================================================================\u001b[0m\r\n\u001b[1mcollecting ... \u001b[0m"]
[76.244889, "o", "\u001b[1m\rcollected 0 items                                                                                                                                              \u001b[0m\r\n"]
[76.245527, "o", "\r\n"]
[76.245606, "o", "\u001b[33m==================================================================== \u001b[33mno tests ran\u001b[0m\u001b[33m in 0.00s\u001b[0m\u001b[33m =====================================================================\u001b[0m\r\n"]
[76.259856, "o", "\u001b[31mERROR: file or directory not found: tests/unit/azure/test_resources.py::test_azure_client_api_delete_spn\r\n\u001b[0m\r\n"]
[76.277949, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/src/databricks/labs/ucx/azure# "]
[99.703696, "i", "ls -la tests/unit/azure/\n"]
[99.703907, "o", "ls -la tests/unit/azure/\r\n\u001b[?2004l\r"]
[99.705098, "o", "ls: cannot access 'tests/unit/azure/': No such file or directory\r\n"]
[99.705305, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/src/databricks/labs/ucx/azure# "]
[123.218025, "i", "cd /workspace/repo\n"]
[123.218161, "o", "cd /workspace/repo\r\n\u001b[?2004l\r"]
[123.218257, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo# "]
[123.672657, "i", "ls -la\n"]
[123.672838, "o", "ls -la\r\n\u001b[?2004l\r"]
[123.674265, "o", "total 968\r\n"]
[123.674306, "o", "drwxr-xr-x 1 root root     42 Feb  9 20:36 .\r\ndrwxr-xr-x 1 root root     18 Feb  9 20:23 ..\r\n-rw-rw-r-- 1 root root    378 Jan 21 15:55 .codegen.json\r\n-rw-rw-r-- 1 root root    294 Jan 21 15:55 .editorconfig\r\ndrwxr-xr-x 4 root root    142 Feb  9 20:23 .github\r\n-rw-rw-r-- 1 root root   2161 Jan 21 15:55 .gitignore\r\ndrwxr-xr-x 3 root root     34 Feb  9 20:36 .venv\r\n"]
[123.674357, "o", "-rw-rw-r-- 1 root root 895135 Jan 21 15:55 CHANGELOG.md\r\n-rw-rw-r-- 1 root root     38 Jan 21 15:55 CODEOWNERS\r\n-rw-rw-r-- 1 root root   3862 Jan 21 15:55 LICENSE\r\n-rw-rw-r-- 1 root root    841 Jan 21 15:55 Makefile\r\n-rw-rw-r-- 1 root root   1206 Jan 21 15:55 NOTICE\r\n-rw-rw-r-- 1 root root   2279 Jan 21 15:55 README.md\r\n-rw-rw-r-- 1 root root   1152 Jan 21 15:55 SECURITY.md\r\ndrwxr-xr-x 3 root root     25 Feb  9 20:23 docs\r\n-rw-rw-r-- 1 root root  17767 Jan 21 15:55 labs.yml\r\n-rw-rw-r-- 1 root root  29386 Jan 21 15:55 pyproject.toml\r\ndrwxr-xr-x 1 root root     24 Feb  9 20:23 src\r\ndrwxr-xr-x 4 root root     72 Feb  9 20:23 tests\r\n-rw-rw-r-- 1 root root    597 Jan 21 15:55 ucx.iml\r\n"]
[123.674565, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo# "]
[138.562865, "i", "cd tests\n"]
[138.563025, "o", "cd tests\r\n\u001b[?2004l\r"]
[138.563105, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/tests# "]
[139.063191, "i", "ls -la\n"]
[139.06331, "o", "ls -la\r\n\u001b[?2004l\r"]
[139.064617, "o", "total 8\r\n"]
[139.064642, "o", "drwxr-xr-x  4 root root   72 Feb  9 20:23 .\r\ndrwxr-xr-x  1 root root   42 Feb  9 20:36 ..\r\n-rw-rw-r--  1 root root    0 Jan 21 15:55 __init__.py\r\ndrwxr-xr-x 14 root root 4096 Feb  9 20:23 integration\r\ndrwxr-xr-x 16 root root 4096 Feb  9 20:23 unit\r\n"]
[139.064874, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/tests# "]
[155.727042, "i", "cd unit\n"]
[155.727219, "o", "cd unit\r\n\u001b[?2004l\r"]
[155.72729, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/tests/unit# "]
[156.217605, "i", "ls -la\n"]
[156.217765, "o", "ls -la\r\n\u001b[?2004l\r"]
[156.219288, "o", "total 136\r\n"]
[156.21933, "o", "drwxr-xr-x 16 root root  4096 Feb  9 20:23 .\r\ndrwxr-xr-x  4 root root    72 Feb  9 20:23 ..\r\n-rw-rw-r--  1 root root  7482 Jan 21 15:55 __init__.py\r\ndrwxr-xr-x  2 root root   122 Feb  9 20:23 account\r\ndrwxr-xr-x  9 root root  4096 Feb  9 20:23 assessment\r\ndrwxr-xr-x  2 root root    90 Feb  9 20:23 aws\r\ndrwxr-xr-x  3 root root   165 Feb  9 20:23 azure\r\n-rw-rw-r--  1 root root 10210 Jan 21 15:55 conftest.py\r\ndrwxr-xr-x  2 root root    97 Feb  9 20:23 contexts\r\n"]
[156.219367, "o", "drwxr-xr-x  2 root root   137 Feb  9 20:23 framework\r\ndrwxr-xr-x  3 root root  4096 Feb  9 20:23 hive_metastore\r\ndrwxr-xr-x  2 root root   121 Feb  9 20:23 install\r\ndrwxr-xr-x  2 root root   143 Feb  9 20:23 installer\r\ndrwxr-xr-x  2 root root    74 Feb  9 20:23 mixins\r\n-rw-rw-r--  1 root root  1151 Jan 21 15:55 no_cheat.py\r\ndrwxr-xr-x  2 root root  4096 Feb  9 20:23 progress\r\ndrwxr-xr-x  2 root root  4096 Feb  9 20:23 recon\r\ndrwxr-xr-x  7 root root  4096 Feb  9 20:23 source_code\r\n-rw-rw-r--  1 root root 50159 Jan 21 15:55 test_cli.py\r\n-rw-rw-r--  1 root root  7533 Jan 21 15:55 test_collection.py\r\n-rw-rw-r--  1 root root  1345 Jan 21 15:55 test_config.py\r\n-rw-rw-r--  1 root root  3444 Jan 21 15:55 test_factories.py\r\n-rw-rw-r--  1 root root  1951 Jan 21 15:55 test_github.py\r\n-rw-rw-r--  1 root root  2181 Jan 21 15:55 test_no_cheat.py\r\n-rw-rw-r--  1 root root  2722 Jan 21 15:55 test_useragent.py\r\n-rw-rw-r--  1 root root   442 Jan 21 15:55 test_workflows.py\r\ndrwxr-xr-x  2 root root  4096 Feb  9 20:23 workspace_access\r\n"]
[156.219593, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/tests/unit# "]
[172.820102, "i", "cd azure\n"]
[172.820274, "o", "cd azure\r\n\u001b[?2004l\r"]
[172.820349, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/tests/unit/azure# "]
[173.298761, "i", "ls -la\n"]
[173.298887, "o", "ls -la\r\n\u001b[?2004l\r"]
[173.300211, "o", "total 128\r\n"]
[173.300233, "o", "drwxr-xr-x  3 root root   165 Feb  9 20:23 .\r\ndrwxr-xr-x 16 root root  4096 Feb  9 20:23 ..\r\n-rw-rw-r--  1 root root  1314 Jan 21 15:55 __init__.py\r\n"]
[173.300281, "o", "drwxr-xr-x  2 root root    27 Feb  9 20:23 azure\r\n-rw-rw-r--  1 root root 47736 Jan 21 15:55 test_access.py\r\n-rw-rw-r--  1 root root 23323 Jan 21 15:55 test_credentials.py\r\n-rw-rw-r--  1 root root 23020 Jan 21 15:55 test_locations.py\r\n-rw-rw-r--  1 root root 22785 Jan 21 15:55 test_resources.py\r\n"]
[173.300471, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/tests/unit/azure# "]
[186.888527, "i", "pytest tests/unit/azure/test_resources.py::test_azure_client_api_delete_spn -v\n"]
[186.888836, "o", "pytest tests/unit/azure/test_resources.py::test_azure_client_api_delete_spn -v\r\n"]
[186.888859, "o", "\u001b[?2004l\r"]
[187.704538, "o", "\u001b[31mImportError while loading conftest '/workspace/repo/tests/unit/conftest.py'.\u001b[0m\r\n"]
[187.800447, "o", "\u001b[31m../conftest.py:23: in <module>\u001b[0m\r\n\u001b[31m    from databricks.labs.ucx.contexts.workflow_task import RuntimeContext\u001b[0m\r\n\u001b[31m../../../src/databricks/labs/ucx/contexts/workflow_task.py:23: in <module>\u001b[0m\r\n\u001b[31m    from databricks.labs.ucx.contexts.application import GlobalContext\u001b[0m\r\n\u001b[31m../../../src/databricks/labs/ucx/contexts/application.py:38: in <module>\u001b[0m\r\n\u001b[31m    from databricks.labs.ucx.hive_metastore.catalog_schema import CatalogSchema\u001b[0m\r\n\u001b[31m../../../src/databricks/labs/ucx/hive_metastore/catalog_schema.py:12: in <module>\u001b[0m\r\n\u001b[31m    from databricks.labs.ucx.hive_metastore.grants import MigrateGrants\u001b[0m\r\n\u001b[31m../../../src/databricks/labs/ucx/hive_metastore/grants.py:30: in <module>\u001b[0m\r\n\u001b[31m    from databricks.labs.ucx.azure.access import (\u001b[0m\r\n\u001b[31m../../../src/databricks/labs/ucx/azure/access.py:38: in <module>\u001b[0m\r\n"]
[187.800486, "o", "\u001b[31m    from databricks.labs.ucx.azure.resources import (\u001b[0m\r\n\u001b[31mE     File \"/workspace/repo/src/databricks/labs/ucx/azure/resources.py\", line 1\u001b[0m\r\n\u001b[31mE       \"\"\"Delete an access connector.\u001b[0m\r\n\u001b[31mE   IndentationError: unexpected indent\u001b[0m\r\n"]
[187.919527, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/tests/unit/azure# "]
[400.254866, "i", "cd /workspace/repo/src/databricks/labs/ucx/azure\n"]
[400.255138, "o", "cd /workspace/repo/src/databricks/labs/ucx/azure\r\n\u001b[?2004l\r"]
[400.25525, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/src/databricks/labs/ucx/azure# "]
[400.821145, "i", "cat > resources.py <<'EOF'\nimport urllib.parse\nimport time\nfrom collections.abc import Iterable\nfrom dataclasses import dataclass, field\nfrom datetime import timedelta\nfrom typing import Any\nfrom databricks.sdk.core import ApiClient, AzureCliTokenSource, Config, CredentialsProvider, CredentialsStrategy, credentials_strategy\nfrom databricks.sdk.errors import NotFound, PermissionDenied, ResourceConflict\nfrom databricks.sdk.retries import retried\nfrom databricks.labs.ucx.assessment.crawlers import logger\n_ROLES = {'STORAGE_BLOB_DATA_READER': '2a2b9908-6ea1-4ae2-8e65-a410df84e7d1', 'STORAGE_BLOB_DATA_CONTRIBUTOR': 'ba92f5b4-2d11-453d-a403-e96b0029c9fe'}\n\n@dataclass\nclass AzureSubscription:\n    name: str\n    subscription_id: str\n    tenant_id: str\n\nclass AzureResource:\n\n    def __init__(self, resource_id: str):\n        self._pairs = {}\n        self._resource_id = resource_id\n        split = resource_id.lstrip('/').split('/')\n        if len(split) % 2 != 0:\n            msg = f'not a list of pairs: {resource_id}'\n            raise ValueError(msg)\n        i = 0\n        while i < len(split):\n            k = split[i]\n            value = split[i + 1]\n            i += 2\n            self._pairs[k] = value\n\n    @property\n    def subscription_id(self):\n        return self._pairs.get('subscriptions')\n\n    @property\n    def resource_group(self):\n        return self._pairs.get('resourceGroups')\n\n    @property\n    def storage_account(self):\n        return self._pairs.get('storageAccounts')\n\n    @property\n    def container(self):\n        return self._pairs.get('containers')\n\n    @property\n    def access_connector(self):\n        return self._pairs.get('accessConnectors')\n\n    def __eq__(self, other):\n        if not isinstance(other, AzureResource):\n            return NotImplemented\n        return self._resource_id == other._resource_id\n\n    def __repr__(self):\n        properties = ['subscription_id', 'resource_group', 'storage_account', 'container', 'access_connector']\n        pairs = [f'{_}={getattr(self, _)}' for _ in properties]\n        return f\"AzureResource<{', '.join(pairs)}>\"\n\n    def __str__(self):\n        return self._resource_id\n\nclass RawResource:\n\n    def __init__(self, raw_resource: dict[str, Any]):\n        if 'id' not in raw_resource:\n            raise KeyError(\"Raw resource must contain an 'id' field\")\n        self._id = AzureResource(raw_resource['id'])\n        self._raw_resource = raw_resource\n\n    @property\n    def id(self) -> AzureResource:\n        return self._id\n\n    def get(self, key: str, default: Any) -> Any:\n        return self._raw_resource.get(key, default)\n\n@dataclass\nclass Principal:\n    client_id: str\n    display_name: str\n    object_id: str\n    type: str\n    directory_id: str | None = None\n\n@dataclass\nclass StorageAccount:\n    id: AzureResource\n    name: str\n    location: str\n    default_network_action: str\n\n    @classmethod\n    def from_raw_resource(cls, raw: RawResource) -> 'StorageAccount':\n        if raw.id is None:\n            raise KeyError(f'Missing id: {raw}')\n        name = raw.get('name', '')\n        if name == '':\n            raise KeyError(f'Missing name: {raw}')\n        location = raw.get('location', '')\n        if location == '':\n            raise KeyError(f'Missing location: {raw}')\n        default_network_action = raw.get('properties', {}).get('networkAcls', {}).get('defaultAction', 'Unknown')\n        storage_account = cls(id=raw.id, name=name, location=location, default_network_action=default_network_action)\n        return storage_account\n\n@dataclass\nclass PrincipalSecret:\n    client: Principal\n    secret: str\n\n@dataclass\nclass AzureRoleAssignment:\n    id: str\n    resource: AzureResource\n    scope: AzureResource\n    principal: Principal\n    role_name: str\n    role_type: str\n    role_permissions: list[str]\n\n@dataclass\nclass AzureRoleDetails:\n    role_name: str | None\n    role_type: str\n    role_permissions: list[str]\n\n@dataclass\nclass AccessConnector:\n    id: AzureResource\n    name: str\n    location: str\n    provisioning_state: str\n    identity_type: str\n    principal_id: str\n    managed_identi"]
[400.821257, "i", "ty_type: str | None = None\n    client_id: str | None = None\n    tenant_id: str | None = None\n    tags: dict[str, str] = field(default_factory=dict)\n\n    @classmethod\n    def from_raw_resource(cls, raw: RawResource) -> 'AccessConnector':\n        if raw.id is None:\n            raise KeyError(f'Missing id: {raw}')\n        name = raw.get('name', '')\n        if name == '':\n            raise KeyError(f'Missing name: {raw}')\n        location = raw.get('location', '')\n        if location == '':\n            raise KeyError(f'Missing location: {raw}')\n        provisioning_state = raw.get('properties', {}).get('provisioningState', '')\n        if provisioning_state == '':\n            raise KeyError(f'Missing provisioning state: {raw}')\n        identity = raw.get('identity', {})\n        identity_type = identity.get('type')\n        principal_id = identity.get('principalId')\n        managed_identity_type = identity.get('type')\n        client_id = None\n        tenant_id = None\n        if identity.get('type') == 'UserAssigned':\n            if not user_assigned_identity_id:\n                return None\n            identities = identity.get('userAssignedIdentities')\n            if user_assigned_identity_id in identities:\n                return identities.get(user_assigned_identity_id).get('clientId')\n            alternative_identity_id = user_assigned_identity_id.replace('resourcegroups', 'resourceGroups')\n            if alternative_identity_id in identities:\n                return identities.get(alternative_identity_id).get('clientId')\n            return None\n        if identity.get('type') == 'SystemAssigned':\n            principal = self._get_principal(identity.get('principalId'))\n            if not principal:\n                return None\n            return principal.client_id\n        return None\n\n    def get_access_connector(self, subscription_id: str, resource_group_name: str, name: str) -> AccessConnector | None:\n        \"\"\"Get an access connector.\n\n        Docs:\n            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/get?view=rest-databricks-2023-05-01&tabs=HTTP\n        \"\"\"\n        url = f'/subscriptions/{subscription_id}/resourceGroups/{resource_group_name}/providers/Microsoft.Databricks/accessConnectors/{name}'\n        response = self._mgmt.get(url, api_version='2023-05-01')\n        raw = RawResource(response)\n        try:\n            access_connector = AccessConnector.from_raw_resource(raw)\n        except KeyError:\n            logger.warning(f'Tried getting non-existing access connector: {url}')\n            access_connector = None\n        return access_connector\n\n    def list_resources(self, subscription: AzureSubscription, resource_type: str) -> Iterable[RawResource]:\n        \"\"\"List all resources of a type within subscription\"\"\"\n        query = {'api-version': '2020-06-01', '$filter': f\"resourceType eq '{resource_type}'\"}\n        while True:\n            res = self._mgmt.get(f'/subscriptions/{subscription.subscription_id}/resources', query=query)\n            for resource in res['value']:\n                try:\n                    yield RawResource(resource)\n                except KeyError:\n                    logger.warning(f'Could not parse resource: {resource}')\n            next_link = res.get('nextLink', None)\n            if not next_link:\n                break\n            parsed_link = urllib.parse.urlparse(next_link)\n            query = dict(urllib.parse.parse_qsl(parsed_link.query))\n\n    def access_connectors(self) -> Iterable[AccessConnector]:\n        \"\"\"List all access connector within subscription\n\n        Docs:\n            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/list-by-subscription?view=rest-databricks-2023-05-01&tabs=HTTP\n        \"\"\"\n        for subscription in self.subscriptions():\n            for raw in self.list_resources(subscription, 'Microsoft.Databricks/accessConnectors'):\n                try:\n                    yield AccessConnector.from_raw_resource(raw)\n                except KeyError:\n                    logger.warning(f'Could not parse access connec"]
[400.821312, "i", "tor: {raw}')\n\n    def create_or_update_access_connector(self, subscription_id: str, resource_group_name: str, name: str, location: str, tags: dict[str, str] | None, *, wait_for_provisioning: bool=False, wait_for_provisioning_timeout_in_seconds: int=300) -> AccessConnector:\n        \"\"\"Create access connector.\n\n        Docs:\n            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/create-or-update?view=rest-databricks-2023-05-01&tabs=HTTP\n        \"\"\"\n        url = f'/subscriptions/{subscription_id}/resourceGroups/{resource_group_name}/providers/Microsoft.Databricks/accessConnectors/{name}'\n        body = {'location': location, 'identity': {'type': 'SystemAssigned'}}\n        if tags is not None:\n            body['tags'] = tags\n        self._mgmt.put(url, api_version='2023-05-01', body=body)\n        access_connector = self.get_access_connector(subscription_id, resource_group_name, name)\n        start_time = time.time()\n        if access_connector is None or (wait_for_provisioning and access_connector.provisioning_state != 'Succeeded'):\n            if time.time() - start_time > wait_for_provisioning_timeout_in_seconds:\n                raise TimeoutError(f'Timeout waiting for creating or updating access connector: {url}')\n            time.sleep(5)\n            access_connector = self.get_access_connector(subscription_id, resource_group_name, name)\n            assert access_connector is not None\n        return access_connector\n\n    def delete_access_connector(self, url: str) -> None:\n        \"\"\"Delete an access connector.\n\n        Docs:\n            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/delete?view=rest-databricks-2023-05-01&tabs=HTTP\n        \"\"\"\n        self._mgmt.delete(url, api_version='2023-05-01')\nEOF\n"]
[400.821442, "o", "cat > resources.py <<'EOF'\r\n\u001b[?2004l\r"]
[400.821506, "o", "\u001b[?2004h> "]
[400.821571, "o", "import urllib.parse\r\n\u001b[?2004l\r"]
[400.821595, "o", "\u001b[?2004h> "]
[400.821652, "o", "import time\r\n\u001b[?2004l\r\u001b[?2004h> "]
[400.821801, "o", "from collections.abc import Iterable\r\n\u001b[?2004l\r"]
[400.821824, "o", "\u001b[?2004h> "]
[400.821974, "o", "from dataclasses import dataclass, field\r\n\u001b[?2004l\r"]
[400.821998, "o", "\u001b[?2004h> "]
[400.822103, "o", "from datetime import timedelta\r\n\u001b[?2004l\r"]
[400.822127, "o", "\u001b[?2004h> "]
[400.822209, "o", "from typing import Any\r\n\u001b[?2004l\r"]
[400.822233, "o", "\u001b[?2004h> "]
[400.822739, "o", "from databricks.sdk.core import ApiClient, AzureCliTokenSource, Config, CredentialsProvider, CredentialsStrategy, credentials_strategy\r\n\u001b[?2004l\r\u001b[?2004h"]
[400.822799, "o", "> "]
[400.823064, "o", "from databricks.sdk.errors import NotFound, PermissionDenied, ResourceConflict\r\n\u001b[?2004l\r"]
[400.823084, "o", "\u001b[?2004h> "]
[400.823226, "o", "from databricks.sdk.retries import retried\r\n\u001b[?2004l\r"]
[400.823246, "o", "\u001b[?2004h> "]
[400.823434, "o", "from databricks.labs.ucx.assessment.crawlers import logger\r\n\u001b[?2004l\r"]
[400.823453, "o", "\u001b[?2004h> "]
[400.823917, "o", "_ROLES = {'STORAGE_BLOB_DATA_READER': '2a2b9908-6ea1-4ae2-8e65-a410df84e7d1', 'STORAGE_BLOB_DATA_CONTRIBUTOR': 'ba92f5b4-2d11-453d-a403-e96b0029c9fe'}\r\n\u001b[?2004l\r"]
[400.823937, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.823977, "o", "\u001b[?2004h> "]
[400.824009, "o", "@dataclass\r\n\u001b[?2004l\r\u001b[?2004h"]
[400.824028, "o", "> "]
[400.82412, "o", "class AzureSubscription:\r\n\u001b[?2004l\r"]
[400.824138, "o", "\u001b[?2004h> "]
[400.824196, "o", "    name: str\r\n\u001b[?2004l\r"]
[400.824214, "o", "\u001b[?2004h> "]
[400.824315, "o", "    subscription_id: str\r\n\u001b[?2004l\r"]
[400.824333, "o", "\u001b[?2004h> "]
[400.824403, "o", "    tenant_id: str\r\n\u001b[?2004l\r"]
[400.824421, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.824458, "o", "\u001b[?2004h> "]
[400.824525, "o", "class AzureResource:\r\n\u001b[?2004l\r"]
[400.824545, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.824583, "o", "\u001b[?2004h> "]
[400.824698, "o", "    def __init__(self, resource_id: str):\r\n\u001b[?2004l\r"]
[400.824716, "o", "\u001b[?2004h> "]
[400.824826, "o", "        self._pairs = {}\r\n\u001b[?2004l\r"]
[400.824844, "o", "\u001b[?2004h> "]
[400.824974, "o", "        self._resource_id = resource_id\r\n\u001b[?2004l\r"]
[400.824992, "o", "\u001b[?2004h> "]
[400.825155, "o", "        split = resource_id.lstrip('/').split('/')\r\n\u001b[?2004l\r"]
[400.825172, "o", "\u001b[?2004h> "]
[400.82528, "o", "        if len(split) % 2 != 0:\r\n\u001b[?2004l\r"]
[400.825298, "o", "\u001b[?2004h> "]
[400.825476, "o", "            msg = f'not a list of pairs: {resource_id}'\r\n\u001b[?2004l\r"]
[400.825494, "o", "\u001b[?2004h> "]
[400.825597, "o", "            raise ValueError(msg)\r\n\u001b[?2004l\r"]
[400.825616, "o", "\u001b[?2004h> "]
[400.825662, "o", "        i = 0\r\n\u001b[?2004l\r"]
[400.82568, "o", "\u001b[?2004h> "]
[400.825774, "o", "        while i < len(split):\r\n\u001b[?2004l\r"]
[400.825797, "o", "\u001b[?2004h> "]
[400.825879, "o", "            k = split[i]\r\n\u001b[?2004l\r"]
[400.825897, "o", "\u001b[?2004h> "]
[400.825998, "o", "            value = split[i + 1]\r\n\u001b[?2004l\r"]
[400.826016, "o", "\u001b[?2004h> "]
[400.826077, "o", "            i += 2\r\n\u001b[?2004l\r"]
[400.826095, "o", "\u001b[?2004h> "]
[400.826203, "o", "            self._pairs[k] = value\r\n\u001b[?2004l\r"]
[400.826221, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.826257, "o", "\u001b[?2004h> "]
[400.826287, "o", "    @property\r\n\u001b[?2004l\r"]
[400.826306, "o", "\u001b[?2004h> "]
[400.826404, "o", "    def subscription_id(self):\r\n\u001b[?2004l\r"]
[400.826423, "o", "\u001b[?2004h> "]
[400.826568, "o", "        return self._pairs.get('subscriptions')\r\n\u001b[?2004l\r"]
[400.826587, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.826625, "o", "\u001b[?2004h> "]
[400.826652, "o", "    @property\r\n\u001b[?2004l\r"]
[400.826669, "o", "\u001b[?2004h> "]
[400.826763, "o", "    def resource_group(self):\r\n\u001b[?2004l\r"]
[400.826796, "o", "\u001b[?2004h> "]
[400.826941, "o", "        return self._pairs.get('resourceGroups')\r\n\u001b[?2004l\r"]
[400.82696, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.827004, "o", "\u001b[?2004h> "]
[400.827022, "o", "    @property\r\n\u001b[?2004l\r"]
[400.827059, "o", "\u001b[?2004h> "]
[400.827138, "o", "    def storage_account(self):\r\n\u001b[?2004l\r"]
[400.827158, "o", "\u001b[?2004h> "]
[400.827312, "o", "        return self._pairs.get('storageAccounts')\r\n\u001b[?2004l\r"]
[400.827332, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.827369, "o", "\u001b[?2004h> "]
[400.827399, "o", "    @property\r\n\u001b[?2004l\r"]
[400.827416, "o", "\u001b[?2004h> "]
[400.827497, "o", "    def container(self):\r\n\u001b[?2004l\r"]
[400.827515, "o", "\u001b[?2004h> "]
[400.827655, "o", "        return self._pairs.get('containers')\r\n\u001b[?2004l\r"]
[400.827674, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.82771, "o", "\u001b[?2004h> "]
[400.827743, "o", "    @property\r\n\u001b[?2004l\r"]
[400.827782, "o", "\u001b[?2004h> "]
[400.82787, "o", "    def access_connector(self):\r\n\u001b[?2004l\r"]
[400.827891, "o", "\u001b[?2004h> "]
[400.828043, "o", "        return self._pairs.get('accessConnectors')\r\n\u001b[?2004l\r"]
[400.828064, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.828103, "o", "\u001b[?2004h> "]
[400.828169, "o", "    def __eq__(self, other):\r\n\u001b[?2004l\r"]
[400.828192, "o", "\u001b[?2004h> "]
[400.828341, "o", "        if not isinstance(other, AzureResource):\r\n\u001b[?2004l\r"]
[400.828361, "o", "\u001b[?2004h> "]
[400.828463, "o", "            return NotImplemented\r\n\u001b[?2004l\r"]
[400.828486, "o", "\u001b[?2004h> "]
[400.828652, "o", "        return self._resource_id == other._resource_id\r\n\u001b[?2004l\r"]
[400.828673, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.828693, "o", "\u001b[?2004h> "]
[400.828766, "o", "    def __repr__(self):\r\n\u001b[?2004l\r"]
[400.828807, "o", "\u001b[?2004h> "]
[400.829125, "o", "        properties = ['subscription_id', 'resource_group', 'storage_account', 'container', 'access_connector']\r\n\u001b[?2004l\r"]
[400.829149, "o", "\u001b[?2004h> "]
[400.829345, "o", "        pairs = [f'{_}={getattr(self, _)}' for _ in properties]\r\n\u001b[?2004l\r"]
[400.829365, "o", "\u001b[?2004h> "]
[400.829521, "o", "        return f\"AzureResource<{', '.join(pairs)}>\"\r\n\u001b[?2004l\r"]
[400.829541, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.829582, "o", "\u001b[?2004h> "]
[400.829635, "o", "    def __str__(self):\r\n\u001b[?2004l\r"]
[400.829656, "o", "\u001b[?2004h> "]
[400.829756, "o", "        return self._resource_id\r\n\u001b[?2004l\r"]
[400.829781, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.829803, "o", "\u001b[?2004h> "]
[400.829859, "o", "class RawResource:\r\n\u001b[?2004l\r"]
[400.82988, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.829916, "o", "\u001b[?2004h> "]
[400.830078, "o", "    def __init__(self, raw_resource: dict[str, Any]):\r\n\u001b[?2004l\r"]
[400.830107, "o", "\u001b[?2004h> "]
[400.830244, "o", "        if 'id' not in raw_resource:\r\n\u001b[?2004l\r"]
[400.830267, "o", "\u001b[?2004h> "]
[400.830533, "o", "            raise KeyError(\"Raw resource must contain an 'id' field\")\r\n\u001b[?2004l\r"]
[400.830555, "o", "\u001b[?2004h> "]
[400.830765, "o", "        self._id = AzureResource(raw_resource['id'])\r\n\u001b[?2004l\r"]
[400.830791, "o", "\u001b[?2004h> "]
[400.830923, "o", "        self._raw_resource = raw_resource\r\n\u001b[?2004l\r"]
[400.830942, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.830978, "o", "\u001b[?2004h> "]
[400.831023, "o", "    @property\r\n\u001b[?2004l\r"]
[400.831053, "o", "\u001b[?2004h> "]
[400.831168, "o", "    def id(self) -> AzureResource:\r\n\u001b[?2004l\r"]
[400.831191, "o", "\u001b[?2004h> "]
[400.831272, "o", "        return self._id\r\n\u001b[?2004l\r"]
[400.831296, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h"]
[400.831338, "o", "> "]
[400.831467, "o", "    def get(self, key: str, default: Any) -> Any:\r\n\u001b[?2004l\r"]
[400.83149, "o", "\u001b[?2004h> "]
[400.831687, "o", "        return self._raw_resource.get(key, default)\r\n\u001b[?2004l\r"]
[400.83171, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.831751, "o", "\u001b[?2004h> "]
[400.831788, "o", "@dataclass\r\n\u001b[?2004l\r"]
[400.83182, "o", "\u001b[?2004h> "]
[400.831864, "o", "class Principal:\r\n\u001b[?2004l\r"]
[400.831887, "o", "\u001b[?2004h> "]
[400.83195, "o", "    client_id: str\r\n\u001b[?2004l\r"]
[400.831973, "o", "\u001b[?2004h> "]
[400.832044, "o", "    display_name: str\r\n\u001b[?2004l\r"]
[400.832068, "o", "\u001b[?2004h> "]
[400.832134, "o", "    object_id: str\r\n\u001b[?2004l\r"]
[400.832157, "o", "\u001b[?2004h> "]
[400.832209, "o", "    type: str\r\n\u001b[?2004l\r"]
[400.832232, "o", "\u001b[?2004h> "]
[400.832347, "o", "    directory_id: str | None = None\r\n\u001b[?2004l\r"]
[400.83237, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.832411, "o", "\u001b[?2004h> "]
[400.832443, "o", "@dataclass\r\n\u001b[?2004l\r\u001b[?2004h"]
[400.832465, "o", "> "]
[400.832536, "o", "class StorageAccount:\r\n\u001b[?2004l\r"]
[400.832558, "o", "\u001b[?2004h> "]
[400.832631, "o", "    id: AzureResource\r\n\u001b[?2004l\r"]
[400.832653, "o", "\u001b[?2004h> "]
[400.8327, "o", "    name: str\r\n\u001b[?2004l\r"]
[400.832722, "o", "\u001b[?2004h> "]
[400.832797, "o", "    location: str\r\n\u001b[?2004l\r"]
[400.83282, "o", "\u001b[?2004h> "]
[400.832917, "o", "    default_network_action: str\r\n\u001b[?2004l\r"]
[400.832939, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.832979, "o", "\u001b[?2004h> "]
[400.833023, "o", "    @classmethod\r\n\u001b[?2004l\r"]
[400.833046, "o", "\u001b[?2004h> "]
[400.833264, "o", "    def from_raw_resource(cls, raw: RawResource) -> 'StorageAccount':\r\n\u001b[?2004l\r"]
[400.833287, "o", "\u001b[?2004h> "]
[400.833374, "o", "        if raw.id is None:\r\n\u001b[?2004l\r"]
[400.833396, "o", "\u001b[?2004h> "]
[400.833548, "o", "            raise KeyError(f'Missing id: {raw}')\r\n\u001b[?2004l\r"]
[400.833571, "o", "\u001b[?2004h> "]
[400.833687, "o", "        name = raw.get('name', '')\r\n\u001b[?2004l\r"]
[400.83371, "o", "\u001b[?2004h> "]
[400.8338, "o", "        if name == '':\r\n\u001b[?2004l\r"]
[400.833825, "o", "\u001b[?2004h> "]
[400.834003, "o", "            raise KeyError(f'Missing name: {raw}')\r\n\u001b[?2004l\r"]
[400.834025, "o", "\u001b[?2004h> "]
[400.834189, "o", "        location = raw.get('location', '')\r\n\u001b[?2004l\r"]
[400.834212, "o", "\u001b[?2004h> "]
[400.834312, "o", "        if location == '':\r\n\u001b[?2004l\r"]
[400.834334, "o", "\u001b[?2004h> "]
[400.834504, "o", "            raise KeyError(f'Missing location: {raw}')\r\n\u001b[?2004l\r"]
[400.834527, "o", "\u001b[?2004h> "]
[400.83488, "o", "        default_network_action = raw.get('properties', {}).get('networkAcls', {}).get('defaultAction', 'Unknown')\r\n\u001b[?2004l\r"]
[400.834904, "o", "\u001b[?2004h> "]
[400.835264, "o", "        storage_account = cls(id=raw.id, name=name, location=location, default_network_action=default_network_action)\r\n\u001b[?2004l\r"]
[400.835287, "o", "\u001b[?2004h> "]
[400.835399, "o", "        return storage_account\r\n\u001b[?2004l\r"]
[400.835421, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.835462, "o", "\u001b[?2004h> "]
[400.835484, "o", "@dataclass\r\n\u001b[?2004l\r\u001b[?2004h"]
[400.835525, "o", "> "]
[400.835579, "o", "class PrincipalSecret:\r\n\u001b[?2004l\r"]
[400.835601, "o", "\u001b[?2004h> "]
[400.835672, "o", "    client: Principal\r\n\u001b[?2004l\r"]
[400.835695, "o", "\u001b[?2004h> "]
[400.835754, "o", "    secret: str\r\n\u001b[?2004l\r"]
[400.83578, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.835809, "o", "\u001b[?2004h> "]
[400.83586, "o", "@dataclass\r\n\u001b[?2004l\r\u001b[?2004h> "]
[400.835947, "o", "class AzureRoleAssignment:\r\n\u001b[?2004l\r"]
[400.835978, "o", "\u001b[?2004h> "]
[400.836009, "o", "    id: str\r\n\u001b[?2004l\r"]
[400.836031, "o", "\u001b[?2004h> "]
[400.836123, "o", "    resource: AzureResource\r\n\u001b[?2004l\r"]
[400.836146, "o", "\u001b[?2004h> "]
[400.836228, "o", "    scope: AzureResource\r\n\u001b[?2004l\r"]
[400.836251, "o", "\u001b[?2004h> "]
[400.836344, "o", "    principal: Principal\r\n\u001b[?2004l\r"]
[400.836366, "o", "\u001b[?2004h> "]
[400.83643, "o", "    role_name: str\r\n\u001b[?2004l\r"]
[400.836452, "o", "\u001b[?2004h> "]
[400.836514, "o", "    role_type: str\r\n\u001b[?2004l\r"]
[400.836535, "o", "\u001b[?2004h> "]
[400.836638, "o", "    role_permissions: list[str]\r\n\u001b[?2004l\r"]
[400.83666, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.8367, "o", "\u001b[?2004h> "]
[400.836722, "o", "@dataclass\r\n\u001b[?2004l\r\u001b[?2004h"]
[400.836762, "o", "> "]
[400.836824, "o", "class AzureRoleDetails:\r\n\u001b[?2004l\r"]
[400.836859, "o", "\u001b[?2004h> "]
[400.836928, "o", "    role_name: str | None\r\n\u001b[?2004l\r"]
[400.836951, "o", "\u001b[?2004h> "]
[400.837026, "o", "    role_type: str\r\n\u001b[?2004l\r"]
[400.837048, "o", "\u001b[?2004h> "]
[400.837171, "o", "    role_permissions: list[str]\r\n\u001b[?2004l\r"]
[400.837194, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.837235, "o", "\u001b[?2004h> "]
[400.837257, "o", "@dataclass\r\n\u001b[?2004l\r"]
[400.837298, "o", "\u001b[?2004h> "]
[400.837362, "o", "class AccessConnector:\r\n\u001b[?2004l\r"]
[400.837383, "o", "\u001b[?2004h> "]
[400.837456, "o", "    id: AzureResource\r\n\u001b[?2004l\r"]
[400.837478, "o", "\u001b[?2004h> "]
[400.837525, "o", "    name: str\r\n\u001b[?2004l\r"]
[400.837547, "o", "\u001b[?2004h> "]
[400.837606, "o", "    location: str\r\n\u001b[?2004l\r"]
[400.837628, "o", "\u001b[?2004h> "]
[400.837735, "o", "    provisioning_state: str\r\n\u001b[?2004l\r"]
[400.837756, "o", "\u001b[?2004h> "]
[400.837851, "o", "    identity_type: str\r\n\u001b[?2004l\r"]
[400.837873, "o", "\u001b[?2004h> "]
[400.837945, "o", "    principal_id: str\r\n\u001b[?2004l\r"]
[400.837966, "o", "\u001b[?2004h> "]
[400.838109, "o", "    managed_identity_type: str | None = None\r\n\u001b[?2004l\r"]
[400.838131, "o", "\u001b[?2004h> "]
[400.838236, "o", "    client_id: str | None = None\r\n\u001b[?2004l\r"]
[400.838259, "o", "\u001b[?2004h> "]
[400.838362, "o", "    tenant_id: str | None = None\r\n\u001b[?2004l\r"]
[400.838384, "o", "\u001b[?2004h> "]
[400.838594, "o", "    tags: dict[str, str] = field(default_factory=dict)\r\n\u001b[?2004l\r"]
[400.838616, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.838656, "o", "\u001b[?2004h> "]
[400.838695, "o", "    @classmethod\r\n\u001b[?2004l\r"]
[400.838718, "o", "\u001b[?2004h> "]
[400.838958, "o", "    def from_raw_resource(cls, raw: RawResource) -> 'AccessConnector':\r\n\u001b[?2004l\r\u001b[?2004h"]
[400.839004, "o", "> "]
[400.83906, "o", "        if raw.id is None:\r\n\u001b[?2004l\r"]
[400.839083, "o", "\u001b[?2004h> "]
[400.839237, "o", "            raise KeyError(f'Missing id: {raw}')\r\n\u001b[?2004l\r"]
[400.839261, "o", "\u001b[?2004h> "]
[400.839395, "o", "        name = raw.get('name', '')\r\n\u001b[?2004l\r"]
[400.839418, "o", "\u001b[?2004h> "]
[400.839493, "o", "        if name == '':\r\n\u001b[?2004l\r"]
[400.839516, "o", "\u001b[?2004h> "]
[400.839674, "o", "            raise KeyError(f'Missing name: {raw}')\r\n\u001b[?2004l\r"]
[400.839697, "o", "\u001b[?2004h> "]
[400.839863, "o", "        location = raw.get('location', '')\r\n\u001b[?2004l\r"]
[400.839886, "o", "\u001b[?2004h> "]
[400.83997, "o", "        if location == '':\r\n\u001b[?2004l\r"]
[400.839992, "o", "\u001b[?2004h> "]
[400.840201, "o", "            raise KeyError(f'Missing location: {raw}')\r\n\u001b[?2004l\r"]
[400.840224, "o", "\u001b[?2004h> "]
[400.84054, "o", "        provisioning_state = raw.get('properties', {}).get('provisioningState', '')\r\n\u001b[?2004l\r"]
[400.840562, "o", "\u001b[?2004h> "]
[400.8407, "o", "        if provisioning_state == '':\r\n\u001b[?2004l\r"]
[400.840722, "o", "\u001b[?2004h> "]
[400.84093, "o", "            raise KeyError(f'Missing provisioning state: {raw}')\r\n\u001b[?2004l\r"]
[400.840953, "o", "\u001b[?2004h> "]
[400.841112, "o", "        identity = raw.get('identity', {})\r\n\u001b[?2004l\r"]
[400.841135, "o", "\u001b[?2004h> "]
[400.841275, "o", "        identity_type = identity.get('type')\r\n\u001b[?2004l\r"]
[400.841297, "o", "\u001b[?2004h> "]
[400.841457, "o", "        principal_id = identity.get('principalId')\r\n\u001b[?2004l\r"]
[400.84148, "o", "\u001b[?2004h> "]
[400.841682, "o", "        managed_identity_type = identity.get('type')\r\n\u001b[?2004l\r"]
[400.841705, "o", "\u001b[?2004h> "]
[400.841802, "o", "        client_id = None\r\n\u001b[?2004l\r"]
[400.841825, "o", "\u001b[?2004h> "]
[400.841916, "o", "        tenant_id = None\r\n\u001b[?2004l\r"]
[400.841939, "o", "\u001b[?2004h> "]
[400.842132, "o", "        if identity.get('type') == 'UserAssigned':\r\n\u001b[?2004l\r"]
[400.842155, "o", "\u001b[?2004h> "]
[400.842328, "o", "            if not user_assigned_identity_id:\r\n\u001b[?2004l\r"]
[400.84235, "o", "\u001b[?2004h> "]
[400.842454, "o", "                return None\r\n\u001b[?2004l\r"]
[400.842476, "o", "\u001b[?2004h> "]
[400.842716, "o", "            identities = identity.get('userAssignedIdentities')\r\n\u001b[?2004l\r"]
[400.842739, "o", "\u001b[?2004h> "]
[400.84296, "o", "            if user_assigned_identity_id in identities:\r\n\u001b[?2004l\r"]
[400.842985, "o", "\u001b[?2004h> "]
[400.843291, "o", "                return identities.get(user_assigned_identity_id).get('clientId')\r\n\u001b[?2004l\r"]
[400.843314, "o", "\u001b[?2004h> "]
[400.843731, "o", "            alternative_identity_id = user_assigned_identity_id.replace('resourcegroups', 'resourceGroups')\r\n\u001b[?2004l\r"]
[400.843754, "o", "\u001b[?2004h> "]
[400.843957, "o", "            if alternative_identity_id in identities:\r\n\u001b[?2004l\r"]
[400.843979, "o", "\u001b[?2004h> "]
[400.844258, "o", "                return identities.get(alternative_identity_id).get('clientId')\r\n\u001b[?2004l\r"]
[400.844281, "o", "\u001b[?2004h> "]
[400.84437, "o", "            return None\r\n\u001b[?2004l\r"]
[400.844393, "o", "\u001b[?2004h> "]
[400.844596, "o", "        if identity.get('type') == 'SystemAssigned':\r\n\u001b[?2004l\r"]
[400.844619, "o", "\u001b[?2004h> "]
[400.844896, "o", "            principal = self._get_principal(identity.get('principalId'))\r\n\u001b[?2004l\r"]
[400.844918, "o", "\u001b[?2004h> "]
[400.845012, "o", "            if not principal:\r\n\u001b[?2004l\r"]
[400.845044, "o", "\u001b[?2004h> "]
[400.845138, "o", "                return None\r\n\u001b[?2004l\r"]
[400.84516, "o", "\u001b[?2004h> "]
[400.845304, "o", "            return principal.client_id\r\n\u001b[?2004l\r"]
[400.845326, "o", "\u001b[?2004h> "]
[400.845379, "o", "        return None\r\n\u001b[?2004l\r"]
[400.845401, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.845441, "o", "\u001b[?2004h> "]
[400.845723, "o", "    def get_access_connector(self, subscription_id: str, resource_group_name: str, name: str) -> AccessConnector | None:\r\n\u001b[?2004l\r"]
[400.845744, "o", "\u001b[?2004h> "]
[400.845842, "o", "        \"\"\"Get an access connector.\r\n\u001b[?2004l\r"]
[400.845863, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.845903, "o", "\u001b[?2004h> "]
[400.845925, "o", "        Docs:\r\n\u001b[?2004l\r"]
[400.845965, "o", "\u001b[?2004h> "]
[400.846276, "o", "            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/get?view=rest-databricks-2023-05-01&tabs=HTTP\r\n\u001b[?2004l\r"]
[400.846298, "o", "\u001b[?2004h> "]
[400.846338, "o", "        \"\"\"\r\n\u001b[?2004l\r"]
[400.84636, "o", "\u001b[?2004h> "]
[400.846711, "o", "        url = f'/subscriptions/{subscription_id}/resourceGroups/{resource_group_name}/providers/Microsoft.Databricks/accessConnectors/{name}'\r\n\u001b[?2004l\r"]
[400.846734, "o", "\u001b[?2004h> "]
[400.846902, "o", "        response = self._mgmt.get(url, api_version='2023-05-01')\r\n\u001b[?2004l\r"]
[400.846925, "o", "\u001b[?2004h> "]
[400.847014, "o", "        raw = RawResource(response)\r\n\u001b[?2004l\r"]
[400.847037, "o", "\u001b[?2004h> "]
[400.847078, "o", "        try:\r\n\u001b[?2004l\r\u001b[?2004h"]
[400.847101, "o", "> "]
[400.84727, "o", "            access_connector = AccessConnector.from_raw_resource(raw)\r\n\u001b[?2004l\r"]
[400.847293, "o", "\u001b[?2004h> "]
[400.847357, "o", "        except KeyError:\r\n\u001b[?2004l\r"]
[400.847379, "o", "\u001b[?2004h> "]
[400.847583, "o", "            logger.warning(f'Tried getting non-existing access connector: {url}')\r\n\u001b[?2004l\r"]
[400.847605, "o", "\u001b[?2004h> "]
[400.847696, "o", "            access_connector = None\r\n\u001b[?2004l\r"]
[400.84772, "o", "\u001b[?2004h> "]
[400.847805, "o", "        return access_connector\r\n\u001b[?2004l\r"]
[400.847827, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.847868, "o", "\u001b[?2004h> "]
[400.848115, "o", "    def list_resources(self, subscription: AzureSubscription, resource_type: str) -> Iterable[RawResource]:\r\n\u001b[?2004l\r"]
[400.848136, "o", "\u001b[?2004h> "]
[400.848295, "o", "        \"\"\"List all resources of a type within subscription\"\"\"\r\n\u001b[?2004l\r"]
[400.848317, "o", "\u001b[?2004h> "]
[400.848553, "o", "        query = {'api-version': '2020-06-01', '$filter': f\"resourceType eq '{resource_type}'\"}\r\n\u001b[?2004l\r"]
[400.848574, "o", "\u001b[?2004h> "]
[400.848628, "o", "        while True:\r\n\u001b[?2004l\r"]
[400.84865, "o", "\u001b[?2004h> "]
[400.848917, "o", "            res = self._mgmt.get(f'/subscriptions/{subscription.subscription_id}/resources', query=query)\r\n\u001b[?2004l\r"]
[400.848939, "o", "\u001b[?2004h> "]
[400.849045, "o", "            for resource in res['value']:\r\n\u001b[?2004l\r"]
[400.849067, "o", "\u001b[?2004h> "]
[400.849121, "o", "                try:\r\n\u001b[?2004l\r"]
[400.849143, "o", "\u001b[?2004h> "]
[400.849268, "o", "                    yield RawResource(resource)\r\n\u001b[?2004l\r"]
[400.849289, "o", "\u001b[?2004h> "]
[400.849374, "o", "                except KeyError:\r\n\u001b[?2004l\r"]
[400.849396, "o", "\u001b[?2004h> "]
[400.849584, "o", "                    logger.warning(f'Could not parse resource: {resource}')\r\n\u001b[?2004l\r"]
[400.849606, "o", "\u001b[?2004h> "]
[400.849732, "o", "            next_link = res.get('nextLink', None)\r\n\u001b[?2004l\r"]
[400.849754, "o", "\u001b[?2004h> "]
[400.849837, "o", "            if not next_link:\r\n\u001b[?2004l\r"]
[400.849874, "o", "\u001b[?2004h> "]
[400.849911, "o", "                break\r\n\u001b[?2004l\r"]
[400.849933, "o", "\u001b[?2004h> "]
[400.850082, "o", "            parsed_link = urllib.parse.urlparse(next_link)\r\n\u001b[?2004l\r"]
[400.850104, "o", "\u001b[?2004h> "]
[400.850277, "o", "            query = dict(urllib.parse.parse_qsl(parsed_link.query))\r\n\u001b[?2004l\r"]
[400.850299, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.85034, "o", "\u001b[?2004h> "]
[400.850483, "o", "    def access_connectors(self) -> Iterable[AccessConnector]:\r\n\u001b[?2004l\r"]
[400.850506, "o", "\u001b[?2004h> "]
[400.850648, "o", "        \"\"\"List all access connector within subscription\r\n\u001b[?2004l\r"]
[400.850671, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.850711, "o", "\u001b[?2004h> "]
[400.850733, "o", "        Docs:\r\n\u001b[?2004l\r"]
[400.850773, "o", "\u001b[?2004h> "]
[400.851127, "o", "            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/list-by-subscription?view=rest-databricks-2023-05-01&tabs=HTTP\r\n\u001b[?2004l\r"]
[400.851156, "o", "\u001b[?2004h> "]
[400.851203, "o", "        \"\"\"\r\n\u001b[?2004l\r\u001b[?2004h> "]
[400.851334, "o", "        for subscription in self.subscriptions():\r\n\u001b[?2004l\r"]
[400.851361, "o", "\u001b[?2004h> "]
[400.851605, "o", "            for raw in self.list_resources(subscription, 'Microsoft.Databricks/accessConnectors'):\r\n\u001b[?2004l\r"]
[400.851632, "o", "\u001b[?2004h> "]
[400.851678, "o", "                try:\r\n\u001b[?2004l\r"]
[400.851704, "o", "\u001b[?2004h> "]
[400.851865, "o", "                    yield AccessConnector.from_raw_resource(raw)\r\n\u001b[?2004l\r"]
[400.851892, "o", "\u001b[?2004h> "]
[400.851972, "o", "                except KeyError:\r\n\u001b[?2004l\r"]
[400.851999, "o", "\u001b[?2004h> "]
[400.852192, "o", "                    logger.warning(f'Could not parse access connector: {raw}')\r\n\u001b[?2004l\r"]
[400.852215, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.852258, "o", "\u001b[?2004h> "]
[400.852886, "o", "    def create_or_update_access_connector(self, subscription_id: str, resource_group_name: str, name: str, location: str, tags: dict[str, str] | None, *, wait_for_provisioning: bool=False, wait_for_provisioning_timeout_in_seconds: int=300) -> AccessConnector:\r\n\u001b[?2004l\r"]
[400.852909, "o", "\u001b[?2004h> "]
[400.853001, "o", "        \"\"\"Create access connector.\r\n\u001b[?2004l\r"]
[400.853023, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.853065, "o", "\u001b[?2004h> "]
[400.853087, "o", "        Docs:\r\n\u001b[?2004l\r"]
[400.853128, "o", "\u001b[?2004h> "]
[400.853458, "o", "            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/create-or-update?view=rest-databricks-2023-05-01&tabs=HTTP\r\n\u001b[?2004l\r"]
[400.85348, "o", "\u001b[?2004h> "]
[400.853522, "o", "        \"\"\"\r\n\u001b[?2004l\r\u001b[?2004h> "]
[400.853885, "o", "        url = f'/subscriptions/{subscription_id}/resourceGroups/{resource_group_name}/providers/Microsoft.Databricks/accessConnectors/{name}'\r\n\u001b[?2004l\r"]
[400.853908, "o", "\u001b[?2004h> "]
[400.854103, "o", "        body = {'location': location, 'identity': {'type': 'SystemAssigned'}}\r\n\u001b[?2004l\r"]
[400.854125, "o", "\u001b[?2004h> "]
[400.854199, "o", "        if tags is not None:\r\n\u001b[?2004l\r"]
[400.85422, "o", "\u001b[?2004h> "]
[400.854303, "o", "            body['tags'] = tags\r\n\u001b[?2004l\r"]
[400.854325, "o", "\u001b[?2004h> "]
[400.854514, "o", "        self._mgmt.put(url, api_version='2023-05-01', body=body)\r\n\u001b[?2004l\r\u001b[?2004h> "]
[400.854767, "o", "        access_connector = self.get_access_connector(subscription_id, resource_group_name, name)\r\n\u001b[?2004l\r"]
[400.854812, "o", "\u001b[?2004h> "]
[400.85489, "o", "        start_time = time.time()\r\n\u001b[?2004l\r"]
[400.854923, "o", "\u001b[?2004h> "]
[400.855222, "o", "        if access_connector is None or (wait_for_provisioning and access_connector.provisioning_state != 'Succeeded'):\r\n\u001b[?2004l\r"]
[400.855245, "o", "\u001b[?2004h> "]
[400.855464, "o", "            if time.time() - start_time > wait_for_provisioning_timeout_in_seconds:\r\n\u001b[?2004l\r"]
[400.855498, "o", "\u001b[?2004h> "]
[400.855765, "o", "                raise TimeoutError(f'Timeout waiting for creating or updating access connector: {url}')\r\n\u001b[?2004l\r"]
[400.855802, "o", "\u001b[?2004h> "]
[400.855876, "o", "            time.sleep(5)\r\n\u001b[?2004l\r"]
[400.855911, "o", "\u001b[?2004h> "]
[400.85616, "o", "            access_connector = self.get_access_connector(subscription_id, resource_group_name, name)\r\n\u001b[?2004l\r"]
[400.856183, "o", "\u001b[?2004h> "]
[400.856316, "o", "            assert access_connector is not None\r\n\u001b[?2004l\r"]
[400.856338, "o", "\u001b[?2004h> "]
[400.856427, "o", "        return access_connector\r\n\u001b[?2004l\r"]
[400.856449, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.856488, "o", "\u001b[?2004h> "]
[400.856632, "o", "    def delete_access_connector(self, url: str) -> None:\r\n\u001b[?2004l\r"]
[400.856654, "o", "\u001b[?2004h> "]
[400.856764, "o", "        \"\"\"Delete an access connector.\r\n\u001b[?2004l\r"]
[400.856795, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r"]
[400.856818, "o", "\u001b[?2004h> "]
[400.856868, "o", "        Docs:\r\n\u001b[?2004l\r"]
[400.85689, "o", "\u001b[?2004h> "]
[400.857232, "o", "            https://learn.microsoft.com/en-us/rest/api/databricks/access-connectors/delete?view=rest-databricks-2023-05-01&tabs=HTTP\r\n\u001b[?2004l\r"]
[400.857254, "o", "\u001b[?2004h> "]
[400.857299, "o", "        \"\"\"\r\n\u001b[?2004l\r"]
[400.857331, "o", "\u001b[?2004h> "]
[400.857482, "o", "        self._mgmt.delete(url, api_version='2023-05-01')\r\n\u001b[?2004l\r"]
[400.857505, "o", "\u001b[?2004h> "]
[400.857542, "o", "EOF\r\n\u001b[?2004l\r"]
[400.858924, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/src/databricks/labs/ucx/azure# "]
[401.778689, "i", "cd /workspace/repo/tests/unit/azure\n"]
[401.7789, "o", "cd /workspace/repo/tests/unit/azure\r\n\u001b[?2004l\r"]
[401.779009, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/tests/unit/azure# "]
[402.294192, "i", "pytest tests/unit/azure/test_resources.py::test_azure_client_api_delete_spn -v\n"]
[402.29459, "o", "pytest tests/unit/azure/test_resources.py::test_azure_client_api_delete_spn -v\r\n\u001b[?2004l\r"]
[403.035436, "o", "\u001b[31mImportError while loading conftest '/workspace/repo/tests/unit/conftest.py'.\u001b[0m\r\n"]
[403.139486, "o", "\u001b[31m../conftest.py:23: in <module>\u001b[0m\r\n\u001b[31m    from databricks.labs.ucx.contexts.workflow_task import RuntimeContext\u001b[0m\r\n\u001b[31m../../../src/databricks/labs/ucx/contexts/workflow_task.py:23: in <module>\u001b[0m\r\n\u001b[31m    from databricks.labs.ucx.contexts.application import GlobalContext\u001b[0m\r\n\u001b[31m../../../src/databricks/labs/ucx/contexts/application.py:38: in <module>\u001b[0m\r\n\u001b[31m    from databricks.labs.ucx.hive_metastore.catalog_schema import CatalogSchema\u001b[0m\r\n\u001b[31m../../../src/databricks/labs/ucx/hive_metastore/catalog_schema.py:12: in <module>\u001b[0m\r\n\u001b[31m    from databricks.labs.ucx.hive_metastore.grants import MigrateGrants\u001b[0m\r\n\u001b[31m../../../src/databricks/labs/ucx/hive_metastore/grants.py:30: in <module>\u001b[0m\r\n\u001b[31m    from databricks.labs.ucx.azure.access import (\u001b[0m\r\n"]
[403.139598, "o", "\u001b[31m../../../src/databricks/labs/ucx/azure/access.py:38: in <module>\u001b[0m\r\n\u001b[31m    from databricks.labs.ucx.azure.resources import (\u001b[0m\r\n\u001b[31m../../../src/databricks/labs/ucx/azure/resources.py:134: in <module>\u001b[0m\r\n\u001b[31m    class AccessConnector:\u001b[0m\r\n\u001b[31m../../../src/databricks/labs/ucx/azure/resources.py:182: in AccessConnector\u001b[0m\r\n\u001b[31m    def get_access_connector(self, subscription_id: str, resource_group_name: str, name: str) -> AccessConnector | None:\u001b[0m\r\n\u001b[31mE   NameError: name 'AccessConnector' is not defined\u001b[0m\r\n"]
[403.252795, "o", "\u001b[?2004hroot@bc4f9015-dd8b-49bb-a762-ee6c1a2231b2:/workspace/repo/tests/unit/azure# "]
