[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo# asciinema rec --stdin /logs/agent/recording.cast
[?2004l[0;32masciinema: recording asciicast to /logs/agent/recording.cast[0m
[0;32masciinema: press <ctrl-d> or type "exit" when you're done[0m
[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo# clear
[?2004l[H[J[3J[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo# ls -la
[?2004ltotal 308
drwxr-xr-x 1 root root     36 Feb  9 20:25 .
drwxr-xr-x 1 root root     26 Feb  9 20:25 ..
-rw-rw-r-- 1 root root    353 Jan 21 13:43 .codecov.yml
-rw-rw-r-- 1 root root     54 Jan 21 13:43 .dockerignore
-rw-rw-r-- 1 root root    168 Jan 21 13:43 .flake8
drwxr-xr-x 3 root root     31 Feb  9 20:25 .github
-rw-rw-r-- 1 root root    489 Jan 21 13:43 .gitignore
-rw-rw-r-- 1 root root    163 Jan 21 13:43 .readthedocs.yaml
-rw-rw-r-- 1 root root  21099 Jan 21 13:43 CHANGELOG.txt
-rw-rw-r-- 1 root root   3332 Jan 21 13:43 CODE_OF_CONDUCT.md
-rw-rw-r-- 1 root root    344 Jan 21 13:43 Dockerfile
-rw-rw-r-- 1 root root   1063 Jan 21 13:43 LICENSE
-rw-rw-r-- 1 root root    574 Jan 21 13:43 Makefile
-rw-rw-r-- 1 root root  26370 Jan 21 13:43 README.md
drwxr-xr-x 2 root root    105 Feb  9 20:25 bench
drwxr-xr-x 2 root root   4096 Feb  9 20:25 docs
drwxr-xr-x 2 root root   4096 Feb  9 20:25 examples
-rw-rw-r-- 1 root root    592 Jan 21 13:43 mypy.ini
drwxr-xr-x 2 root root   4096 Feb  9 20:25 pyais
drwxr-xr-x 1 root root    162 Feb  9 20:26 pyais.egg-info
-rw-rw-r-- 1 root root   1580 Jan 21 13:43 pyproject.toml
-rw-rw-r-- 1 root root     39 Jan 21 13:43 pyrightconfig.json
-rw-rw-r-- 1 root root    241 Jan 21 13:43 requirements.txt
drwxr-xr-x 3 root root   4096 Feb  9 20:25 tests
-rw-rw-r-- 1 root root 190128 Jan 21 13:43 uv.lock
[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo# cd pyais
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# ls -la
[?2004ltotal 212
drwxr-xr-x 2 root root  4096 Feb  9 20:25 .
drwxr-xr-x 1 root root    36 Feb  9 20:25 ..
-rw-rw-r-- 1 root root   705 Jan 21 13:43 __init__.py
-rw-rw-r-- 1 root root  7503 Jan 21 13:43 ais_decode.py
-rw-rw-r-- 1 root root  5829 Jan 21 13:43 ais_encode.py
-rw-rw-r-- 1 root root   826 Jan 21 13:43 ais_types.py
-rw-rw-r-- 1 root root 17908 Jan 21 13:43 constants.py
-rw-rw-r-- 1 root root  4392 Jan 21 13:43 decode.py
-rw-rw-r-- 1 root root  5177 Jan 21 13:43 encode.py
-rw-rw-r-- 1 root root  1117 Jan 21 13:43 exceptions.py
-rw-rw-r-- 1 root root  8534 Jan 21 13:43 filter.py
-rw-rw-r-- 1 root root 77303 Jan 21 13:43 messages.py
-rw-rw-r-- 1 root root     0 Jan 21 13:43 py.typed
-rw-rw-r-- 1 root root  3800 Jan 21 13:43 queue.py
-rw-rw-r-- 1 root root 20163 Jan 21 13:43 stream.py
-rw-rw-r-- 1 root root 13014 Jan 21 13:43 tracker.py
-rw-rw-r-- 1 root root 15332 Jan 21 13:43 util.py
[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# nano util.py
[?2004lbash: nano: command not found
[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# vi util.py
[?2004lbash: vi: command not found
[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# cat util.py
[?2004limport base64
import math
import typing
from collections import OrderedDict
from functools import partial, reduce
from operator import xor
from typing import Any, Generator, Hashable, TYPE_CHECKING, Union, Dict
from bitarray import bitarray
from pyais.constants import COUNTRY_MAPPING, SyncState
from pyais.exceptions import NonPrintableCharacterException
if TYPE_CHECKING:
    BaseDict = OrderedDict[Hashable, Any]
else:
    BaseDict = OrderedDict
from_bytes = partial(int.from_bytes, byteorder='big')
from_bytes_signed = partial(int.from_bytes, byteorder='big', signed=True)
T = typing.TypeVar('T')

def decode_into_bit_array(data: bytes, fill_bits: int=0) -> bitarray:
    """
    Decodes a raw AIS message into a bitarray.
    :param data:        Raw AIS message in bytes
    :param fill_bits:   Number of trailing fill bits to be ignored
    :return:
    """
    bit_str = ''
    length = len(data)
    for (i, c) in enumerate(data):
        if not 32 <= c <= 126:
            raise NonPrintableCharacterException(f"Non printable character: '{hex(c)}'")
        c -= 48 if c < 96 else 56
        c &= 63
        if i == length - 1 and fill_bits:
            c = c >> fill_bits
            bit_str += f'{c:b}'.zfill(6 - fill_bits)
        else:
            bit_str += f'{c:06b}'
    bit_arr = bitarray(bit_str)
    return bit_arr

def chunks(sequence: typing.Sequence[T], n: int) -> Generator[typing.Sequence[T], None, None]:
    """Yield successive n-sized chunks from sequence."""
    return (sequence[i:i + n] for i in range(0, len(sequence), n))

def decode_bin_as_ascii6(bit_arr: bitarray) -> str:
    """
    Decode binary data as 6 bit ASCII.
    :param bit_arr: array of bits
    :return: ASCII String
    """
    string: str = ''
    c: bitarray
    for c in chunks(bit_arr, 6):
        n: int = from_bytes(c.tobytes()) >> 2
        if len(c) != 6:
            n >>= 6 - len(c)
        if n < 32:
            n += 64
        if n == 64:
            break
        string += chr(n)
    return string.strip()

def get_int(data: bitarray, ix_low: int, ix_high: int, signed: bool=False) -> int:
    """
    Cast a subarray of a bitarray into an integer.
    The bitarray module adds tailing zeros when calling tobytes(), if the bitarray is not a multiple of 8.
    So those need to be shifted away.
    :param data: some bitarray
    :param ix_low: the lower index of the sub-array
    :param ix_high: the upper index of the sub-array
    :param signed: True if the value should be interpreted as a signed integer
    :return: a normal integer (int)
    """
    shift: int = (8 - (ix_high - ix_low) % 8) % 8
    data = data[ix_low:ix_high]
    i: int = from_bytes_signed(data) if signed else from_bytes(data)
    return i >> shift

def checksum(sentence: bytes) -> int:
    """
    Compute the NMEA checksum for a payload.
    :param sentence: The sentence to compute the checksum for. MUST BE bytes.

    >>> checksum(b's:2573535,c:1671533231')
    8
    """
    checksum = reduce(xor, sentence)
    return checksum

def compute_checksum(msg: Union[str, bytes]) -> int:
    """
    Compute the checksum of a given message.
    This method takes the **whole** message including the leading `!`.

    >>> compute_checksum(b"!AIVDM,1,1,,B,15M67FC000G?ufbE`FepT@3n00Sa,0")
    91

    :param msg: message
    :return: int value of the checksum. Format as hex with `f'{checksum:02x}'`
    """
    if isinstance(msg, str):
        msg = msg.encode()
    msg = msg[1:].split(b'*', 1)[0]
    return reduce(xor, msg)
PAYLOAD_ARMOR = {0: '0', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: ':', 11: ';', 12: '<', 13: '=', 14: '>', 15: '?', 16: '@', 17: 'A', 18: 'B', 19: 'C', 20: 'D', 21: 'E', 22: 'F', 23: 'G', 24: 'H', 25: 'I', 26: 'J', 27: 'K', 28: 'L', 29: 'M', 30: 'N', 31: 'O', 32: 'P', 33: 'Q', 34: 'R', 35: 'S', 36: 'T', 37: 'U', 38: 'V', 39: 'W', 40: '`', 41: 'a', 42: 'b', 43: 'c', 44: 'd', 45: 'e', 46: 'f', 47: 'g', 48: 'h', 49: 'i', 50: 'j', 51: 'k', 52: 'l', 53: 'm', 54: 'n', 55: 'o', 56: 'p', 57: 'q', 58: 'r', 59: 's', 60: 't', 61: 'u', 62: 'v', 63: 'w'}
SIX_BIT_ENCODING = {'@': 0, 'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5, 'F': 6, 'G': 7, 'H': 8, 'I': 9, 'J': 10, 'K': 11, 'L': 12, 'M': 13, 'N': 14, 'O': 15, 'P': 16, 'Q': 17, 'R': 18, 'S': 19, 'T': 20, 'U': 21, 'V': 22, 'W': 23, 'X': 24, 'Y': 25, 'Z': 26, '[': 27, '\\': 28, ']': 29, '^': 30, '_': 31, ' ': 32, '!': 33, '"': 34, '#': 35, '$': 36, '%': 37, '&': 38, "'": 39, '(': 40, ')': 41, '*': 42, '+': 43, ',': 44, '-': 45, '.': 46, '/': 47, '0': 48, '1': 49, '2': 50, '3': 51, '4': 52, '5': 53, '6': 54, '7': 55, '8': 56, '9': 57, ':': 58, ';': 59, '<': 60, '=': 61, '>': 62, '?': 63}

def to_six_bit(char: str) -> str:
    """
    Encode a single character as six-bit bitstring.
    @param char: The character to encode
    @return: The six-bit representation as string
    """
    char = char.upper()
    try:
        encoding = SIX_BIT_ENCODING[char]
        return f'{encoding:06b}'
    except KeyError:
        raise ValueError(f"received char '{char}' that cant be encoded")

def encode_ascii_6(bits: bitarray) -> typing.Tuple[str, int]:
    """
    Transform the bitarray to an ASCII-encoded bit vector.
    Each character represents six bits of data.
    @param bits: The bitarray to convert to an ASCII-encoded bit vector.
    @return: ASCII-encoded bit vector and the number of fill bits required to pad the data payload to a 6 bit boundary.
    """
    out = ''
    chunk: bitarray
    padding = 0
    for chunk in chunks(bits, 6):
        padding = 6 - len(chunk)
        num = from_bytes(chunk.tobytes()) >> 2
        armor = PAYLOAD_ARMOR[num]
        out += armor
    return (out, padding)

def int_to_bytes(val: typing.Union[int, bytes]) -> int:
    """
    Convert a bytes object to an integer. Byteorder is big.

    @param val: A bytes object to convert to an int. If the value is already an int, this is a NO-OP.
    @return: Integer representation of `val`
    """
    if isinstance(val, int):
        return val
    return int.from_bytes(val, 'big')

def bits2bytes(bits: typing.Union[str, bitarray]) -> bytes:
    """
    Convert a bitstring or a bitarray to bytes.
    >>> bits2bytes('00100110')
    b'&'
    """
    bits = bitarray(bits)
    return bits.tobytes()

def bytes2bits(in_bytes: bytes, default: typing.Optional[bitarray]=None) -> bitarray:
    """
    TODO: Implement this function
    """
    ...

def b64encode_str(val: bytes, encoding: str='utf-8') -> str:
    """BASE64 encoded a bytes string and returns the result as UTF-8 string"""
    return base64.b64encode(val).decode(encoding)

def coerce_val(val: typing.Any, d_type: typing.Type[T]) -> T:
    """Forces a given value in a given datatype"""
    if d_type == bytes and (not isinstance(val, bytes)):
        raise ValueError(f'Expected bytes, but got: {type(val)}')
    return d_type(val)

def int_to_bin(val: typing.Union[int, bool], width: int, signed: bool=True) -> bitarray:
    """
    Convert an integer or boolean value to binary. If the value is too great to fit into
    `width` bits, the maximum possible number that still fits is used.

    @param val:     Any integer or boolean value.
    @param width:   The bit width. If less than width bits are required, leading zeros are added.
    @param signed:  Set to True/False if the value is signed or not.
    @return:        The binary representation of value with exactly width bits. Type is bitarray.
    """
    (n_bytes, mod) = divmod(width, 8)
    if mod > 0:
        n_bytes += 1
    mask = (1 << width) - 1
    if val >= mask:
        return bitarray('1' * width)
    bits = bitarray(endian='big')
    bits.frombytes(val.to_bytes(n_bytes, 'big', signed=signed))
    return bits[8 - mod if mod else 0:]

def str_to_bin(val: str, width: int, trailing_spaces: bool=False) -> bitarray:
    """
    Convert a string value to binary using six-bit ASCII encoding up to `width` chars.

    @param val:               The string to first convert to six-bit ASCII and then to binary.
    @param width:             The width of the full string
    @param trailing_spaces:   If the string has fewer characters than width, trailing '@' are added
    @return:        The binary representation of value with exactly width bits. Type is bitarray.
    """
    out = bitarray(endian='big')
    num_chars = int(width / 6)
    if trailing_spaces:
        for _ in range(num_chars - len(val)):
            val += '@'
    for char in val[:num_chars]:
        txt = to_six_bit(char)
        out += bitarray(txt)
    return out

def chk_to_int(chk_str: bytes) -> typing.Tuple[int, int]:
    """
    Converts a checksum string to a tuple of (fillbits, checksum).
    >>> chk_to_int(b"0*1B")
    (0, 27)
    """
    if not len(chk_str):
        return (0, -1)
    try:
        (a, b) = chk_str.split(b'*')
    except ValueError:
        return (0, -1)
    try:
        fill_bits: int = int(a)
    except ValueError:
        fill_bits = 0
    try:
        checksum = int(b, 16)
    except (IndexError, ValueError):
        checksum = -1
    return (fill_bits, checksum)
SYNC_MASK = 3
TIMEOUT_MASK = 7
MSG_MASK = 16383
SLOT_INCREMENT_MASK = 8191

def get_sotdma_comm_state(radio: int) -> Dict[str, typing.Optional[int]]:
    """
    The SOTDMA communication state is structured as follows:
    +-------------------+----------------------+------------------------------------------------------------------------------------------------+
    | Parameter         |  Number of bits      |  Description                                                                                   |
    +-------------------+----------------------+------------------------------------------------------------------------------------------------+
    | Sync state        |  2                   |  0 UTC direct                                                                                  |
    |                   |                      |  1 UTC indirect                                                                                |
    |                   |                      |  2 Station is synchronized to a base station                                                   |
    |                   |                      |  3 Station is synchronized to another station based on the highest number of received stations |
    | Slot time-out     |  3                   |  Specifies frames remaining until a new slot is selected                                       |
    |                   |                      |  0 means that this was the last transmission in this slot                                      |
    |                   |                      |  1-7 means that 1 to 7 frames respectively are left until slot change                          |
    | Sub message       |  14                  |  14 The sub message depends on the current value in slot time-out                              |
    +-------------------+----------------------+------------------------------------------------------------------------------------------------+

    The slot time-out defines how to interpret the sub message:
    +-----------------+---------------------------------------------------------------------------+
    | Slot time-out   |  Description                                                              |
    +-----------------+---------------------------------------------------------------------------+
    | 3, 5, 7         |  Number of receiving stations (not own station) (between 0 and 16 383)    |
    | 2, 4, 6         |  Slot number Slot number used for this transmission (between 0 and 2 249) |
    | 1               |  UTC hour (bits 13 to 9) and minute (bits 8 to 2)                         |
    | 0               |  Next frame                                                               |
    +-----------------+---------------------------------------------------------------------------+

    You may refer to:
    - https://github.com/M0r13n/pyais/issues/17
    - https://www.itu.int/dms_pubrec/itu-r/rec/m/R-REC-M.1371-1-200108-S!!PDF-E.pdf
    - https://www.navcen.uscg.gov/?pageName=AISMessagesA#Sync
    """
    result = {'received_stations': None, 'slot_number': None, 'utc_hour': None, 'utc_minute': None, 'slot_offset': None, 'slot_timeout': 0, 'sync_state': 0}
    sync_state = radio >> 17 & SYNC_MASK
    slot_timeout = radio >> 14 & TIMEOUT_MASK
    sub_msg = radio & MSG_MASK
    if slot_timeout == 0:
        result['slot_offset'] = sub_msg
    elif slot_timeout == 1:
        result['utc_hour'] = sub_msg >> 9 & 31
        result['utc_minute'] = sub_msg >> 2 & 63
    elif slot_timeout in (2, 4, 6):
        result['slot_number'] = sub_msg
    elif slot_timeout in (3, 5, 7):
        result['received_stations'] = sub_msg
    else:
        raise ValueError('Slot timeout can only be an integer between 0 and 7')
    result['sync_state'] = SyncState(sync_state)
    result['slot_timeout'] = slot_timeout
    return result

def get_itdma_comm_state(radio: int) -> Dict[str, typing.Optional[int]]:
    """
    +-----------------+------+--------------------------------------------------------------------------------+
    |    Parameter    | Bits |                                  Description                                   |
    +-----------------+------+--------------------------------------------------------------------------------+
    | Sync state      |   2  | 0 UTC direct                                                                   |
    |                 |      | 1 UTC indirec                                                                  |
    |                 |      | 2 Station is synchronized to a base station                                    |
    |                 |      | 3 Station is synchronized to another station                                   |
    | Slot increment  |  13  | Offset to next slot to be used, or zero (0) if no more transmissions           |
    | Number of slots |   3  | Number of consecutive slots to allocate. (0 = 1 slot, 1 = 2 slots,2 = 3 slots, |
    |                 |      | 3 = 4 slots, 4 = 5 slots)                                                      |
    | Keep flag       |   1  | Set to TRUE = 1 if the slot remains allocated for one additional frame         |
    +-----------------+------+--------------------------------------------------------------------------------+

    You may refer to:
    - https://github.com/M0r13n/pyais/issues/17
    - https://www.itu.int/dms_pubrec/itu-r/rec/m/R-REC-M.1371-1-200108-S!!PDF-E.pdf
    - https://www.navcen.uscg.gov/?pageName=AISMessagesA#Sync
    """
    sync_state = radio >> 17 & SYNC_MASK
    slot_increment = radio >> 4 & SLOT_INCREMENT_MASK
    num_slots = radio >> 1 & TIMEOUT_MASK
    keep_flag = radio & 1
    return {'keep_flag': keep_flag, 'sync_state': sync_state, 'slot_increment': slot_increment, 'num_slots': num_slots, 'keep_flag': keep_flag}

def get_first_three_digits(num: int) -> int:
    if num < 1000:
        return num
    digits = int(math.log10(num)) + 1
    return int(num // 10 ** (digits - 3))

def get_country(mmsi: int) -> typing.Tuple[str, str]:
    return COUNTRY_MAPPING.get(get_first_three_digits(mmsi), ('NA', 'Unknown'))

def is_auxiliary_craft(mmsi: int) -> bool:
    return 980000000 <= mmsi <= 989999999[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# echo 'def bytes2bits(data: bytes) -> typing.List[int]:
[?2004l[?2004h>     return [int(bit) for byte in data for bit in f"{byte:08b}"]
[?2004l[?2004h> ' >> util.py
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# pytest tests/test_decode.py::TestAIS::test_bytes2bits -v
[?2004l[1m===================================================================== test session starts ======================================================================[0m
platform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10
cachedir: .pytest_cache
rootdir: /workspace/repo
configfile: pyproject.toml
plugins: mock-3.15.1, timeout-2.4.0
[1mcollecting ... [0m[1mcollected 0 items                                                                                                                                              [0m

[33m==================================================================== [33mno tests ran[0m[33m in 0.00s[0m[33m =====================================================================[0m
[31mERROR: file or directory not found: tests/test_decode.py::TestAIS::test_bytes2bits
[0m
[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# cd /workspace/repo
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo# pytest tests/test_decode.py::TestAIS::test_bytes2bits -v
[?2004l[1m===================================================================== test session starts ======================================================================[0m
platform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10
cachedir: .pytest_cache
rootdir: /workspace/repo
configfile: pyproject.toml
plugins: mock-3.15.1, timeout-2.4.0
[1mcollecting ... [0m[1mcollected 0 items / 1 error                                                                                                                                    [0m

============================================================================ ERRORS ============================================================================
[31m[1m____________________________________________________________ ERROR collecting tests/test_decode.py _____________________________________________________________[0m
[31m/usr/local/lib/python3.10/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1050: in _gcd_import
    ???
<frozen importlib._bootstrap>:1027: in _find_and_load
    ???
<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:688: in _load_unlocked
    ???
/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:197: in exec_module
    exec(co, module.__dict__)
tests/test_decode.py:9: in <module>
    from pyais import NMEAMessage, encode_dict, encode_msg
pyais/__init__.py:1: in <module>
    from pyais.messages import NMEAMessage, ANY_MESSAGE, AISSentence, TagBlock
pyais/messages.py:16: in <module>
    from pyais.util import checksum, decode_into_bit_array, compute_checksum, get_itdma_comm_state, get_sotdma_comm_state, int_to_bin, str_to_bin, \
E     File "/workspace/repo/pyais/util.py", line 326
E       return 980000000 <= mmsi <= 989999999def bytes2bits(data: bytes) -> typing.List[int]:
E                                           ^
E   SyntaxError: invalid decimal literal[0m
[36m[1m=================================================================== short test summary info ====================================================================[0m
[31mERROR[0m tests/test_decode.py
[31m======================================================================= [31m[1m1 error[0m[31m in 0.27s[0m[31m =======================================================================[0m
[31mERROR: found no collectors for /workspace/repo/tests/test_decode.py::TestAIS::test_bytes2bits
[0m
[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo# sed -i '/return 980000000 <= mmsi <= 989999999/a \\n' util.py
[?2004lsed: can't read util.py: No such file or directory
[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo# cd pyais
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# sed -i '/return 980000000 <= mmsi <= 989999999/a \\n' util.py
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# cd /workspace/repo
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo# pytest tests/test_decode.py::TestAIS::test_bytes2bits -v
[?2004l[1m===================================================================== test session starts ======================================================================[0m
platform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10
cachedir: .pytest_cache
rootdir: /workspace/repo
configfile: pyproject.toml
plugins: mock-3.15.1, timeout-2.4.0
[1mcollecting ... [0m[1mcollected 0 items / 1 error                                                                                                                                    [0m

============================================================================ ERRORS ============================================================================
[31m[1m____________________________________________________________ ERROR collecting tests/test_decode.py _____________________________________________________________[0m
[31m/usr/local/lib/python3.10/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1050: in _gcd_import
    ???
<frozen importlib._bootstrap>:1027: in _find_and_load
    ???
<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:688: in _load_unlocked
    ???
/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:197: in exec_module
    exec(co, module.__dict__)
tests/test_decode.py:9: in <module>
    from pyais import NMEAMessage, encode_dict, encode_msg
pyais/__init__.py:1: in <module>
    from pyais.messages import NMEAMessage, ANY_MESSAGE, AISSentence, TagBlock
pyais/messages.py:16: in <module>
    from pyais.util import checksum, decode_into_bit_array, compute_checksum, get_itdma_comm_state, get_sotdma_comm_state, int_to_bin, str_to_bin, \
E     File "/workspace/repo/pyais/util.py", line 326
E       return 980000000 <= mmsi <= 989999999def bytes2bits(data: bytes) -> typing.List[int]:
E                                           ^
E   SyntaxError: invalid decimal literal[0m
[36m[1m=================================================================== short test summary info ====================================================================[0m
[31mERROR[0m tests/test_decode.py
[31m======================================================================= [31m[1m1 error[0m[31m in 0.11s[0m[31m =======================================================================[0m
[31mERROR: found no collectors for /workspace/repo/tests/test_decode.py::TestAIS::test_bytes2bits
[0m
[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo# cd pyais
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# sed -i '/return 980000000 <= mmsi <= 989999999/a\\n' util.py
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# cd /workspace/repo
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo# pytest tests/test_decode.py::TestAIS::test_bytes2bits -v
[?2004l[1m===================================================================== test session starts ======================================================================[0m
platform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10
cachedir: .pytest_cache
rootdir: /workspace/repo
configfile: pyproject.toml
plugins: mock-3.15.1, timeout-2.4.0
[1mcollecting ... [0m[1mcollected 0 items / 1 error                                                                                                                                    [0m

============================================================================ ERRORS ============================================================================
[31m[1m____________________________________________________________ ERROR collecting tests/test_decode.py _____________________________________________________________[0m
[31m/usr/local/lib/python3.10/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1050: in _gcd_import
    ???
<frozen importlib._bootstrap>:1027: in _find_and_load
    ???
<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:688: in _load_unlocked
    ???
/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:197: in exec_module
    exec(co, module.__dict__)
tests/test_decode.py:9: in <module>
    from pyais import NMEAMessage, encode_dict, encode_msg
pyais/__init__.py:1: in <module>
    from pyais.messages import NMEAMessage, ANY_MESSAGE, AISSentence, TagBlock
pyais/messages.py:16: in <module>
    from pyais.util import checksum, decode_into_bit_array, compute_checksum, get_itdma_comm_state, get_sotdma_comm_state, int_to_bin, str_to_bin, \
E     File "/workspace/repo/pyais/util.py", line 326
E       return 980000000 <= mmsi <= 989999999def bytes2bits(data: bytes) -> typing.List[int]:
E                                           ^
E   SyntaxError: invalid decimal literal[0m
[36m[1m=================================================================== short test summary info ====================================================================[0m
[31mERROR[0m tests/test_decode.py
[31m======================================================================= [31m[1m1 error[0m[31m in 0.11s[0m[31m =======================================================================[0m
[31mERROR: found no collectors for /workspace/repo/tests/test_decode.py::TestAIS::test_bytes2bits
[0m
[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo# cd pyais
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# vi util.py
[?2004lbash: vi: command not found
[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# ed util.py
[?2004lbash: ed: command not found
[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# ex util.py
[?2004lbash: ex: command not found
[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# cat util.py
[?2004limport base64
import math
import typing
from collections import OrderedDict
from functools import partial, reduce
from operator import xor
from typing import Any, Generator, Hashable, TYPE_CHECKING, Union, Dict
from bitarray import bitarray
from pyais.constants import COUNTRY_MAPPING, SyncState
from pyais.exceptions import NonPrintableCharacterException
if TYPE_CHECKING:
    BaseDict = OrderedDict[Hashable, Any]
else:
    BaseDict = OrderedDict
from_bytes = partial(int.from_bytes, byteorder='big')
from_bytes_signed = partial(int.from_bytes, byteorder='big', signed=True)
T = typing.TypeVar('T')

def decode_into_bit_array(data: bytes, fill_bits: int=0) -> bitarray:
    """
    Decodes a raw AIS message into a bitarray.
    :param data:        Raw AIS message in bytes
    :param fill_bits:   Number of trailing fill bits to be ignored
    :return:
    """
    bit_str = ''
    length = len(data)
    for (i, c) in enumerate(data):
        if not 32 <= c <= 126:
            raise NonPrintableCharacterException(f"Non printable character: '{hex(c)}'")
        c -= 48 if c < 96 else 56
        c &= 63
        if i == length - 1 and fill_bits:
            c = c >> fill_bits
            bit_str += f'{c:b}'.zfill(6 - fill_bits)
        else:
            bit_str += f'{c:06b}'
    bit_arr = bitarray(bit_str)
    return bit_arr

def chunks(sequence: typing.Sequence[T], n: int) -> Generator[typing.Sequence[T], None, None]:
    """Yield successive n-sized chunks from sequence."""
    return (sequence[i:i + n] for i in range(0, len(sequence), n))

def decode_bin_as_ascii6(bit_arr: bitarray) -> str:
    """
    Decode binary data as 6 bit ASCII.
    :param bit_arr: array of bits
    :return: ASCII String
    """
    string: str = ''
    c: bitarray
    for c in chunks(bit_arr, 6):
        n: int = from_bytes(c.tobytes()) >> 2
        if len(c) != 6:
            n >>= 6 - len(c)
        if n < 32:
            n += 64
        if n == 64:
            break
        string += chr(n)
    return string.strip()

def get_int(data: bitarray, ix_low: int, ix_high: int, signed: bool=False) -> int:
    """
    Cast a subarray of a bitarray into an integer.
    The bitarray module adds tailing zeros when calling tobytes(), if the bitarray is not a multiple of 8.
    So those need to be shifted away.
    :param data: some bitarray
    :param ix_low: the lower index of the sub-array
    :param ix_high: the upper index of the sub-array
    :param signed: True if the value should be interpreted as a signed integer
    :return: a normal integer (int)
    """
    shift: int = (8 - (ix_high - ix_low) % 8) % 8
    data = data[ix_low:ix_high]
    i: int = from_bytes_signed(data) if signed else from_bytes(data)
    return i >> shift

def checksum(sentence: bytes) -> int:
    """
    Compute the NMEA checksum for a payload.
    :param sentence: The sentence to compute the checksum for. MUST BE bytes.

    >>> checksum(b's:2573535,c:1671533231')
    8
    """
    checksum = reduce(xor, sentence)
    return checksum

def compute_checksum(msg: Union[str, bytes]) -> int:
    """
    Compute the checksum of a given message.
    This method takes the **whole** message including the leading `!`.

    >>> compute_checksum(b"!AIVDM,1,1,,B,15M67FC000G?ufbE`FepT@3n00Sa,0")
    91

    :param msg: message
    :return: int value of the checksum. Format as hex with `f'{checksum:02x}'`
    """
    if isinstance(msg, str):
        msg = msg.encode()
    msg = msg[1:].split(b'*', 1)[0]
    return reduce(xor, msg)
PAYLOAD_ARMOR = {0: '0', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: ':', 11: ';', 12: '<', 13: '=', 14: '>', 15: '?', 16: '@', 17: 'A', 18: 'B', 19: 'C', 20: 'D', 21: 'E', 22: 'F', 23: 'G', 24: 'H', 25: 'I', 26: 'J', 27: 'K', 28: 'L', 29: 'M', 30: 'N', 31: 'O', 32: 'P', 33: 'Q', 34: 'R', 35: 'S', 36: 'T', 37: 'U', 38: 'V', 39: 'W', 40: '`', 41: 'a', 42: 'b', 43: 'c', 44: 'd', 45: 'e', 46: 'f', 47: 'g', 48: 'h', 49: 'i', 50: 'j', 51: 'k', 52: 'l', 53: 'm', 54: 'n', 55: 'o', 56: 'p', 57: 'q', 58: 'r', 59: 's', 60: 't', 61: 'u', 62: 'v', 63: 'w'}
SIX_BIT_ENCODING = {'@': 0, 'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5, 'F': 6, 'G': 7, 'H': 8, 'I': 9, 'J': 10, 'K': 11, 'L': 12, 'M': 13, 'N': 14, 'O': 15, 'P': 16, 'Q': 17, 'R': 18, 'S': 19, 'T': 20, 'U': 21, 'V': 22, 'W': 23, 'X': 24, 'Y': 25, 'Z': 26, '[': 27, '\\': 28, ']': 29, '^': 30, '_': 31, ' ': 32, '!': 33, '"': 34, '#': 35, '$': 36, '%': 37, '&': 38, "'": 39, '(': 40, ')': 41, '*': 42, '+': 43, ',': 44, '-': 45, '.': 46, '/': 47, '0': 48, '1': 49, '2': 50, '3': 51, '4': 52, '5': 53, '6': 54, '7': 55, '8': 56, '9': 57, ':': 58, ';': 59, '<': 60, '=': 61, '>': 62, '?': 63}

def to_six_bit(char: str) -> str:
    """
    Encode a single character as six-bit bitstring.
    @param char: The character to encode
    @return: The six-bit representation as string
    """
    char = char.upper()
    try:
        encoding = SIX_BIT_ENCODING[char]
        return f'{encoding:06b}'
    except KeyError:
        raise ValueError(f"received char '{char}' that cant be encoded")

def encode_ascii_6(bits: bitarray) -> typing.Tuple[str, int]:
    """
    Transform the bitarray to an ASCII-encoded bit vector.
    Each character represents six bits of data.
    @param bits: The bitarray to convert to an ASCII-encoded bit vector.
    @return: ASCII-encoded bit vector and the number of fill bits required to pad the data payload to a 6 bit boundary.
    """
    out = ''
    chunk: bitarray
    padding = 0
    for chunk in chunks(bits, 6):
        padding = 6 - len(chunk)
        num = from_bytes(chunk.tobytes()) >> 2
        armor = PAYLOAD_ARMOR[num]
        out += armor
    return (out, padding)

def int_to_bytes(val: typing.Union[int, bytes]) -> int:
    """
    Convert a bytes object to an integer. Byteorder is big.

    @param val: A bytes object to convert to an int. If the value is already an int, this is a NO-OP.
    @return: Integer representation of `val`
    """
    if isinstance(val, int):
        return val
    return int.from_bytes(val, 'big')

def bits2bytes(bits: typing.Union[str, bitarray]) -> bytes:
    """
    Convert a bitstring or a bitarray to bytes.
    >>> bits2bytes('00100110')
    b'&'
    """
    bits = bitarray(bits)
    return bits.tobytes()

def bytes2bits(in_bytes: bytes, default: typing.Optional[bitarray]=None) -> bitarray:
    """
    TODO: Implement this function
    """
    ...

def b64encode_str(val: bytes, encoding: str='utf-8') -> str:
    """BASE64 encoded a bytes string and returns the result as UTF-8 string"""
    return base64.b64encode(val).decode(encoding)

def coerce_val(val: typing.Any, d_type: typing.Type[T]) -> T:
    """Forces a given value in a given datatype"""
    if d_type == bytes and (not isinstance(val, bytes)):
        raise ValueError(f'Expected bytes, but got: {type(val)}')
    return d_type(val)

def int_to_bin(val: typing.Union[int, bool], width: int, signed: bool=True) -> bitarray:
    """
    Convert an integer or boolean value to binary. If the value is too great to fit into
    `width` bits, the maximum possible number that still fits is used.

    @param val:     Any integer or boolean value.
    @param width:   The bit width. If less than width bits are required, leading zeros are added.
    @param signed:  Set to True/False if the value is signed or not.
    @return:        The binary representation of value with exactly width bits. Type is bitarray.
    """
    (n_bytes, mod) = divmod(width, 8)
    if mod > 0:
        n_bytes += 1
    mask = (1 << width) - 1
    if val >= mask:
        return bitarray('1' * width)
    bits = bitarray(endian='big')
    bits.frombytes(val.to_bytes(n_bytes, 'big', signed=signed))
    return bits[8 - mod if mod else 0:]

def str_to_bin(val: str, width: int, trailing_spaces: bool=False) -> bitarray:
    """
    Convert a string value to binary using six-bit ASCII encoding up to `width` chars.

    @param val:               The string to first convert to six-bit ASCII and then to binary.
    @param width:             The width of the full string
    @param trailing_spaces:   If the string has fewer characters than width, trailing '@' are added
    @return:        The binary representation of value with exactly width bits. Type is bitarray.
    """
    out = bitarray(endian='big')
    num_chars = int(width / 6)
    if trailing_spaces:
        for _ in range(num_chars - len(val)):
            val += '@'
    for char in val[:num_chars]:
        txt = to_six_bit(char)
        out += bitarray(txt)
    return out

def chk_to_int(chk_str: bytes) -> typing.Tuple[int, int]:
    """
    Converts a checksum string to a tuple of (fillbits, checksum).
    >>> chk_to_int(b"0*1B")
    (0, 27)
    """
    if not len(chk_str):
        return (0, -1)
    try:
        (a, b) = chk_str.split(b'*')
    except ValueError:
        return (0, -1)
    try:
        fill_bits: int = int(a)
    except ValueError:
        fill_bits = 0
    try:
        checksum = int(b, 16)
    except (IndexError, ValueError):
        checksum = -1
    return (fill_bits, checksum)
SYNC_MASK = 3
TIMEOUT_MASK = 7
MSG_MASK = 16383
SLOT_INCREMENT_MASK = 8191

def get_sotdma_comm_state(radio: int) -> Dict[str, typing.Optional[int]]:
    """
    The SOTDMA communication state is structured as follows:
    +-------------------+----------------------+------------------------------------------------------------------------------------------------+
    | Parameter         |  Number of bits      |  Description                                                                                   |
    +-------------------+----------------------+------------------------------------------------------------------------------------------------+
    | Sync state        |  2                   |  0 UTC direct                                                                                  |
    |                   |                      |  1 UTC indirect                                                                                |
    |                   |                      |  2 Station is synchronized to a base station                                                   |
    |                   |                      |  3 Station is synchronized to another station based on the highest number of received stations |
    | Slot time-out     |  3                   |  Specifies frames remaining until a new slot is selected                                       |
    |                   |                      |  0 means that this was the last transmission in this slot                                      |
    |                   |                      |  1-7 means that 1 to 7 frames respectively are left until slot change                          |
    | Sub message       |  14                  |  14 The sub message depends on the current value in slot time-out                              |
    +-------------------+----------------------+------------------------------------------------------------------------------------------------+

    The slot time-out defines how to interpret the sub message:
    +-----------------+---------------------------------------------------------------------------+
    | Slot time-out   |  Description                                                              |
    +-----------------+---------------------------------------------------------------------------+
    | 3, 5, 7         |  Number of receiving stations (not own station) (between 0 and 16 383)    |
    | 2, 4, 6         |  Slot number Slot number used for this transmission (between 0 and 2 249) |
    | 1               |  UTC hour (bits 13 to 9) and minute (bits 8 to 2)                         |
    | 0               |  Next frame                                                               |
    +-----------------+---------------------------------------------------------------------------+

    You may refer to:
    - https://github.com/M0r13n/pyais/issues/17
    - https://www.itu.int/dms_pubrec/itu-r/rec/m/R-REC-M.1371-1-200108-S!!PDF-E.pdf
    - https://www.navcen.uscg.gov/?pageName=AISMessagesA#Sync
    """
    result = {'received_stations': None, 'slot_number': None, 'utc_hour': None, 'utc_minute': None, 'slot_offset': None, 'slot_timeout': 0, 'sync_state': 0}
    sync_state = radio >> 17 & SYNC_MASK
    slot_timeout = radio >> 14 & TIMEOUT_MASK
    sub_msg = radio & MSG_MASK
    if slot_timeout == 0:
        result['slot_offset'] = sub_msg
    elif slot_timeout == 1:
        result['utc_hour'] = sub_msg >> 9 & 31
        result['utc_minute'] = sub_msg >> 2 & 63
    elif slot_timeout in (2, 4, 6):
        result['slot_number'] = sub_msg
    elif slot_timeout in (3, 5, 7):
        result['received_stations'] = sub_msg
    else:
        raise ValueError('Slot timeout can only be an integer between 0 and 7')
    result['sync_state'] = SyncState(sync_state)
    result['slot_timeout'] = slot_timeout
    return result

def get_itdma_comm_state(radio: int) -> Dict[str, typing.Optional[int]]:
    """
    +-----------------+------+--------------------------------------------------------------------------------+
    |    Parameter    | Bits |                                  Description                                   |
    +-----------------+------+--------------------------------------------------------------------------------+
    | Sync state      |   2  | 0 UTC direct                                                                   |
    |                 |      | 1 UTC indirec                                                                  |
    |                 |      | 2 Station is synchronized to a base station                                    |
    |                 |      | 3 Station is synchronized to another station                                   |
    | Slot increment  |  13  | Offset to next slot to be used, or zero (0) if no more transmissions           |
    | Number of slots |   3  | Number of consecutive slots to allocate. (0 = 1 slot, 1 = 2 slots,2 = 3 slots, |
    |                 |      | 3 = 4 slots, 4 = 5 slots)                                                      |
    | Keep flag       |   1  | Set to TRUE = 1 if the slot remains allocated for one additional frame         |
    +-----------------+------+--------------------------------------------------------------------------------+

    You may refer to:
    - https://github.com/M0r13n/pyais/issues/17
    - https://www.itu.int/dms_pubrec/itu-r/rec/m/R-REC-M.1371-1-200108-S!!PDF-E.pdf
    - https://www.navcen.uscg.gov/?pageName=AISMessagesA#Sync
    """
    sync_state = radio >> 17 & SYNC_MASK
    slot_increment = radio >> 4 & SLOT_INCREMENT_MASK
    num_slots = radio >> 1 & TIMEOUT_MASK
    keep_flag = radio & 1
    return {'keep_flag': keep_flag, 'sync_state': sync_state, 'slot_increment': slot_increment, 'num_slots': num_slots, 'keep_flag': keep_flag}

def get_first_three_digits(num: int) -> int:
    if num < 1000:
        return num
    digits = int(math.log10(num)) + 1
    return int(num // 10 ** (digits - 3))

def get_country(mmsi: int) -> typing.Tuple[str, str]:
    return COUNTRY_MAPPING.get(get_first_three_digits(mmsi), ('NA', 'Unknown'))

def is_auxiliary_craft(mmsi: int) -> bool:
    return 980000000 <= mmsi <= 989999999def bytes2bits(data: bytes) -> typing.List[int]:




    return [int(bit) for byte in data for bit in f"{byte:08b}"]

[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# cd /workspace/repo
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo# pytest tests/test_decode.py::TestAIS::test_bytes2bits -v
[?2004l[1m===================================================================== test session starts ======================================================================[0m
platform linux -- Python 3.10.19, pytest-9.0.2, pluggy-1.6.0 -- /usr/local/bin/python3.10
cachedir: .pytest_cache
rootdir: /workspace/repo
configfile: pyproject.toml
plugins: mock-3.15.1, timeout-2.4.0
[1mcollecting ... [0m[1mcollected 0 items / 1 error                                                                                                                                    [0m

============================================================================ ERRORS ============================================================================
[31m[1m____________________________________________________________ ERROR collecting tests/test_decode.py _____________________________________________________________[0m
[31m/usr/local/lib/python3.10/site-packages/_pytest/python.py:507: in importtestmodule
    mod = import_path(
/usr/local/lib/python3.10/site-packages/_pytest/pathlib.py:587: in import_path
    importlib.import_module(module_name)
/usr/local/lib/python3.10/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1050: in _gcd_import
    ???
<frozen importlib._bootstrap>:1027: in _find_and_load
    ???
<frozen importlib._bootstrap>:1006: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:688: in _load_unlocked
    ???
/usr/local/lib/python3.10/site-packages/_pytest/assertion/rewrite.py:197: in exec_module
    exec(co, module.__dict__)
tests/test_decode.py:9: in <module>
    from pyais import NMEAMessage, encode_dict, encode_msg
pyais/__init__.py:1: in <module>
    from pyais.messages import NMEAMessage, ANY_MESSAGE, AISSentence, TagBlock
pyais/messages.py:16: in <module>
    from pyais.util import checksum, decode_into_bit_array, compute_checksum, get_itdma_comm_state, get_sotdma_comm_state, int_to_bin, str_to_bin, \
E     File "/workspace/repo/pyais/util.py", line 326
E       return 980000000 <= mmsi <= 989999999def bytes2bits(data: bytes) -> typing.List[int]:
E                                           ^
E   SyntaxError: invalid decimal literal[0m
[36m[1m=================================================================== short test summary info ====================================================================[0m
[31mERROR[0m tests/test_decode.py
[31m======================================================================= [31m[1m1 error[0m[31m in 0.11s[0m[31m =======================================================================[0m
[31mERROR: found no collectors for /workspace/repo/tests/test_decode.py::TestAIS::test_bytes2bits
[0m
[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo# cd pyais
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# echo '    return 980000000 <= mmsi <= 989999999
[?2004l[?2004h> 
[?2004l[?2004h> def bytes2bits(data: bytes) -> typing.List[int]:
[?2004l[?2004h>     return [int(bit) for byte in data for bit in f"{byte:08b}"]' > temp.py
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# tail -n +1 util.py | head -n -1 >> temp.py
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# mv temp.py util.py
[?2004l[?2004hroot@7ede15ef-efb4-449e-872e-58658028a822:/workspace/repo/pyais# 